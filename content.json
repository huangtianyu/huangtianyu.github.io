{"meta":{"title":"天宇","subtitle":null,"description":null,"author":"黄天宇","url":"http://yoursite.com"},"pages":[{"title":"前端","date":"2018-01-17T09:44:10.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"前端/index.html","permalink":"http://yoursite.com/前端/index.html","excerpt":"","text":"前端内容很多，也有很多框架，这里推荐几个网站供大家学习：W3school菜鸟教程"},{"title":"关于","date":"2018-01-03T15:57:53.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"关于/index.html","permalink":"http://yoursite.com/关于/index.html","excerpt":"","text":"关于博主本博客暂时只为巩固博主我学习的东西。多学点东西总是好的，积少成多，也许哪一天哪一个知识能救我一命了。志向不大，搭建本博客只为学习。微信号：MingTian–Hello微博号：tianyu240 博客历史2017.12.27, 搭建个人博客；2018.1.4, 编写关于 有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。"},{"title":"工具","date":"2018-01-17T07:39:44.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"工具/index.html","permalink":"http://yoursite.com/工具/index.html","excerpt":"","text":"平时代码写多了，有些常用的操作就想写个小工具，然后点击即可完成。于是我就利用闲暇时间写了下面两个小工具，大家没事可以下载试玩一下。还是挺方便的。后续会持续更新小工具里面的内容，尽量包含更多的工具。 测试小工具测试小工具是由于Android调试的，里面有很多Android常用的工具以及部分电脑工具。下载地址如下（CSDN下载最低分得有2分，我也很无奈）：测试小工具 字符小工具常用的字符处理工具，简单方便。下载地址如下（CSDN下载最低分得有2分，我也很无奈）：字符串小工具"},{"title":"常用Android资源","date":"2018-01-17T10:08:29.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"资源/index.html","permalink":"http://yoursite.com/资源/index.html","excerpt":"","text":"常用工具• bandicoot - 一个Python工具箱，用于分析手机元数据。它提供了一个完整，易于使用的环境，数据科学家分析手机元数据。只需几行代码，加载数据集，可视化数据，执行分析和导出结果。• Android Connections Forensics- 使法庭调查员能够连接到其原始进程• Android Forensics- 开源Android Forensics应用程序和框架• Android Data Extractor Lite• BitPim - 一个程序，允许您查看和操纵数据在LG，三星，三洋和其他制造商的许多CDMA手机。• fridump- 一个开源内存转储工具，主要针对渗透测试人员和开发人员。• LiME- （以前称为DMD）是一个可加载内核模块（LKM），它允许从Linux和基于Linux的设备（如Android提供的设备）中获取易失性内存。• Open Source Android Forensics• Project RetroScope• P2P-ADB - 电话到手机Android Debug Bridge - 一个用于从其他手机“调试”手机的项目。• pySimReader - 它允许用户写出任意原始SMS PDU到SIM卡。 开发工具• Android SDK - Android软件开发工具包（SDK）包括一整套开发工具。这些包括调试器，库，基于QEMU的手持机仿真器，文档，示例代码和教程。• Android NDK - NDK是一个工具集，允许您使用本地代码语言（如C和C ++）来实现应用程序的各个部分。• ADT Bundle - Android开发工具（ADT）包是一个单一的下载，包含开发人员开始创建Android应用程序的一切。Native Android Runtime Emulation- 本机Android仿真器。 静态分析工具• Amandroid - 一个数据流分析框架的Android应用程序的安全审查。• Androwarn - 另一个静态代码分析器的恶意Android应用程序• ApkAnalyser - 一个静态的虚拟分析工具，用于检查和验证Android应用程序的开发工作。• APKInspector- 一个强大的GUI工具，分析人员分析Android应用程序。• droid-hunter - Android应用程序漏洞分析和pentesting工具。• Error-Prone - 将常见的Java错误作为编译时错误• FindBugs + FindSecurityBugs - FindSecurityBugs是FindBugs的扩展，包括Java应用程序的安全规则。它会找到加密问题以及Android的具体问题。• FlowDroid - FlowDroid是一个用于Android应用程序的上下文，对敏感对象和生命周期的静态分析工具。• Lint- Android lint工具是一个静态代码分析工具，检查您的Android项目源文件的潜在错误和优化改进正确性，安全性，性能，可用性，可访问性和国际化。• Smali CFGs - Smali控制流程图• Smali和Baksmali- smali / baksmali是dalvik使用的dex格式的汇编/反汇编器，Android的Java VM实现。• SPARTA- SPARTA项目（可靠可信应用程序的静态程序分析）正在构建一个工具集，以验证手机应用程序的安全性。• Thresher- thresher是一个静态分析工具，专门检查堆可达性。以便对由分析点报告的警报进行精确的符号分析。• VectorAttackScanner– 这种工具用于分析Android应用程序以检测攻击点，例如接收器，服务，进程和库 动态分析工具• Android Hooker - 此项目提供了各种工具和应用程序，可用于自动拦截和修改目标应用程序所做的任何API调用。• AppAudit- 在线工具（包括一个API）使用动态和静态分析检测应用程序中的隐藏数据泄漏。• BareDroid- 在Android设备上大规模支持裸机分析。• CuckooDroid- Cuckoo Sandbox的扩展，CuckooDroid带来了执行和分析Android应用程序到Cuckoo的功能。• Droidbox- DroidBox是开发来提供Android应用程序的动态分析• Droid-FF - Droid-FF是一个可扩展的模糊框架Android• Drozer- Drozer允许您通过承担应用程序的角色并与Dalvik VM，其他应用程序的IPC端点和基础操作系统交互来搜索应用程序和设备中的安全漏洞。• Marvin- Marvin是一个分析Android应用程序以搜索漏洞的系统，并允许通过其版本历史跟踪应用程序。• Inspeckage- Inspeckage是一个为Android应用程序提供动态分析的工具。通过应用hook到Android API的功能，Inspeckage将帮助您了解Android应用程序在运行时做什么。• PATDroid- 用于分析Android应用程序和系统本身的工具和数据结构集合。形成AppAudit的基础。 逆向工程工具• Androguard- 反向工程，Android应用程序的恶意软件和好的软件分析• Android Apk decompiler - 在线反编译为Apk和Dex Android文件• Android loadble内核模块 - 它主要用于在受控系统/仿真器上进行反转和调试。• AndBug- Android调试库• ApkTool- 用于反向工程Android Apk文件的工具• APK Studio- APK Studio是一个IDE，用于在单个用户界面中反编译/编辑然后重新编译Android应用程序二进制文件。• Bytecode-Viewer - 一个Java 8 Jar和Android APK反向工程套件（解码器，编辑器，调试器等）• ClassyShark- Android可执行文件浏览器，用于分析APK。• CodeInspect- 用于Android和Java应用程序的基于Jimple的反向工程框架。• dedex - 用于反汇编Android DEX文件的命令行工具。• dextra- dextra实用程序开始了它的生命，作为AOSP的dexdump和dx - dump的替代品，两者都相当基本，并产生丰富，但非结构化的输出。除了支持所有的功能，它还支持各种输出模式，特定类，方法和字段查找，以及确定静态字段值。我更新了它以支持ART• Dex2Jar- 使用android .dex和java .class文件的工具• dexdisassembler- 一个用于拆卸Android DEX文件的GTK工具。• Enjarify- Enjarify是一个工具，用于将Dalvik字节码转换为等效的Java字节码。这允许Java分析工具分析Android应用程序。• Fern Flower - FernFlower Java反编译器• Fino- Android小型检测工具• Introspy-Android - Blackbox工具来帮助了解Android应用程序在运行时做什么，并帮助识别潜在的安全问题。• JD-Gui- 快速Java解压缩器，方便阅读java源代码• JEB - 交互Android Decompiler• Lobotomy- Lobotomy是一个Android安全工具包，将自动执行不同的Android评估和逆向工程任务。Lobotomy工具包的目标是提供一个控制台环境，允许用户加载其目标Android APK一次，然后拥有所有必要的工具，而不需要退出该环境。1.2版本将保持开源。• smali- Android的dex格式的汇编/反汇编程序• smali_emulator - 模拟由apktool生成的smali源文件，例如，以便在APKs中取消模糊处理和加密。• Strongdb- Strongdb是一个用Python编写的gdb插件，用于帮助调试Android Native程序。主要代码使用gdb Python API。• Xenotix APK Reverser - 一个开源的Android应用程序包（APK）反编译和反汇编由dex2jar，baksmali和jd-core hooking工具• ADBI- Android动态二进制测试（ADBI）是一种用于动态跟踪Android本机层的工具。• Cydia Substrate - 适用于Android的Cydia Substrate支持开发人员使用注入到目标进程内存中的Substrate扩展对现有软件进行更改。• Diff-GUI - 用于在Android上注入JavaScript的GUI（使用Frida）• Dynamic Dalvik Instrumentation Toolkit - 简单易用的Dalvik代码动态仪器工具包。• Frida - 注册JavaScript以探索Android上的本机应用• Xposed框架 - Xposed框架使您能够在运行时修改系统或应用程序方面和行为，而无需修改任何Android应用程序包（APK）。 在线分析• Android Observatory - Android Observatory是一个面向大量Android应用程序存储库的Web界面。它允许用户搜索或浏览成千上万的Android应用程序，并检索这些应用程序的原数据。• Android APK Decompiler - 解压APK文件变得容易。在线反编译。• AndroidTotal- AndroTotal是一个免费的服务，扫描可疑APK与多个手机防病毒应用程序。• Anubis- 未知二进制文件的恶意软件分析。• Akana- Akana是一个在线Android应用程序Interactive Analysis Enviroment（IAE），它结合一些插件来检查恶意应用程序。• App360Scan- 说明应用程序使用的权限，以及它可能对用户造成的危害。• CopperDroid- 它自动执行Android恶意软件的开箱即用的动态行为分析。• Dexter- Dexter是一个具有协作功能的交互式Android软件分析环境。• Eacus- Android Lite应用分析框架• Mobile Sandbox - 移动沙箱提供静态和动态恶意软件分析，结合Android应用程序的机器学习技术。• NVISO ApkScan - NVISO的ApkScan web应用程序允许您扫描Android应用程序的恶意软件。• Sandroid- 一个自动Android应用程序分析系统• Virus Total - VirusTotal是一个免费的服务，可以分析可疑文件和URL，并有助于快速检测病毒，蠕虫，木马和各种恶意软件。 教程• Android Application Security Series - 一个简单和详细的Android应用程序安全系列。有益于Android安全专业人员和开发人员。• Android Forensics Course• ARM简介• Android Security Articles By Infosec Institute• Learning Android Bytecode 最佳实践• NIST网络安全实践指南：“移动设备安全：云和混合构建”• Android安全概述• 开发人员的Android安全提示• 移动应用渗透测试备忘录• MobileAppReportCard：Microsoft Excel电子表格，用于对Android和iOS移动应用程序进行一致的安全评估• 项目/ OWASP移动安全项目 - 十大移动控制• 开发商PCI移动支付接受安全指南• Android中的安全编码• Android应用程序安全设计/安全编码指南"},{"title":"后端","date":"2018-01-17T09:44:16.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"后端/index.html","permalink":"http://yoursite.com/后端/index.html","excerpt":"","text":"简介基于Java的JavaWeb现在已经很成熟，有很多框架可以使用。诸如Spring+Struts+Hibernate，或者Spring+Struts+Ibatis(MyBatis)。轻轻松松即可搭建一个后台服务，这里我主要推荐几篇大牛博客，为自己也为别人。 推荐以下资源整理引用自：GitHub常用Java资源 Awesome Java Bean Mapping Build Bytecode Manipulation Caching Cluster Management Code Analysis Code Coverage Code Generators Command-line Argument Parsers Compiler-compiler Configuration Constraint Satisfaction Problem Solver CSV Data structures Database Date and Time Dependency Injection Development Distributed Applications Distributed Transactions Distribution Document Processing Formal Verification Functional Programming Game Development Geospatial GUI High Performance HTTP Clients Hypermedia Types IDE Imagery JSON Processing JSON JVM and JDK Logging Machine Learning Messaging Microservice Miscellaneous Monitoring Native Natural Language Processing Networking ORM PaaS PDF Performance analysis Platform Reactive libraries REST Frameworks Science Search Security Serialization Server Template Engine Testing Utility Version Managers Web Crawling Web Frameworks Resources Awesome Lists Communities Frontends Influential Books Podcasts and Screencasts Twitter Websites Contributing Bean MappingFrameworks that ease bean mapping. Dozer - Mapper that copies data from one object to another using annotations and API or XML configuration. JMapper - Uses byte code manipulation for lightning-fast mapping. Supports annotations and API or XML configuration. MapStruct - Code generator that simplifies mappings between different bean types, based on a convention-over-configuration approach. ModelMapper - Intelligent object mapping library that automatically maps objects to each other. Orika - JavaBean-mapping framework that recursively copies (among other capabilities) data from one object to another. Selma - Annotation processor-based bean mapper. BuildTools that handle the build cycle and dependencies of an application. Apache Maven - Declarative build and dependency management that favors convention over configuration. It might be preferable to Apache Ant, which uses a rather procedural approach and can be difficult to maintain. Bazel - Tool from Google that builds code quickly and reliably. Gradle - Incremental builds programmed via Groovy instead of declaring XML. Works well with Maven’s dependency management. Bytecode ManipulationLibraries to manipulate bytecode programmatically. ASM - All-purpose, low-level bytecode manipulation and analysis. Byte Buddy - Further simplifies bytecode generation with a fluent API. Byteman - Manipulate bytecode at runtime via DSL (rules); mainly for testing/troubleshooting. cglib - Bytecode generation library. Javassist - Tries to simplify bytecode editing. CachingLibraries that provide caching facilities. Caffeine - High-performance, near-optimal caching library. Ehcache - Distributed general-purpose cache. Infinispan - Highly concurrent key/value datastore used for caching. Cluster ManagementFrameworks that can dynamically manage applications inside of a cluster. Apache Aurora - Mesos framework for long-running services and cron jobs. Apache Mesos - Abstracts CPU, memory, storage, and other compute resources away from machines. Singularity - Mesos framework that makes deployment and operations easy. It supports web services, background workers, scheduled jobs, and one-off tasks. Code AnalysisTools that provide metrics and quality measurements. Checkstyle - Static analysis of coding conventions and standards. Error Prone - Catches common programming mistakes as compile-time errors. Infer - Modern static analysis tool for verifying the correctness of code. jQAssistant - Static code analysis with Neo4J-based query language. NullAway - Eliminates NullPointerExceptions with low build-time overhead. PMD - Source code analysis for finding bad coding practices. SonarJava - Static analyzer for SonarQube &amp; SonarLint. Sourcetrail - Visual source code navigator. Spoon - Library for analyzing and transforming Java source code. Spotbugs - Static analysis of bytecode to find potential bugs. Code CoverageFrameworks and tools that enable code coverage metrics collection for test suites. Clover - Relies on source-code instrumentation instead of bytecode instrumentation. Cobertura - Relies on offline (or static) bytecode instrumentation and class loading to collect code coverage metrics. JaCoCo - Framework that enables collection of code coverage metrics, using both offline and runtime bytecode instrumentation. Code GeneratorsTools that generate patterns for repetitive code in order to reduce verbosity and error-proneness. ADT4J - JSR-269 code generator for algebraic data types. Auto - Generates factory, service, and value classes. FreeBuilder - Automatically generates the Builder pattern. Immutables - Annotation processors to generate simple, safe and consistent value objects. JavaPoet - API to generate source files. JHipster - Yeoman source code generator for Spring Boot and AngularJS. Joda-Beans - Small framework that adds queryable properties to Java, enhancing JavaBeans. Lombok - Code generator that aims to reduce verbosity. Command-line Argument ParsersLibraries that make it easy to parse command line options, arguments, etc. Airline - Annotation-based framework for parsing Git-like command-line arguments. args4j - Small library to parse command-line arguments. JCommander - Command-line argument-parsing framework with custom types and validation via implementing interfaces. JOpt Simple - Simple parser that uses the POSIX getopt() and GNU getopt_long() syntaxes. Uses a fluent API instead of annotations. picocli - ANSI colors and styles in usage help. Can be included as source to avoid dependency. Annotation-based, POSIX/GNU/any syntax, subcommands, strong typing for both options and positional args. Compiler-compilerFrameworks that help to create parsers, interpreters or compilers. ANTLR - Complex full-featured framework for top-down parsing. JFlex - A lexical analyzer generator. ConfigurationLibraries that provide external configuration. centraldogma - Highly-available version-controlled service configuration repository based on Git, ZooKeeper and HTTP/2. cfg4j - Modern configuration library for distributed apps written in Java. config - Configuration library for JVM languages. dotenv - A twelve-factor configuration library for Java. ini4j - Provides an API for handling Windows’ INI files. KAConf - Annotation-based configuration system for Java and Kotlin. owner - Reduces boilerplate of properties. Constraint Satisfaction Problem SolverLibraries that help with implementing optimization and satisfiability problems. Choco - Off-the-shelf constraint satisfaction problem solver that uses constraint programming techniques. JaCoP - Includes an interface for the FlatZinc language, enabling it to execute MiniZinc models. OptaPlanner - Business planning and resource scheduling optimization solver. CSVFrameworks and libraries that simplify reading/writing CSV data. jackson-dataformat-csv - Jackson extension for reading and writing CSV. opencsv - Simple CSV parser. Super CSV - Powerful CSV parser with support for Dozer, Joda-Time and Java 8. uniVocity-parsers - One of the fastest and most feature-complete parsers. Also comes with parsers for TSV and fixed-width records. DatabaseEverything that simplifies interactions with the database. Apache Phoenix - High-performance relational database layer over HBase for low-latency applications. Chronicle Map - Efficient, in-memory (opt. persisted to disk), off-heap key-value store. eXist - A NoSQL document database and application platform. FlexyPool - Brings metrics and failover strategies to the most common connection pooling solutions. Flyway - Simple database migration tool. H2 - Small SQL database notable for its in-memory functionality. HikariCP - High-performance JDBC connection pool. JDBI - Convenient abstraction of JDBC. Jedis - Small client for interaction with Redis, with methods for commands. Jest - Client for the Elasticsearch REST API. jetcd - Client library for etcd. Jinq - Typesafe database queries via symbolic execution of Java 8 Lambdas (on top of JPA or jOOQ). jOOQ - Generates typesafe code based on SQL schema. Liquibase - Database-independent library for tracking, managing and applying database schema changes. MapDB - Embedded database engine that provides concurrent collections backed on disk or in off-heap memory. MariaDB4j - Launcher for MariaDB that requires no installation or external dependencies. OrientDB - Embeddable distributed database written on top of Hazelcast. Presto - Distributed SQL query engine for big data. Querydsl - Typesafe unified queries. Realm - Mobile database to run directly inside phones, tablets or wearables. Redisson - Allows for distributed and scalable data structures on top of a Redis server. requery - A modern, lightweight but powerful object mapping and SQL generator. Easily map to or create databases, or perform queries and updates from any Java-using platform. Speedment - Database access library that utilizes Java 8’s Stream API for querying. sql2o - Thin JDBC wrapper that simplifies database access and provides simple mapping of ResultSets to POJOs. Vibur DBCP - JDBC connection pool library with advanced performance monitoring capabilities. Xodus - Highly concurrent transactional schema-less and ACID-compliant embedded database. Data StructuresEfficient and specific data structures. Apache Avro - Data interchange format with dynamic typing, untagged data, and absence of manually assigned IDs. Apache Orc - Fast and efficient columnar storage format for Hadoop-based workloads. Apache Parquet - Columnar storage format based on assembly algorithms from Google’s paper on Dremel. Apache Thrift - Data interchange format that originated at Facebook. Big Queue - A big, fast and persistent queue based on memory-mapped files. Persistent Collection - Persistent and immutable analogue of the Java Collections Framework. Protobuf - Google’s data interchange format. SBE - Simple Binary Encoding, one of the fastest message formats around. Tape - A lightning-fast, transactional, file-based FIFO. Wire - Clean, lightweight protocol buffers. Date and TimeLibraries related to handling date and time. Almanac Converter - Simple conversion between different calendar systems. iCal4j - Parse and build iCalendar RFC 5545 data models. ThreeTen-Extra - Additional date-time classes that complement those in JDK 8. Time4J - Advanced date and time library. Dependency InjectionLibraries that help to realize the Inversion of Control paradigm. Apache DeltaSpike - CDI extension framework. Dagger2 - Compile-time injection framework without reflection. Feather - Ultra-lightweight, JSR-330-compliant dependency injection library. Governator - Extensions and utilities that enhance Google Guice. Guice - Lightweight and opinionated framework that completes Dagger. HK2 - Lightweight and dynamic dependency injection framework. DevelopmentAugmentation of the development process at a fundamental level. AspectJ - Seamless aspect-oriented programming extension. DCEVM - JVM modification that allows unlimited redefinition of loaded classes at runtime. Faux Pas - Library that simplifies error handling by circumventing the issue that none of the functional interfaces in the Java Runtime is allowed by default to throw checked exceptions. HotswapAgent - Unlimited runtime class and resource redefinition. JavaParser - Parse, modify and generate Java code. JavaSymbolSolver - A symbol solver for Java. JRebel - Instantly reloads code and configuration changes without redeploys. NoException - Allows checked exceptions in functional interfaces and converts exceptions to Optional return. Distributed ApplicationsLibraries and frameworks for writing distributed and fault-tolerant applications. Apache Geode - In-memory data management system that provides reliable asynchronous event notifications and guaranteed message delivery. Apache Storm - Realtime computation system. Apache ZooKeeper - Coordination service with distributed configuration, synchronization, and naming registry for large distributed systems. Atomix - Fault-tolerant distributed coordination framework. Axon Framework - Framework for creating CQRS applications. Copycat - Fault-tolerant state machine replication framework. Dropwizard Circuit Breaker - Circuit breaker design pattern for Dropwizard. Failsafe - Simple failure handling with retries and circuit breakers. Hazelcast - Highly scalable in-memory datagrid with a free open-source version. Hystrix - Provides latency and fault tolerance. JGroups - Toolkit for reliable messaging and cluster creation. Orbit - Virtual actors; adds another level of abstraction to traditional actors. Quasar - Lightweight threads and actors for the JVM. resilience4j - Functional fault tolerance library. ScaleCube - Embeddable Cluster-Membership library based on SWIM and gossip protocol. Zuul - A gateway service that provides dynamic routing, monitoring, resiliency, security, and more. Distributed TransactionsDistributed transactions provide a mechanism for ensuring consistency of data updates in the presence of concurrent access and partial failures. Atomikos - Provides transactions for REST, SOA and microservices with support for JTA and XA. Bitronix - A simple but complete implementation of the JTA 1.1 API. Narayana - Provides support for traditional ACID and compensation transactions, also complies with JTA, JTS and other standards. DistributionTools that handle the distribution of applications in native formats. Bintray - Version control for binaries that handle publishing. Compatible with Maven or Gradle, with a free plan for open-source software as well as several business plans. Boxfuse - Deployment of JVM applications to AWS using the principles of immutable infrastructure. Capsule - Simple and powerful packaging and deployment. A fat JAR on steroids, or a “Docker for Java” that supports JVM-optimized containers. Central Repository - Largest binary component repository available as a free service to the open-source community. Default used by Apache Maven, and available in all other build tools. IzPack - Setup authoring tool for cross-platform deployments. JitPack - Easy-to-use package repository for GitHub. Builds Maven/Gradle projects on demand and publishes ready-to-use packages. Nexus - Binary management with proxy and caching capabilities. packr - Packs JARs, assets and the JVM for native distribution on Windows, Linux and Mac OS X. really-executable-jars-maven-plugin - Maven plugin for making self-executing JARs. Document ProcessingLibraries that assist with processing office document formats. Apache POI - Supports OOXML (XLSX, DOCX, PPTX) as well as OLE2 (XLS, DOC or PPT). documents4j - API for document format conversion using third-party converters such as MS Word. docx4j - Create and manipulate Microsoft Open XML files. Formal VerificationFormal-methods tools: proof assistants, model checking, symbolic execution, etc. CATG - Concolic unit testing engine. Automatically generates unit tests using formal methods. Checker Framework - Pluggable type systems. Includes nullness types, physical units, immutability types and more. Daikon - Detects likely program invariants and generates JML specs based on those invariants. Java Path Finder (JPF) - JVM formal verification tool containing a model checker and more. Created by NASA. JMLOK 2.0 - Detects inconsistencies between code and JML specification through feedback-directed random tests generation, and suggests a likely cause for each nonconformance detected. KeY - Formal software development tool that aims to integrate design, implementation, formal specification, and formal verification of object-oriented software as seamlessly as possible. Uses JML for specification and symbolic execution for verification. OpenJML - Translates JML specifications into SMT-LIB format and passes the proof problems implied by the program to backend solvers. Functional ProgrammingLibraries that facilitate functional programming. cyclops-react - Monad and stream utilities, comprehensions, pattern matching, functional extensions for all JDK collections, future streams, trampolines and much more. derive4j - Java 8 annotation processor and framework for deriving algebraic data types constructors, pattern-matching and morphisms. Fugue - Functional extensions to Guava. Functional Java - Implements numerous basic and advanced programming abstractions that assist composition-oriented development. jOOλ - Extension to Java 8 that aims to fix gaps in lambda by providing numerous missing types and a rich set of sequential Stream API additions. protonpack - Collection of stream utilities. StreamEx - Enhances Java 8 Streams. Vavr - Functional component library that provides persistent data types and functional control structures. Game DevelopmentFrameworks that support the development of games. FXGL - JavaFX Game Development Framework. jMonkeyEngine - Game engine for modern 3D development. libGDX - All-round cross-platform, high-level framework. LWJGL - Robust framework that abstracts libraries like OpenGL/CL/AL. GeospatialLibraries for working with geospatial data and algorithms. Apache SIS - Library for developing geospatial applications. Geo - GeoHash utilities in Java. Geotoolkit.org - Library for developing geospatial applications. Built on top of the Apache SIS project. GeoTools - Library that provides tools for geospatial data. GraphHopper - Road-routing engine. Used as a Java library or standalone web service. H2GIS - A spatial extension of the H2 database. Jgeohash - Library for using the GeoHash algorithm. Mapsforge - Map rendering based on OpenStreetMap data. Spatial4j - General-purpose spatial/geospatial library. GUILibraries to create modern graphical user interfaces. JavaFX - The successor of Swing. Scene Builder - Visual layout tool for JavaFX applications. SWT - The Standard Widget Toolkit, a graphical widget toolkit. High PerformanceEverything about high-performance computation, from collections to specific libraries. Agrona - Data structures and utility methods that are common in high-performance applications. Disruptor - Inter-thread messaging library. Eclipse Collections - Collections framework inspired by Smalltalk. fastutil - Fast and compact type-specific collections. HPPC - Primitive collections. JCTools - Concurrency tools currently missing from the JDK. Koloboke - Hash sets and hash maps. HTTP ClientsLibraries that assist with creating HTTP requests and/or binding responses. Async Http Client - Asynchronous HTTP and WebSocket client library. Feign - HTTP client binder inspired by Retrofit, JAXRS-2.0, and WebSocket. OkHttp - HTTP+SPDY client. restQL-core - Microservice query language that fetches information from multiple services. Retrofit - Typesafe REST client. Ribbon - Client-side IPC library that is battle-tested in cloud. Riptide - Client-side response routing for Spring’s RestTemplate. Hypermedia TypesLibraries that handle serialization to hypermedia types. JSON-LD - JSON-LD implementation. Siren4J - Library for the Siren specification. IDEIntegrated development environments that try to simplify several aspects of development. Eclipse - Established open-source project with support for lots of plugins and languages. IntelliJ IDEA - Supports many JVM languages and provides good options for Android development. The commercial edition targets the enterprise sector. NetBeans - Provides integration for several Java SE and EE features, from database access to HTML5. ImageryLibraries that assist with the creation, evaluation or manipulation of graphical images. Imgscalr - Simple, efficient and hardware-accelerated image-scaling library implemented in pure Java 2D. Tess4J - A JNA wrapper for Tesseract OCR API. Thumbnailator - High-quality thumbnail generation library. TwelveMonkeys - Collection of plugins that extend the number of supported image file formats. ZXing - Multi-format 1D/2D barcode image processing library. JSONLibraries for serializing and deserializing JSON to and from Java objects. Genson - Powerful and easy-to-use Java-to-JSON conversion library. Gson - Serializes objects to JSON and vice versa. Good performance with on-the-fly usage. HikariJSON - High-performance JSON parser, 2x faster than Jackson. jackson-modules-java8 - Set of Jackson modules for Java 8 datatypes and features. Jackson-datatype-money - Open-source Jackson module to support JSON serialization and deserialization of JavaMoney data types. Jackson - Similar to GSON, but offers performance gains if you need to instantiate the library more often. JSON-io - Convert Java to JSON. Convert JSON to Java. Pretty print JSON. Java JSON serializer. jsoniter - Fast and flexible library with iterator and lazy parsing API. LoganSquare - JSON parsing and serializing library based on Jackson’s streaming API. Outperforms GSON &amp; Jackson’s library. Moshi - Modern JSON library, less opinionated and uses built-in types like List and Map. Yasson - Binding layer between classes and JSON documents similar to JAXB. JSON ProcessingLibraries for processing data in JSON format. fastjson - Very fast processor with no additional dependencies and full data binding. Jolt - JSON to JSON transformation tool. JsonPath - Extract data from JSON using XPATH-like syntax. JsonSurfer - Streaming JsonPath processor dedicated to processing big and complicated JSON data. JVM and JDKCurrent implementations of the JVM/JDK. Avian - JVM with both JIT and AOT modes. Includes an iOS port. OpenJ9 - High performance, enterprise calibre, flexibly licensed, openly governed cross platform Java Virtual Machine extending and augmenting the runtime technology components from the Eclipse OMR and OpenJDK project. OpenJDK - Open-source implementation for Linux. ParparVM - VM with non-blocking, concurrent GC for iOS. Zulu OpenJDK 9 - Early-access OpenJDK 9 builds for Windows, Linux, and Mac OS X. Zulu OpenJDK - OpenJDK builds for Windows, Linux, and Mac OS X through Java 8. LoggingLibraries that log the behavior of an application. Apache Log4j 2 - Complete rewrite with a powerful plugin and configuration architecture. Graylog - Open-source aggregator suited for extended role and permission management. Kibana - Analyzes and visualizes log files. Some features require payment. Logback - Robust logging library with interesting configuration options via Groovy. Logbook - Extensible, open-source library for HTTP request and response logging. Logstash - Tool for managing log files. SLF4J - Abstraction layer/simple logging facade. tinylog - Lightweight logging framework with static logger class. Tracer - Call tracing and log correlation in distributed systems. Machine LearningTools that provide specific statistical algorithms for learning from data. Apache Flink - Fast, reliable, large-scale data processing engine. Apache Mahout - Scalable algorithms focused on collaborative filtering, clustering and classification. Apache Spark - Data analytics cluster-computing framework. DatumBox - Provides several algorithms and pre-trained models for natural language processing. DeepDive - Creates structured information from unstructured data and integrates it into an existing database. Deeplearning4j - Distributed and multi-threaded deep learning library. H2O - Analytics engine for statistics over big data. JSAT - Algorithms for pre-processing, classification, regression, and clustering with support for multi-threaded execution. Oryx 2 - Framework for building real-time, large-scale machine learning applications. Includes end-to-end applications for collaborative filtering, classification, regression, and clustering. Smile - The Statistical Machine Intelligence and Learning Engine provides a set of machine learning algorithms and a visualization library. Weka - Collection of algorithms for data mining tasks ranging from pre-processing to visualization. MessagingTools that help send messages between clients to ensure protocol independency. Aeron - Efficient, reliable, unicast and multicast message transport. Apache ActiveMQ - Message broker that implements JMS and converts synchronous to asynchronous communication. Apache Camel - Glues together different transport APIs via Enterprise Integration Patterns. Apache Kafka - High-throughput distributed messaging system. Hermes - Fast and reliable message broker built on top of Kafka. JeroMQ - Implementation of ZeroMQ. Nakadi - Provides a RESTful API on top of Kafka. RocketMQ - A fast, reliable, and scalable distributed messaging platform. Smack - Cross-platform XMPP client library. MiscellaneousEverything else. Codename One - Cross-platform solution for writing native mobile apps. CQEngine - Ultra-fast, SQL-like queries on Java collections. Design Patterns - Implementation and explanation of the most common design patterns. Failsafe - Simple failure handling with retries and circuit breakers. FF4J - Feature Flags for Java. J2ObjC - Java-to-Objective-C translator for porting Android libraries to iOS. JavaX - Reinventing and extending Java with a focus on simplicity. JBake - Static website generator. JBot - Framework for building chatbots. Jimfs - In-memory file system. Joda-Money - Basic currency and money classes and algorithms not provided by the JDK. JPad - Snippet runner. Lanterna - Easy console text-GUI library, similar to curses. LightAdmin - Pluggable CRUD UI library for rapid application development. Maven Wrapper - Analogue of Gradle Wrapper for Maven, allows building projects without installing maven. Membrane Service Proxy - An open-source, reverse-proxy framework written in Java. MinimalFTP - Lightweight, small and customizable FTP server. Modern Java - A Guide to Java 8 - Popular Java 8 guide. Modernizer - Detect uses of legacy Java APIs. Multi-OS Engine - An open-source, cross-platform engine to develop native mobile (iOS, Android, etc.) apps. OpenRefine - Tool for working with messy data: cleaning, transforming, extending it with web services and linking it to databases. Polyglot for Maven - Extensions for Maven 3.3.1+ that allows writing the POM model in dialects other than XML. Smooks - Extensible framework for building applications that process data which means bindings, transformations, message processing and enrichment. Togglz - Implementation of the Feature Toggles pattern. TypeTools - Tools for resolving generic types. XMLBeam - Processes XML by using annotations or XPath within code. OctoLinker - Browser extension which allows to navigate through code on GitHub more efficiently. MicroserviceTools for managing microservices: i.e., creation, coordination or discovery. Apollo - Libraries for writing composable microservices. consul-api - Client for the Consul API: a distributed, highly available and datacenter-aware registry/discovery service. Eureka - REST-based service registry for resilient load balancing and failover. Lagom - Framework for creating microservice-based systems. MonitoringTools that monitor applications in production. AppDynamics - Performance monitor. Automon - Combines the power of AOP with monitoring and/or logging tools. BugSnag - Exception and error monitoring with an integration of several third party tools for a better workflow and a free hobbyist tier. Failsafe Actuator - Out of the box monitoring of Failsafe Circuit Breaker in Spring-Boot environment. Glowroot - Open-source Java APM. inspectIT - Captures detailed run-time information via hooks that can be changed on the fly. It supports tracing over multiple systems via the OpenTracing API and can correlate the data with end user monitoring. Instrumental - Real-time Java application performance monitoring. A commercial service with free development accounts. JavaMelody - Performance monitoring and profiling. jmxtrans - Connect to multiple JVMs and query them for their attributes via JMX. Its query language is based on JSON, which allows non-Java programmers to access the JVM attributes. Supports different output writes, including Graphite, Ganglia, and StatsD. Jolokia - JMX over REST. Kamon - Tool for monitoring applications running on the JVM. Metrics - Expose metrics via JMX or HTTP and send them to a database. New Relic - Performance monitor. nudge4j - Remote developer console from the browser for Java 8 via bytecode injection. OverOps - In-production error monitoring and debugging. Pinpoint - Open-source APM tool. Prometheus - Provides a multi-dimensional data model, DSL, autonomous server nodes and much more. SPM - Performance monitor with distributing transaction tracing for JVM apps. Stagemonitor - Open-source performance monitoring and transaction tracing for JVM apps. Sysmon - Lightweight platform monitoring tool for Java VMs. NativeFor working with platform-specific native libraries. JavaCPP - Provides efficient and easy access to native C++. JNA - Work with native libraries without writing JNI. Also provides interfaces to common system libraries. JNR - Work with native libraries without writing JNI. Also provides interfaces to common system libraries. Same goals as JNA, but faster, and serves as the basis for the upcoming Project Panama. Natural Language ProcessingLibraries that specialize in processing text. CogCompNLP - Provides common annotators for plain text input. CoreNLP - Provides a set of fundamental tools for tasks like tagging, named entity recognition, and sentiment analysis. DKPro - Collection of reusable NLP tools for linguistic pre-processing, machine learning, lexical resources, etc. LingPipe - Toolkit for tasks ranging from POS tagging to sentiment analysis. NetworkingLibraries for building network servers. Comsat - Integrates standard Java web-related APIs with Quasar fibers and actors. Dubbo - High-performance RPC framework. Finagle - Extensible RPC system for constructing high-concurrency servers. It implements uniform client and server APIs for several protocols, and is protocol-agnostic to simplify implementation of new protocols. Grizzly - NIO framework. Used as a network layer in Glassfish. gRPC - RPC framework based on protobuf and HTTP/2. KryoNet - Provides a clean and simple API for efficient TCP and UDP client/server network communication using NIO and Kryo. MINA - Abstract, event-driven async I/O API for network operations over TCP/IP and UDP/IP via Java NIO. Netty - Framework for building high-performance network applications. Nifty - Implementation of Thrift clients and servers on Netty. sshj - Programatically use SSH, SCP or SFTP. Undertow - Web server providing both blocking and non-blocking APIs based on NIO. Used as a network layer in WildFly. urnlib - Represent, parse and encode URNs, as in RFC 2141. ORMAPIs that handle the persistence of objects. Apache Cayenne - Provides a clean, static API for data access. Also includes a GUI Modeler for working with database mappings, and DB reverse engineering and generation. Ebean - Provides simple and fast data access. EclipseLink - Supports a number of persistence standards: JPA, JAXB, JCA and SDO. Hibernate - Robust and widely used, with an active community. MyBatis - Couples objects with stored procedures or SQL statements. SimpleFlatMapper - Simple database and CSV mapper. PaaSJava platform as a service. AWS Elastic Beanstalk - AWS-based, with support for Tomcat and Jetty. AWS Lambda - Serverless computation. Google App Engine - PaaS on Google’s infrastructure. Heroku - Abstract computing environments. Jelastic - Supports Tomcat, Jetty, GlassFish, JBoss, TomEE and WildFly. OpenShift Enterprise - On-premise solution. PDFTools to help with PDF file creation. Apache FOP - Creates PDFs from XSL-FO. Apache PDFBox - Toolbox for creating and manipulating PDFs. Dynamic Jasper - Abstraction layer to JasperReports. DynamicReports - Simplifies JasperReports. flyingsaucer - XML/XHTML and CSS 2.1 renderer. iText - Creates PDF files programmatically. JasperReports - Complex reporting engine. Performance analysisTools for performance analysis, profiling and benchmarking. fastThread - Analyze and visualize thread dumps with a free cloud-based upload interface. GCeasy - Tool to analyze and visualize GC logs. It provides a free cloud-based upload interface. honest-profiler - A low-overhead, bias-free sampling profiler. jHiccup - Logs and records platform JVM stalls. JITWatch - Analyze the JIT compiler optimisations made by the HotSpot JVM. JMH - a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks written in Java and other languages targeting the JVM. JProfiler - Database profiling for JDBC, JPA and NoSQL, with JEE support. LatencyUtils - Utilities for latency measurement and reporting. XRebel - Real-time profiling for web applications, with an in-browser widget. YourKit Java Profiler - Profiler for any application running on the JVM. PlatformFrameworks that are suites of multiple libraries encompassing several categories. CUBA Platform - High-level framework for developing enterprise applications with a rich web interface, based on Spring, EclipseLink and Vaadin. Light-Java - A fast, lightweight and productive microservices framework with built-in security. Orienteer - Open-source business application platform for rapid configuration/development of CRM, ERP, LMS and other applications. Spring - Provides many packages for dependency injection, aspect-oriented programming, security, etc. Reactive librariesLibraries for developing reactive applications. Akka - Toolkit and runtime for building concurrent, distributed, fault-tolerant and event-driven applications. Reactive Streams - Provides a standard for asynchronous stream processing with non-blocking backpressure. Reactor - Library for building reactive fast-data applications. vert.x - Polyglot event-driven application framework. REST FrameworksFrameworks specifically for creating RESTful services. Dropwizard - Opinionated framework for setting up modern web applications with Jetty, Jackson, Jersey and Metrics. Jersey - JAX-RS reference implementation. Microserver — A convenient, extensible microservices plugin system for Spring &amp; Spring Boot. With more than 30 plugins and growing, it supports both micro-monolith and pure microservices styles. Rapidoid - A simple, secure and extremely fast framework consisting of an embedded HTTP server, GUI components and dependency injection. rest.li - Framework for building robust, scalable RESTful architectures using typesafe bindings and asynchronous, non-blocking IO with an end-to-end developer workflow that promotes clean practices, uniform interface design and consistent data modeling. RESTEasy - Fully certified and portable implementation of the JAX-RS specification. RestExpress - Thin wrapper on the JBoss Netty HTTP stack that provides scaling and performance. Restlet Framework - Pioneering framework with powerful routing and filtering capabilities, and a unified client and server API. Spark - Sinatra inspired framework. Crnk - Implementation of the JSON API specification to build resource-oriented REST endpoints with sorting, filtering, paging, linking, object graphs, type-safety, bulk updates, integrations and more. ScienceLibraries for scientific computing, analysis and visualization. DataMelt - Environment for scientific computation, data analysis and data visualization. Erdos - Modular, light and easy graph framework for theoretic algorithms. GraphStream - Library for modeling and analyzing dynamic graphs. JGraphT - Graph library that provides mathematical graph-theory objects and algorithms. JGraphX - Library for visualizing (mainly Swing) and interacting with node-edge graphs. Mines Java Toolkit - Library for geophysical scientific computation, visualization and digital signal analysis. Morpheus - Provides a versatile two-dimensional memory efficient tabular data structure called a DataFrame to enable efficient in-memory analytics for scientific computing on the JVM. Tablesaw - Includes a data-frame, an embedded column store, and hundreds of methods to transform, summarize, or filter data. SearchEngines that index documents for search and analysis. Apache Lucene - High-performance, full-featured, cross-platform, text search engine library. Apache Solr - Enterprise search engine optimized for high-volume traffic. Elasticsearch - Distributed, multitenant-capable, full-text search engine with a RESTful web interface and schema-free JSON documents. SecurityLibraries that handle security, authentication, authorization or session management. Apache Shiro - Performs authentication, authorization, cryptography and session management. Bouncy Castle - All-purpose cryptographic library and JCA provider offering a wide range of functions, from basic helpers to PGP/SMIME operations. Cryptomator - Multiplatform, transparent, client-side encryption of files in the cloud. Hdiv - Runtime application that repels application security risks included in the OWASP Top 10, including SQL injection, cross-site scripting, cross-site request forgery, data tampering, and brute force attacks. jjwt - JSON web token for Java and Android. Keycloak - Integrated SSO and IDM for browser apps and RESTful web services. Keyczar - Easy-to-use, safe encryption framework with key versioning. Keywhiz - System for distributing and managing secrets. Nbvcxz - Advanced password strength estimation. OACC - Provides permission-based authorization services. pac4j - Security engine. PicketLink - Umbrella project for security and identity management. Vault - Secures, stores, and tightly controls access to tokens, passwords, certificates, API keys, and other secrets. It handles leasing, key revocation, key rolling, and auditing. Through a unified API, users can access an encrypted Key/Value store and network encryption-as-a-service, or generate AWS IAM/STS credentials, SQL/NoSQL databases, X.509 certificates, SSH credentials, and more. SerializationLibraries that handle serialization with high efficiency. FlatBuffers - Memory-efficient serialization library that can access serialized data without unpacking and parsing it. FST - JDK-compatible, high-performance object graph serialization. Kryo - Fast and efficient object graph serialization framework. MessagePack - Efficient binary serialization format. PHP Serializer - Serializing objects in the PHP serialization format. ServerServers specifically used to deploy applications. Apache Tomcat - Robust, all-round server for Servlet and JSP. Apache TomEE - Tomcat plus Java EE. Jetty - Provides a Web server and javax.servlet container, plus support for HTTP/2, WebSocket, OSGi, JMX, JNDI, JAAS and many other integrations. nanohttpd - Tiny, easily embeddable HTTP server. WebSphere Liberty - Lightweight, modular server developed by IBM. WildFly - Formerly known as JBoss and developed by Red Hat with extensive Java EE support. Template EngineTools that substitute expressions in a template. Handlebars.java - Logicless and semantic Mustache templates. Jade4J - Implementation of Pug (formerly known as Jade). Jtwig - Modular, configurable and fully tested template engine. Pebble - Inspired by Twig and separates itself with its inheritance feature and its easy-to-read syntax. It ships with built-in autoescaping for security and it includes integrated support for internationalization. Thymeleaf - Aims to be a substitute for JSP and works for XML files. TestingTools that test from model to the view. AsynchronousTools that simplify testing asynchronous services. Awaitility - DSL for synchronizing asynchronous operations. ConcurrentUnit - Toolkit for testing multi-threaded and asynchronous applications. GreenMail - In-memory email server for integration testing. Supports SMTP, POP3 and IMAP including SSL. Hoverfly Java - Native bindings for Hoverfly, a proxy which allows you to simulate HTTP services. REST Assured - DSL for easy testing of REST/HTTP services. BDDTesting for the software development process that emerged from TDD and was heavily influenced by DDD and OOAD. Cucumber - Provides a way to describe features in a plain language which customers can understand. Cukes-REST - A collection of Gherkin steps for REST-service testing using Cucumber. J8Spec - Follows a Jasmine-like syntax. JBehave - Extensively configurable framework that describes stories. JGiven - Provides a fluent API which allows for simpler composition. Lamdba Behave - Aims to provide a fluent API to write tests in long and descriptive sentences that read like plain English. FixturesEverything related to the creation and handling of random data. Beanmother - Sets up beans from YAML fixtures. Fixture Factory - Generates fake objects from a template. JFairy - Fake data generator. Randomized Testing - JUnit test runner and plugins for running JUnit tests with pseudo-randomness. FrameworksProvide environments to run tests for a specific use case. ArchUnit - Test library for specifying and asserting architecture rules. Apache JMeter - Functional testing and performance measurements. Arquillian - Integration and functional testing platform for Java EE containers. Citrus - Integration testing framework that focuses on both client- and server-side messaging. Gatling - Load testing tool designed for ease of use, maintainability and high performance. JUnit - Common testing framework. Pact JVM - Consumer-driven contract testing. PIT - Fast mutation-testing framework for evaluating fault-detection abilities of existing JUnit or TestNG test suites. MatchersLibraries that provide custom matchers. AssertJ - Fluent assertions that improve readability. JSONAssert - Simplifies testing JSON strings. Truth - Google’s assertion and proposition framework. MiscellaneousOther stuff related to testing. Mutability Detector - Reports whether instances of a given class are immutable. raml-tester - Tests if a request/response matches a given RAML definition. TestContainers - Provides throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container. pojo-tester - Automatically performs tests on basic POJO methods. MockingTools which mock collaborators to help testing single, isolated units. JMockit - Integration testing, API mocking and faking, and code coverage. Mockito - Mocking framework that lets you write tests with a clean and simple API. MockServer - Allows mocking of systems integrated with HTTPS. Moco - Concise web services for stubs and mocks. PowerMock - Mocks static methods, constructors, final classes and methods, private methods, and removal of static initializers. WireMock - Stubs and mocks web services. ParameterizationSimplifies the writing of parameterized tests. Burst - A unit testing library for varying test data. junit-dataprovider - A TestNG-like data provider/runner for JUnit. JUnitParams - Creates readable and maintainable parametrised tests. UtilityLibraries which provide general utility functions. Apache Commons - Provides configuration, validation, collections, file uploading, XML processing and other general-purpose functions. cactoos - Collection of object-oriented primitives. CRaSH - Provides a shell into a JVM that’s running CRaSH. Used by Spring Boot and others. Dex - Java/JavaFX tool capable of powerful ETL and data visualization. Embulk - Bulk data loader that helps data transfer between various databases, storages, file formats, and cloud services. Gephi - Cross-platform for visualizing and manipulating large graph networks. Guava - Collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, and more. JADE - Framework and environment for building and debugging multi-agent systems. JavaVerbalExpressions - Library that helps with constructing difficult regular expressions. JGit - A lightweight, pure Java library implementing the Git version control system. minio-java - Provides simple APIs to access any Amazon S3-compatible object storage server. Protégé - Provides an ontology editor and a framework to build knowledge-based systems. Underscore-java - Port of Underscore.js functions. Version ManagersUtilities that help create the development shell environment and switch between different Java versions. jabba - Java Version Manager inspired by nvm. Supports Mac OS X, Linux and Windows. jenv - Java Version Manager inspired by rbenv. Can configure globally or per project. Tested on Debian and Mac OS X. SDKMan - Java Version Manager inspired by RVM and rbenv. Supports UNIX-based platforms and Windows. Web CrawlingLibraries that analyze the content of websites. Apache Nutch - Highly extensible, highly scalable web crawler for production environments. Crawler4j - Simple and lightweight web crawler. jsoup - Scrapes, parses, manipulates and cleans HTML. StormCrawler - SDK for building low-latency and scalable web crawlers. Web FrameworksFrameworks that handle the communication between the layers of a web application. Apache Tapestry - Component-oriented framework for creating dynamic, robust, highly scalable web applications. Apache Wicket - Component-based web application framework similar to Tapestry, with a stateful GUI. Blade - Lightweight, modular framework that aims to be elegant and simple. Bootique - Minimally opinionated framework for runnable apps. Firefly - Asynchronous framework for rapid development of high-performance web application. Grails - Groovy framework that provides a highly productive environment by favoring convention over configuration, no XML and support for mixins. Jooby - Scalable, fast and modular micro-framework that offers multiple programming models. Ninja - Full-stack web framework. Pippo - Small, highly modularized, Sinatra-like framework. Play - Built on Akka, it provides predictable and minimal resource consumption (CPU, memory, threads) for highly-scalable applications in Java and Scala. PrimeFaces - JSF framework with both free and commercial/support versions and frontend components. Ratpack - Set of libraries that facilitate fast, efficient, evolvable and well-tested HTTP applications. Takes - Opinionated web framework which is built around the concepts of True Object-Oriented Programming and immutability. Vaadin - Event-driven framework built on top of GWT. Uses server-side architecture with Ajax on the client side. ResourcesAwesome ListsAwesome lists related to the Java &amp; JVM ecosystem. Awesome Gradle Plugins AwesomeJavaFX Awesome JVM Awesome Microservices Awesome REST Awesome Selenium ciandcd Useful Java Links CommunitiesActive discussions. r/java - Subreddit for the Java community. stackoverflow - Question/answer platform. VirtualJUG - Virtual Java User Group. FrontendsWebsites that provide a frontend for this list. Please note, there won’t be an official website. We don’t associate with a particular website and everybody is allowed to create one. java.libhunt.com Influential BooksBooks that made a big impact and are still worth reading. Core Java Volume I–Fundamentals Core Java, Volume II–Advanced Features Effective Java (3rd Edition) Java Concurrency in Practice Thinking in Java Podcasts and ScreencastsSomething to look at or listen to while programming. Java Off Heap Marco Behler’s Screencasts - Screencasts about modern Java development. The Java Council The Java Posse - Discontinued as of 02/2015. TwitterActive accounts to follow. Descriptions from Twitter. Adam Bien - Freelance author, JavaOne Rockstar speaker, consultant, Java Champion. Aleksey Shipilëv - Performance geek, benchmarking czar, concurrency bug hunter. Antonio Goncalves - Java Champion, JUG Leader, Devoxx France, Java EE 6/7, JCP, Author. Arun Gupta - Java Champion, JavaOne Rockstar, JUG Leader, Devoxx4Kids-er, VP of Developer Advocacy at Couchbase. Brian Goetz - Java Language Architect at Oracle. Bruno Borges - Product Manager/Java Jock at Oracle. Chris Richardson - Software architect, consultant, and serial entrepreneur, Java Champion, JavaOne Rock Star, POJOs in Action author. Ed Burns - Consulting Member of the Technical Staff at Oracle. Eugen Paraschiv - Author of the Spring Security Course. Heinz Kabutz - Java Champion, speaker, author of The Java Specialists’ Newsletter, concurrency performance expert. Holly Cummins - Technical Lead of IBM London’s Bluemix Garage, Java Champion, developer, author, JavaOne rockstar. James Weaver - Java/JavaFX/IoT developer, author and speaker. Java EE - Official Java EE Twitter account. Java Magazine - Official Java Magazine account. Java - Official Java Twitter account. Javin Paul - Well-known Java blogger. Josh Long - Spring Advocate at Pivotal, author of O’Reilly’s Cloud Native Java and Building Microservices with Spring Boot, JavaOne Rock Star. Lukas Eder - Java Champion, speaker, JUG.ch co-leader, Founder and CEO Data Geekery (jOOQ). Mario Fusco - RedHatter, JUG coordinator, frequent speaker and author. Mark Heckler - Pivotal Principal Technologist and Developer Advocate, conference speaker, published author, and Java Champion, focusing on Internet of Things and the cloud. Mark Reinhold - Chief Architect, Java Platform Group, Oracle. Markus Eisele - Java EE evangelist, Red Hat. Martijn Verburg - London JUG co-leader, speaker, author, Java Champion and much more. Martin Thompson - Pasty faced performance gangster. Monica Beckwith - Performance consultant, JavaOne Rock Star. OpenJDK - Official OpenJDK account. Peter Lawrey - Peter Lawrey, Java performance expert. Randy Shoup - Stitch Fix VP Engineering, speaker, JavaOne Rock Star. Reza Rahman - Java EE/GlassFish/WebLogic evangelist, author, speaker, open source hacker. Simon Maple - Java Champion, VirtualJUG founder, LJC leader, RebelLabs author. Stephen Colebourne - Java Champion, speaker. Trisha Gee - Java Champion and speaker. Venkat Subramaniam - Author, University of Houston professor, MicroSoft MVP award recipient, JavaOne Rock Star, Java Champion. WebsitesSites to read. Google Java Style InfoQ Java Algorithms and Clients Java, SQL, and jOOQ Java.net Javalobby JavaWorld JAXenter RebelLabs The Takipi Blog TheServerSide.com Vanilla Java Voxxed"}],"posts":[{"title":"Android NDK开发系列教程4：对类变量进行操作","slug":"Android-NDK开发系列教程4：对类变量进行操作","date":"2018-02-04T02:54:57.000Z","updated":"2018-02-07T14:39:12.000Z","comments":true,"path":"2018/02/04/Android-NDK开发系列教程4：对类变量进行操作/","link":"","permalink":"http://yoursite.com/2018/02/04/Android-NDK开发系列教程4：对类变量进行操作/","excerpt":"","text":"通常我们也可以直接利用jni来访问和处理类的变量，不一定非要通过Java方法来操作Java类变量。对类变量操作时，类的静态变量和类的实例变量的操作稍微有些不同，下面进行讲解。 对类的静态变量进行操作类的静态变量属于类，是所有该类实例共享的。操作该变量时，不需要指定具体的实例是哪个。 jclass clazz; jfieldID fid; jint num; //1.获取类的Class引用 clazz = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;); if (clazz == NULL) { // 错误处理 return; } //2.获取类静态变量num的属性ID fid = env-&gt;GetStaticFieldID( clazz, &quot;num&quot;, &quot;I&quot;); if (fid == NULL) { return; } // 3.获取静态变量num的值 num = env-&gt;GetStaticIntField(clazz,fid); printf(&quot;In C---&gt;ClassField.num = %d\\n&quot;, num); // 4.修改静态变量num的值 env-&gt;SetStaticIntField(clazz, fid, 80); 主要步骤就是代码里面注释的。 对类的实例变量进行操作代码如下： jclass clazz; jfieldID fid; jstring j_str; jstring j_newStr; const char *c_str = NULL; // 1.获取类的Class引用,obj是该类的某个实例jobject obj; clazz = env-&gt;GetObjectClass(obj); if (clazz == NULL) { return; } // 2. 获取类实例变量str的属性ID fid = env-&gt;GetFieldID(clazz,&quot;str&quot;, &quot;Ljava/lang/String;&quot;); if (clazz == NULL) { return; } // 3. 获取实例变量str的值 j_str = (jstring)env-&gt;GetObjectField(obj,fid); // 4. 将unicode编码的java字符串转换成C风格字符串 c_str = env-&gt;GetStringUTFChars(j_str,NULL); if (c_str == NULL) { return; } printf(&quot;In C---&gt;ClassField.str = %s\\n&quot;, c_str); env-&gt;ReleaseStringUTFChars(j_str, c_str); // 5. 修改实例变量str的值 j_newStr = env-&gt;NewStringUTF(&quot;This is C String&quot;); if (j_newStr == NULL) { return; } env-&gt;SetObjectField(obj, fid, j_newStr); // 6.删除局部引用 env-&gt;DeleteLocalRef(clazz); env-&gt;DeleteLocalRef(j_str); env-&gt;DeleteLocalRef(j_newStr); JNI开发也有JNI开发的套路，按照上面套路来，即可修改类的实例变量。操作过程也很好理解，我们在native操作的时候都需要借助JNI提供的函数获取相应的引用。利用引用去进行操作。由于JNI函数是直接操作JVM中的数据结构，所以即使是private的变量，我们也可以进行修改。 总结 由于JNI函数是直接操作JVM中的数据结构，不受Java访问修饰符的限制。即，在本地代码中可以调用JNI函数可以访问Java对象中的非public属性和方法 访问和修改静态变量操作步聚： 调用FindClass函数获取类的Class引用 调用GetStaticFieldID函数获取Class引用中某个静态变量ID 调用GetStaticXXXField函数获取静态变量的值，需要传入变量所属Class的引用和变量ID 调用SetStaticXXXField函数设置静态变量的值，需要传入变量所属Class的引用、变量ID和变量的值 访问和修改实例变量操作步聚： 调用GetObjectClass函数获取实例对象的Class引用 调用GetFieldID函数获取Class引用中某个实例变量的ID 调用GetXXXField函数获取变量的值，需要传入实例变量所属对象和变量ID 调用SetXXXField函数修改变量的值，需要传入实例变量所属对象、变量ID和变量的值","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android JNI开发","slug":"Android-JNI开发","permalink":"http://yoursite.com/tags/Android-JNI开发/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android NDK开发系列教程3：基本方法调用及传参（续）","slug":"Android-NDK开发系列教程3：基本方法调用及传参（续）","date":"2018-02-02T14:25:43.000Z","updated":"2018-02-07T14:39:12.000Z","comments":true,"path":"2018/02/02/Android-NDK开发系列教程3：基本方法调用及传参（续）/","link":"","permalink":"http://yoursite.com/2018/02/02/Android-NDK开发系列教程3：基本方法调用及传参（续）/","excerpt":"","text":"上一节主要讲解Java向native传参，下面主要讲解从native传相应的数据到java层。接着上一节，下面主要讲解内容如下： native向java返回字符串类型 native向java返回java对象 native向java返回数组类型 native向Java返回List对象对于上面的每个都给出对应的例子。本节所有案例代码均已放到GitHub上，欢迎下载：https://github.com/huangtianyu/JNILearnCourse 1. native向java返回字符串类型传基本数据类型很简单，是什么就传什么就行。传字符串类型也很简单，具体jni代码如下： extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_zqc_com_example_NativeTest_jni2javaMethod1(JNIEnv *env, jobject instance) { //jstring NewStringUTF(const char* bytes),jstring NewString(const jchar* unicodeChars, jsize len) char *returnValue = &quot;你在native做你的操作后，生成char*后，通过env-&gt;NewStringUTF即可返回Java的String类型&quot;; return env-&gt;NewStringUTF(returnValue); } 其中最主要用的是以下几个方法： //创建Unicode格式的jstring串 jstring NewString(const jchar* unicodeChars, jsize len) { return functions-&gt;NewString(this, unicodeChars, len); } //获取jstring长度 jsize GetStringLength(jstring string) { return functions-&gt;GetStringLength(this, string); } //获取jstring对应的字符串，isCopy表示是否拷贝生成副本。 //这个函数返回一个指向特定jstring中字符顺序的指针，该指针保持有效直到ReleaseStringChars函数被调用： const jchar* GetStringChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringChars(this, string, isCopy); } //释放指针 void ReleaseStringChars(jstring string, const jchar* chars) { functions-&gt;ReleaseStringChars(this, string, chars); } ////创建UTF-8格式的jstring串 jstring NewStringUTF(const char* bytes) { return functions-&gt;NewStringUTF(this, bytes); } //获取utf字符串的长度 jsize GetStringUTFLength(jstring string) { return functions-&gt;GetStringUTFLength(this, string); } //同GetStringChars const char* GetStringUTFChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringUTFChars(this, string, isCopy); } //同ReleaseStringChars void ReleaseStringUTFChars(jstring string, const char* utf) { functions-&gt;ReleaseStringUTFChars(this, string, utf); } 以上是处理字符串常用的一些方法。 2 native向java返回java对象具体看native的代码如下： extern &quot;C&quot; JNIEXPORT jobject JNICALL Java_zqc_com_example_NativeTest_jni2javaMethod2(JNIEnv *env, jobject instance) { jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;); jmethodID constructor = env-&gt;GetMethodID(pcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jmethodID setIdMid = env-&gt;GetMethodID(pcls, &quot;setId&quot;, &quot;(J)V&quot;); jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;); jmethodID setAgeMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(I)V&quot;); jobject person = env-&gt;NewObject(pcls, constructor); env-&gt;CallVoidMethod(person, setIdMid, 100L); env-&gt;CallVoidMethod(person, setNameMid, env-&gt;NewStringUTF(&quot;天宇&quot;)); env-&gt;CallVoidMethod(person, setAgeMid, 18); return person; } 常用新建Object的方法由以下几个： //将传递给构造函数的所有参数紧跟着放在 methodID 参数的后面。NewObject() 收到这些参数后，将把它们传给所要调用的Java 方法。 jobject NewObject(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args); va_end(args); return result; } //将传递给构造函数的所有参数放在 va_list 类型的参数 args 中，该参数紧跟着放在 methodID 参数的后面。NewObject() 收到这些参数后，将把它们传给所要调用的 Java 方法。 jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args) { return functions-&gt;NewObjectV(this, clazz, methodID, args); } //将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject() 收到数组中的这些参数后，将把它们传给所要调用的 Java 方法。 jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args) { return functions-&gt;NewObjectA(this, clazz, methodID, args); } //测试对象是否为某个类的实例。 jboolean IsInstanceOf(jobject obj, jclass clazz) { return functions-&gt;IsInstanceOf(this, obj, clazz); } //测试两个引用是否引用同一 Java 对象。 jboolean IsSameObject(jobject ref1, jobject ref2) { return functions-&gt;IsSameObject(this, ref1, ref2); } //分配新 Java 对象而不调用该对象的任何构造函数。返回该对象的引用。 //该方法会抛出：InstantiationException：如果该类为一个接口或抽象类。OutOfMemoryError：如果系统内存不足。 jobject AllocObject(jclass clazz) { return functions-&gt;AllocObject(this, clazz); } 3 native向java返回数组类型3.1 基本类型数组这里直接看native层代码如下： extern &quot;C&quot; JNIEXPORT jintArray JNICALL Java_zqc_com_example_NativeTest_jni2javaMethod3(JNIEnv *env, jobject instance) { int nat[] = {2, 1, 4, 3, 5}; jintArray jnat = env-&gt;NewIntArray(5); env-&gt;SetIntArrayRegion(jnat, 0, 5, nat); return jnat; } 基本数据类型数组都有相应的env-&gt;NewXXXArray(jsize length);通过该方法可以生成对应的数组。 jbooleanArray NewBooleanArray(jsize length) { return functions-&gt;NewBooleanArray(this, length); } jbyteArray NewByteArray(jsize length) { return functions-&gt;NewByteArray(this, length); } jcharArray NewCharArray(jsize length) { return functions-&gt;NewCharArray(this, length); } jshortArray NewShortArray(jsize length) { return functions-&gt;NewShortArray(this, length); } jintArray NewIntArray(jsize length) { return functions-&gt;NewIntArray(this, length); } jlongArray NewLongArray(jsize length) { return functions-&gt;NewLongArray(this, length); } jfloatArray NewFloatArray(jsize length) { return functions-&gt;NewFloatArray(this, length); } jdoubleArray NewDoubleArray(jsize length) { return functions-&gt;NewDoubleArray(this, length); } 在生成了对应的数组后，可以通过setXXXArrayRegion(jxxxArray array, jsize start, jsize len, const jchar* buf)来填充数组 void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, const jboolean* buf) { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); } void SetByteArrayRegion(jbyteArray array, jsize start, jsize len, const jbyte* buf) { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); } void SetCharArrayRegion(jcharArray array, jsize start, jsize len, const jchar* buf) { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); } void SetShortArrayRegion(jshortArray array, jsize start, jsize len, const jshort* buf) { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); } void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint* buf) { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); } void SetLongArrayRegion(jlongArray array, jsize start, jsize len, const jlong* buf) { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); } void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, const jfloat* buf) { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); } void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, const jdouble* buf) { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); } 3.2 对象类型数组直接看native代码： extern &quot;C&quot; JNIEXPORT jobjectArray JNICALL Java_zqc_com_example_NativeTest_jni2javaMethod4(JNIEnv *env, jobject instance) { jclass cls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;); jmethodID cMid = env-&gt;GetMethodID(cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;); jmethodID cmid = env-&gt;GetMethodID(pcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;); jmethodID setAgeMid = env-&gt;GetMethodID(pcls, &quot;setAge&quot;, &quot;(I)V&quot;); jobject obj = env-&gt;NewObject(pcls, cmid); env-&gt;CallVoidMethod(obj, setNameMid, env-&gt;NewStringUTF(&quot;天宇&quot;)); int len = 3; jobjectArray joa = env-&gt;NewObjectArray(len, cls, obj); for (int i = 0; i &lt; len; ++i) { jobject tmp = env-&gt;GetObjectArrayElement(joa,i); env-&gt;CallVoidMethod(tmp, setAgeMid, i + 10); } return joa; } 其在native生成的方法是 jobjectArray joa = env-&gt;NewObjectArray(len, cls, obj); //第一个参数表示生成的长度，第二参数表示里面元素的对象类，第三个表示原始初始化时的值。在生成后每个元素都是该值。 jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement) { return functions-&gt;NewObjectArray(this, length, elementClass, initialElement); } 4 native向Java返回List对象直接看native代码如下： extern &quot;C&quot; JNIEXPORT jobject JNICALL Java_zqc_com_example_NativeTest_jni2javaMethod5(JNIEnv *env, jobject instance) { jclass listCls = env-&gt;FindClass(&quot;java/util/ArrayList&quot;);//获得ArrayList类引用 jmethodID listCon = env-&gt;GetMethodID(listCls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);//获取构造函数的methodID jmethodID addMid = env-&gt;GetMethodID(listCls,&quot;add&quot;,&quot;(Ljava/lang/Object;)Z&quot;);//获取add函数的methodID jobject listObj = env-&gt;NewObject(listCls, listCon);//利用NewObject创建一个ArrayList对象 jobject jperon = Java_zqc_com_example_NativeTest_jni2javaMethod2(env, instance);//利用上面方法新建一个Person对象 env-&gt;CallBooleanMethod(listObj, addMid, jperon);//在listObj中add一个Person对象 //返回ArrayList的对象 return listObj; } 对应jni而言，List，ArrayList以及Map，HashMap，Set，HashSet都只是一个Object，对应于jni而言也就都是jobject，操作jobject都可以用最开始介绍的方法。 总结jni里面的方法很多，多用用就熟悉了。常用的上面都有，自己之前还总结了很多常用的类型转换函数。以后有时间再写篇博客分享下。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android NDK开发，JNI开发","slug":"Android-NDK开发，JNI开发","permalink":"http://yoursite.com/tags/Android-NDK开发，JNI开发/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":" Android NDK开发系列教程2：基本方法调用及传参","slug":"Android-NDK开发系列教程2：基本方法调用及传参","date":"2018-02-02T13:56:11.000Z","updated":"2018-02-07T14:39:12.000Z","comments":true,"path":"2018/02/02/Android-NDK开发系列教程2：基本方法调用及传参/","link":"","permalink":"http://yoursite.com/2018/02/02/Android-NDK开发系列教程2：基本方法调用及传参/","excerpt":"","text":"1. 简介有时候我写了个Java层的方法，希望native层也能够调用（尤其是一个实体类的get，set方法在native一般都会用到）。这在jni开发中也很常见，jni.h中也提供了很多方法。下面利用具体实例进行说明。这里直接使用AS3.0里面的CMake进行编译了，之后会讲解下Android.mk和Application.mk的用法和含义。这里我主要介绍一下几个： java向native传递常用基本数据类型和字符串类型 java向native传递数组类型 java向native传递自定义java对象 java向native传递List对象 1.1 java和jni类型对照表在我们调用方法时会用到方法的签名，使用类变量时需要用该变量对应的jni类型。下面给出对应的类型对照表。 基本数据类型对照表： 对象类型对照表： 简写对应表2. 具体例子2.1 java向native传递常用基本数据类型和字符串类型强大的AS在你写了java的native方法后，直接快捷键按Alt+Enter后即可生成对应的方法。java层的方法：package zqc.com.example; public class NativeTest { // Used to load the &#39;native-lib&#39; library on application startup. static { System.loadLibrary(&quot;native-lib&quot;); } //定义一个native方法，然后传入基本数据类型和String型 public native void java2jniMethod1(boolean b, int i, float f, String s); } 生成后的native方法：extern &quot;C&quot; JNIEXPORT void JNICALL Java_zqc_com_example_NativeTest_java2jniMethod1(JNIEnv *env, jobject instance, jboolean b, jint i, jfloat f, jstring s_) { //在native层会把string转换成c/c++都特别熟悉的char*，由char*可以转string,wstring等等。 //在Java层String是对象，这里讲char*指针指向了该对象，在方法结束的时候记得要是否该指针引用 if (b == JNI_TRUE) { LOGE(&quot;b is true&quot;); } else { LOGE(&quot;b is false&quot;); } float nativi = i + f; LOGE(&quot;native i: %f&quot;, nativi); const char *s = env-&gt;GetStringUTFChars(s_, 0); LOGE(&quot;native string: %s&quot;, s); env-&gt;ReleaseStringUTFChars(s_, s); } 在上面可以看到，Java层的基本类型方法都会经过jni进行转换，转换成相应的jni类型。其操作也很方便。Java的String类型需要注意下，一般是将jstring先转换为char然后对char 进行操作。由于这获取了一个局部引用，一般在调用结束后需要释放该局部引用。 2.2 java向native传递数组类型 //向native传递数组类型 public native void java2jniMethod2(int[] as, String[] strs); 对应的jni方法是： extern &quot;C&quot; JNIEXPORT void JNICALL Java_zqc_com_example_NativeTest_java2jniMethod2(JNIEnv *env, jobject instance, jintArray as_, jobjectArray strs) { //获取数组里面内容 jint *as = env-&gt;GetIntArrayElements(as_, NULL); int result = 0, len = env-&gt;GetArrayLength(as_); for (int i = 0; i &lt; len; ++i) { result += as[i]; } LOGE(&quot;intarray sum is %d&quot;, result); env-&gt;ReleaseIntArrayElements(as_, as, 0); //这里可以看出String[]对应的是jobjectArray len = env-&gt;GetArrayLength(strs); for (int i = 0; i &lt; len; ++i) { jstring temp = (jstring) env-&gt;GetObjectArrayElement(strs, i); const char *ctemp = env-&gt;GetStringUTFChars(temp, JNI_FALSE); LOGE(&quot;第%d个：%s&quot;, i, ctemp); } } 其中函数： jsize GetArrayLength(jxxxarray array);用于获取数组的长度在Java端调用代码如下： NativeTest test = new NativeTest(); int a[] = new int[3]; for (int i=0;i&lt;a.length;i++) { a[i] = i + 10; } String[] strs = new String[4]; for (int i=0;i&lt;strs.length;i++) { strs[i] = &quot;我的值：&quot;+i; } test.java2jniMethod2(a,strs); 2.2.1 处理基本数据类型有以下几个相关函数：(1) GetXXXArrayElements(Array arr , jboolean* isCopide);这类函数可以把Java基本类型的数组转换到C/C++中的数组，有两种处理方式，一种JNI_TRUE是拷贝一份传回本地代码，另一个是JNI_FALSE把指向Java数组的指针直接传回到本地代码中，处理完本地化的数组后，通过ReleaseXXXArrayElements来释放数组 (2) ReleaseXXXArrayElements(Array arr , * array , jint mode)用这个函数可以选择将如何处理Java跟C++的数组，是提交，还是撤销等，内存释放还是不释放等mode可以取下面的值:0 ：对Java的数组进行更新并释放C/C++的数组JNI_COMMIT ：对Java的数组进行更新但是不释放C/C++的数组JNI_ABORT：对Java的数组不进行更新,释放C/C++的数组 (3) GetPrimitiveArrayCritical(jarray arr , jboolean* isCopied);在获得数组上的锁后将返回一个句柄给数组。如果没有建立任何锁，则isCopy被置为JNI_TRUE，否则置为NULL或JNI_FALSE： (4) ReleasePrimitiveArrayCritical(jarray arr , void* array , jint mode);释放从GetPrimitiveArrayCritical调用中返回的数组。也是JDK1.2出来的，为了增加直接传回指向Java数组的指针而加入的函数，同样的也会有同GetStringCritical的死锁的问题。mode取值如下：0：从carray中复制值到数组中，并释放分配给carray的存储器JNI_COMMIT：从carray中复制值到数组中，但是不释放分配给carray的存储器JNI_ABORT：不从carray中复制值到数组中 (5) GetXXXArrayRegion(Array arr , jsize start , jsize len , * buffer);在C/C++预先开辟一段内存，然后把Java基本类型的数组拷贝到这段内存中。用于一个数组子集的复制操作。参数start指定了从何处复制的起始索引，参数len则指定了从数组中复制到本机数组的多个位置数量。 (6) SetXXXArrayRegion(Array arr , jsize start , jsize len , const * buffer);用来复制本机数组的一段内容回Java数组中。元素一般从本机数组起始处（索引为0）开始复制，但是只是从位置start开始将len个元素复制到Java数组中。 (7) Array NewXXXArray(jsize sz)创建一个包含length个元素的Java数组。 2.2.2 处理对象数组类型有以下几个相关函数：(1) jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement );创建对象数组，创建一个长度为length，并且持有类型为elementClass的对象的对象数组，数组中的所有元素都被置为initialElement (2) jobject GetObjectArrayElement(jobjectArray array, jsize Index);获取数组元素，通过Index指定的索引在array中获取一个对象，如果索引超出边界，会抛出一个IndexOutOfBoundsException (3) void SetObjectArrayElement(jobjectArray array, jsize index,jobject value);设置元素值。在array中通过index指定的索引处设置元素值为value，如果index超出边界，会抛出一个IndexOutOfBoundException。 2.3 java向native传递自定义java对象定义一个Java层方法： package zqc.com.example; /** * Created by zhangqianchu on 2018/2/1. */ class Person { long id; String name; int age; public long getId() { return id; } public void setId(long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return &quot;Person{&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;}&#39;; } } 定义一个Java的native方法： //Java向native传自定义类对象 public native void java2jniMethod3(Person person); 在native层实现 extern &quot;C&quot; JNIEXPORT void JNICALL Java_zqc_com_example_NativeTest_java2jniMethod3(JNIEnv *env, jobject instance, jobject person) { jclass cls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;); if (cls == 0) { LOGE(&quot;find class fail&quot;); return; } jmethodID mid_ID = env-&gt;GetMethodID(cls, &quot;setId&quot;, &quot;(J)V&quot;); jmethodID mid_Name = env-&gt;GetMethodID(cls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;); jmethodID mid_Age = env-&gt;GetMethodID(cls, &quot;setAge&quot;, &quot;(I)V&quot;); if (mid_ID &amp;&amp; mid_Name &amp;&amp; mid_Age) { env-&gt;CallVoidMethod(person, mid_ID, 100L); jstring name = env-&gt;NewStringUTF(&quot;Tianyu&quot;); env-&gt;CallVoidMethod(person, mid_Name, name); env-&gt;CallVoidMethod(person, mid_Age, 18); return; } } 在Java端调用 Person person = new Person(); test.java2jniMethod3(person); Toast.makeText(this, person.toString(),Toast.LENGTH_SHORT).show(); 从Java端传对象实例给native时，到native端任何对象都变为jobject类型，如果要做对该对象实例的任何操作需先获取该对象的jfieldID ,jmethodID,然后通过env-&gt;CallXXXMethod来操作该对象的方法其中第一个参数是该对象的具体实例，其中env-&gt;CallStaticXXXMethod方法用来调用该类的静态方法，调用静态方法的时候就不用传具体的对象过去了。 2.4 java向native传递List对象定义Java的native方法 //Java向native传List对象 public native void java2jniMethod4(List&lt;Person&gt;people); 在native中实现具体方法： extern &quot;C&quot; JNIEXPORT void JNICALL Java_zqc_com_example_NativeTest_java2jniMethod4(JNIEnv *env, jobject instance, jobject people) { //下面所有操作都得先判断是否为空。。。 jclass cls = env-&gt;GetObjectClass(people); jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;); //jmethodID getNameMid = env-&gt;GetMethodID(pcls, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;); jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;); //获取List的get方法id jmethodID getMid = env-&gt;GetMethodID(cls, &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;); //获取List的长度 jmethodID sizeMid = env-&gt;GetMethodID(cls, &quot;size&quot;, &quot;()I&quot;); int len = env-&gt;CallIntMethod(people, sizeMid); for (int i = 0; i &lt; len; ++i) { //获取第i个元素 jobject data = env-&gt;CallObjectMethod(people, getMid, i); env-&gt;CallVoidMethod(data, setNameMid, env-&gt;NewStringUTF(&quot;全部随我native&quot;)); } } jclass cls = env-&gt;GetObjectClass(people);这是获取一个对象实例相应的类的最好的办法。从上面可以看出List在传到native时也是变成了jobject，然后具体操作都得通过env-&gt;GetObjectClass先获取到该类，然后获取到该类的具体jmethodID，jfieldID来完成相应的操作。调用的方法也是env-&gt;CallXXXMethod()。然后在Java端调用该native方法： NativeTest test = new NativeTest(); List&lt;Person&gt; people = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 3; i++) { Person person1 = new Person(); person1.setName(&quot;我是Java层&quot;); people.add(person1); } test.java2jniMethod4(people); Iterator&lt;Person&gt; iterator = people.iterator(); while (iterator.hasNext()) { Person person1 = iterator.next(); Log.e(&quot;myndk&quot;, person1.getName() + &quot;\\n&quot;); } 在上面即可通过native将Person的name全部进行了更改。 上面都是Java向native传参，基本用法都类似。基本数据类型有相应的对照表，对象类型的都转为jobject，对对象的操作都是先获取该对象jclass,jmethodID,jfielID后再对对象实例进行操作。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android NDK开发，JNI开发","slug":"Android-NDK开发，JNI开发","permalink":"http://yoursite.com/tags/Android-NDK开发，JNI开发/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android NDK开发系列教程1：环境搭建及基本代码结构","slug":"Android-NDK开发系列教程1：环境搭建及基本代码结构","date":"2018-02-01T13:50:54.000Z","updated":"2018-02-07T14:39:12.000Z","comments":true,"path":"2018/02/01/Android-NDK开发系列教程1：环境搭建及基本代码结构/","link":"","permalink":"http://yoursite.com/2018/02/01/Android-NDK开发系列教程1：环境搭建及基本代码结构/","excerpt":"","text":"1. Eclipse NDK开发环境搭建在开发NDK之前，Java的SDK，Android的NDK，以及Eclipse的ADT工具都需要大家先安装好，在SDK早期版本中没有ndk相关文件，当最近的AndroidSDK中包含了ndk相关文件，所以下载NDK工具的麻烦事这里就没有了。唯一要注意的是需要配置下NDK的环境变量。这样可以方便进行编译。AndroidSDK主要文件夹参考如下：这里讲Eclipse的配置就将下如何添加External Tool来快速生成.h文件以及快速进行ndk_build编译。 1.1 配置快速生成.h头文件的命令 点击Eclipse上面的图标，打开External Tool Configurations。 然后打开如下界面，在如下界面中双击Program，在底下会生成一个New_configuration。然后按照图片上面的格式填写相应的参数。Location填写javah.exe的位置：C:\\Program Files\\Java\\jdk1.8.0_91\\bin\\javah.exeWorking Directory填写当前的工作目录：${workspace_loc:/MyTest/src}Arguments填写相应的参数：-classpath ${workspace_loc:/MyTest/src/bin/classes} -d ${workspace_loc:/MyTest/jni} -jni com.scu.MyNDK 之后在External Tool的地方就会生成一个JavaH的命令工具，点击即可生成对应的.h头文件了。这里要注意的是生成都文件前要先编译出.class文件。其实这个和用javah.exe命令是一样的，具体命令如下：2. Android Studio的配置AS太强大了，所有你想要的只需要简单的添加一个依赖，AS就会自动帮你下载，完全不用你去下载。最新的Android Studio在新建工程的时候，选中Include C++ Support后，即可进行NDK开发，这里注意下在AS中的编译换成了CMake工具，这个工具配置上稍微和Android.mk有些许不同。其配置文件在新建工程的CMakeLists.txt里面配置。 在build.gradle里面也会自动配置cmake工具，配置如下： externalNativeBuild { cmake { path &quot;CMakeLists.txt&quot; } } 3. 基本代码结构利用AS创建工程后，工程会自动生成如下代码： package zqc.com.example; import android.os.Bundle; import android.support.v7.app.AppCompatActivity; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } // Used to load the &#39;native-lib&#39; library on application startup. static { System.loadLibrary(&quot;native-lib&quot;); } /** * A native method that is implemented by the &#39;native-lib&#39; native library, * which is packaged with this application. */ public native String stringFromJNI(); } 其中在static静态代码块中会加载动态链接库。在一个方法前加上native关键字即表明该方法是一个jni方法，因而只有声明，没有实现，其具体实现在c/c++代码中。找到cpp文件，打开后内容如下： #include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jstring JNICALL Java_zqc_com_example_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) { std::string hello = &quot;Hello from C++&quot;; return env-&gt;NewStringUTF(hello.c_str()); } 其中extern “C”表示在编译的时候导出为c语言的格式，JNIEXPORT表示该函数是可以导出的，可以由外部方法进行调用，这和dll类似，jstring表示返回值，JNICALL关键字表示这是一个jni方法，Java_zqc_com_example_MainActivity_stringFromJNI其中Java是固定格式，zqc_com_example_MainActivity是全类名，stringFromJNI是具体的方法名，具体参数：JNIEnv env为env指针，调用jni的很多方法都需要该指针，jobject / this */这个表示当前类的this指针，这里因为没用到就没有命名。在以往开发中可能是把.h和.cpp分开了，这个是AS自动生成的，这里并没有单独生成.h文件。c/c++开发也有自己的结构，这里除了需要对外暴露接口的需要按照上面格式编写外，其他的都可以用古老的c/c++进行编写并遵循古老的结构。你可以先定义.h文件，然后在.cpp里面具体实现。点击Build-&gt;Make Project（快捷键Ctrl+F9）即可生成动态链接库文件.so，其路径在：AS自动生成了Debug版和Release版，并且在各个版本中又生成了不同平台的.so文件。只能说这个AS太牛叉了~之后运行工程，安装到手机上时就把对应的so也拷贝到了手机中了。 总结目前应该是绝大多数人都采用AndroidStudio进行开发，谷歌官方已经不再对Eclipse的ADT进行维护了。而AS是绝对强大的工具，当你选择Include C++ Support的时候，AS会将NDK开发的一切都下载下来。所以如果采用AS开发，那么你学NDK开发的话，只需要把Android开发需要安装的JDK，SDK，AS等工具安装好后，即可进行开发。这个系列教程我也采用AS进行讲解。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android NDK开发，JNI开发","slug":"Android-NDK开发，JNI开发","permalink":"http://yoursite.com/tags/Android-NDK开发，JNI开发/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"深度学习课程资源","slug":"深度学习课程资源","date":"2018-01-23T14:40:46.000Z","updated":"2018-02-07T14:39:12.000Z","comments":true,"path":"2018/01/23/深度学习课程资源/","link":"","permalink":"http://yoursite.com/2018/01/23/深度学习课程资源/","excerpt":"","text":"目前，深度学习和深度强化学习已经在实践中得到了广泛的运用。资源型博客sky2learn整理了15个深度学习和深入强化学习相关的在线课程，其中包括它们在自然语言处理（NLP），计算机视觉和控制系统中的应用教程。 这些课程涵盖了神经网络，卷积神经网络，循环网络和其变体，训练深度网络的困难，无监督表示学习，深度信念网络，深玻尔兹曼机器，深度Q学习，价值函数估计和优化以及蒙特卡洛树搜索等多种算法的基础知识。 吴恩达：深度学习专项 这系列课程侧重于讲解深度学习的基础和在不同领域的运用方式，如医疗健康，自动驾驶，手语阅读，音乐生成和自然语言处理等。课程共包含五个子课程，有视频讲座。同时，课程用户将获得使用TensorFlow解决实际问题的实践经验。 链接：https://www.coursera.org/specializations/deep-learning CMU: 深度学习 该课程由苹果人工智能研究所主任Ruslan Salakhutdinov主导。课程首先讲解了一些例如前馈神经网络、反向传播、卷积模型等的基本知识。然后介绍深度学习中的要点，包括有向图和无向图模型，独立成分分析（ICA），稀疏编码，自动编码器，限制玻尔兹曼机（RBM），蒙特卡罗方法，深度信念网络，深度玻尔兹曼机和亥姆霍兹机。其他内容包括深度网络中的正则化和优化、序列建模和深度强化学习。 链接：http://www.cs.cmu.edu/~rsalakhu/10707/ 斯坦福大学：深度学习理论（Stat385） 本课程讨论深度学习理论方面的知识。有8次特邀嘉宾讲座，这些嘉宾是深度学习、计算神经科学和统计学方面的领军人物。您将有机会在深度学习中，针对当前的研究趋势，探索他们观点的多样性和跨学科性。这门课有视频讲座。 链接：https://stats385.github.io/ Yoshua Bengio: 深度学习 该课程由蒙特利尔大学主导。课程首先回顾了神经网络的基本知识，包括感知器，反向传播算法和梯度优化。然后介绍了神经网络、概率图形模型、深度网络和表示学习等前沿知识。 链接：https://ift6266h16.wordpress.com/ UC Berkeley: 深度强化学习 该课程包括强化学习的基本知识：Q-学习和策略梯度，同时还包含了高级模型学习和预测、提取、奖励学习以及高级深度强化学习，例如信赖域策略梯度方法、actor-critic方法、探索方法。本门课有视频讲座。 链接：http://rll.berkeley.edu/deeprlcourse/ Yoshua Bengio: 深度学习与强化学习暑期学校 暑期学校是由Yoshua Bengio和他的同事们组织。课程包括了深度学习和强化学习两个方向，内容有两个领域的基本知识，研究趋势和最新发现。课程特别邀请这两个领域的主要学者和研究人员进行讲解。暑期学校有视频讲座。 链接：https://mila.quebec/en/cours/deep-learning-summer-school-2017/ Google &amp; Udacity: 深度学习 该课程由谷歌首席科学家Vincent Vanhoucke和Udacity的Arpan Chakraborty共同创立。课程内容包括深度学习、深层神经网络、卷积神经网络和针对文本和序列的深层模型。课程作业要求使用tensorflow。这门课有视频讲座。 链接：https://cn.udacity.com/course/deep-learning--ud730 斯坦福大学：基于深度学习的自然语言处理（CS224n） 该课程是2017年冬斯坦福大学 “cs224n：深度学习中的自然语言处理”课程的压缩版，也是斯坦福大学2018课程的延续版。课程讨论了如何将深度学习应用在自然语言处理中，自然语言处理中的问题以及在自然语言处理中使用深度学习的限制。讲师有Christopher Manning和Richard Socher。 链接：https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6 牛津大学：自然语言处理中的深度学习 本课程涵盖深度学习的基本原理以及如何将其应用在自然语言处理中。用户将学习如何定义这个领域中的数学问题，以及获得使用CPU和GPU的实际编程的经验。讲师分别来自牛津大学、CMU、DeepMind和英伟达公司。 这门课程包括视频讲座。 链接：https://github.com/oxford-cs-deepnlp-2017/lectures 李飞飞：视觉识别中的卷积神经网络（cs231n） 本课程将涵盖深度学习的基础知识，以及如何将深度学习技术应用于计算机视觉。学生将通过作业和最终项目获得如何训练和微调神经网络的实践经验。该课程主要使用Python语言。本课程包括视频讲座。 链接：http://cs231n.stanford.edu/ CMU: 深度强化学习与控制 本课程由苹果人工智能研究所主任Ruslan salakhutdinovat和CMU的Katerina Fragkiadaki主导。内容包括深度学习，强化学习，马尔可夫链决策过程（MDP），部分可观马尔可夫链决策过程（POMDPs），时序差分学习，Q学习，深度学习，深刻Q学习的基础知识。前沿话题包括最优化控制、轨道优化、层次强化学习和迁移学习。 链接：https://katefvision.github.io/ CMU: 深度学习入门 本课程由苹果公司人工智能研究所主任Ruslan Salakhutdinov主导，对深度学习做了一个快速而深入的介绍。课程共分为四个一小时时长的视频讲座，涵盖了监督学习，无监督学习，以及深度学习中的模型评估和开放式的研究问题等内容。 链接：https://simons.berkeley.edu/talks/tutorial-deep-learning RLDM: 深度强化学习入门 课程由DeepMind的David Silver主导，发表于第二届强化学习与决策多学科会议（RLDM）上。在这一个半小时的视频教程中，用户将了解深度学习，强化学习的基本原理，以及如何将深度学习和强化学习以各种方式结合：即深度价值函数，深度策略，和深度模型。此外，用户还能向顶级专家学习如何处理这些方法中的发散问题。 链接：http://videolectures.net/rldm2015_silver_reinforcement_learning/ UC Berkeley: 深度强化学习入门 这是一个关于强化学习长达一小时的教程，配有视频讲座。用户将看到强化学习能有多厉害。 链接：https://simons.berkeley.edu/talks/pieter-abbeel-2017-3-28 MLSS: 深度强化学习入门 课程由OpenAI公司的研究科学家John Schulman主导，包括4个1小时长的视频讲座，并带有针对实验室问题的练习。 链接：https://www.youtube.com/playlist?list=PLjKEIQlKCTZYN3CYBlj8r58SbNorobqcp","categories":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"}],"tags":[{"name":"深度学习 吴恩达","slug":"深度学习-吴恩达","permalink":"http://yoursite.com/tags/深度学习-吴恩达/"}],"keywords":[{"name":"人工智能","slug":"人工智能","permalink":"http://yoursite.com/categories/人工智能/"}]},{"title":"国内配置gradle","slug":"国内配置gradle","date":"2018-01-22T14:14:45.000Z","updated":"2018-02-07T14:39:12.000Z","comments":true,"path":"2018/01/22/国内配置gradle/","link":"","permalink":"http://yoursite.com/2018/01/22/国内配置gradle/","excerpt":"","text":"不知zf是怎么想的，为何要把Google developer给q了，导致Android开发很痛苦，如果不fq，那么gradle里面库就没法下载，不过感谢阿里云，在国内搭建了一个国内的gradle仓库。下面就配置一下国内的gradle仓库 1. 单个项目配置用这种方式仅对单个项目生效，不会影响其他的项目 buildscript { repositories { maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; } maven{ url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;} } dependencies { classpath &#39;com.android.tools.build:gradle:2.2.3&#39; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; } maven{ url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;} } } 2. 配置对所有项目生效在USER_HOME/.gradle/下创建init.gradle文件，填入以下内容： allprojects{ repositories { def ALIYUN_REPOSITORY_URL = &#39;http://maven.aliyun.com/nexus/content/groups/public&#39; def ALIYUN_JCENTER_URL = &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39; all { ArtifactRepository repo -&gt; if(repo instanceof MavenArtifactRepository){ def url = repo.url.toString() if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;)) { project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.&quot; remove repo } if (url.startsWith(&#39;https://jcenter.bintray.com/&#39;)) { project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.&quot; remove repo } } } maven { url ALIYUN_REPOSITORY_URL url ALIYUN_JCENTER_URL } } } 这样新建项目时用的gradle仓库也是阿里云的。","categories":[{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/categories/gradle/"}],"tags":[{"name":"gradle配置","slug":"gradle配置","permalink":"http://yoursite.com/tags/gradle配置/"}],"keywords":[{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/categories/gradle/"}]},{"title":"Android中onSaveInstanceState和onRestoreInstanceState讲解","slug":"Android中onSaveInstanceState和onRestoreInstanceState讲解","date":"2018-01-19T10:21:47.000Z","updated":"2018-01-19T16:18:59.000Z","comments":true,"path":"2018/01/19/Android中onSaveInstanceState和onRestoreInstanceState讲解/","link":"","permalink":"http://yoursite.com/2018/01/19/Android中onSaveInstanceState和onRestoreInstanceState讲解/","excerpt":"","text":"在Android系统中，有时系统可能因为系统资源不够而杀死(kill)某些Activity，在kill Activity之前会调用 onSaveInstanceState来保存一些状态信息(当然也可以保存其他信息)，当再次回到该Activity时，系统会调用onRestoreInstanceState来恢复数据。 下面先讲一下onSaveInstance的调用时机，也就是会在什么情况下被调用。onSaveInstance不是Activity正常生命周期里面的函数。在Google API文档上是这样介绍的： Android calls onSaveInstanceState() before the activity becomesvulnerable to being destroyed by the system, but does not bother calling itwhen the instance is actually being destroyed by a user action (such aspressing the BACK key)。也就是当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的该方法不会调用，例如当用户按BACK键的时候。“容易”包含以下几种情况：1、当用户按下HOME键时。当按下HOME键后，由于系统不知道用户会新开多少程序，因而这个Activity可能会由于系统资源不足而被系统kill，因为在onPause之后会调用onSaveInstance来保存数据。2、长按HOME键，选择运行其他的程序时。分析同上。3、按下电源按键（关闭屏幕显示）时。分析同上。4、从activity A中启动一个新的activity时。分析同上。5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行。 一般调用方式如下： @Override protected void onSaveInstanceState(Bundle outState) { // TODO Auto-generated method stub //这里保存需要保存的数据 String string = edit.getText().toString(); outState.putString(&quot;test&quot;, string); super.onSaveInstanceState(outState); } 系统kill进程是有个先后顺序的：在Google上是这样介绍的ProcessLifecycle,其解释如下：一般系统杀死进程的顺序是： Android系统会尽力保持应用的进程，但是有时为了给新的进程和更重要的进程回收一些内存空间，它会移除一些旧的进程。 为了决定哪些进程留下，哪些进程被杀死，系统根据在进程中在运行的组件及组件的状态，为每一个进程分配了一个优先级等级。 优先级最低的进程首先被杀死。 这个进程重要性的层次结构有五个等级，下面就列出这五种进程，按照重要性来排列，最重要的放在最前。 前台进程 Foreground process前台进程是用户当前做的事所必须的进程，如果满足下面各种情况中的一种，一个进程被认为是在前台：1.1 进程持有一个正在与用户交互的Activity（Activity正处于onResume()的状态）。1.2 进程持有一个Service，这个Service和用户正在交互的Activity绑定。1.3 进程持有一个Service，这个Service是在前台运行的，即它调用了**[startForeground()](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification))**。1.4 进程持有一个Service，这个Service正在执行它的生命周期回调函数（[onCreate()](http://developer.android.com/reference/android/app/Service.html#onCreate()), [onStart()](http://developer.android.com/reference/android/app/Service.html#onStart(android.content.Intent, int)), or [onDestroy()](http://developer.android.com/reference/android/app/Service.html#onDestroy())）。1.5 进程持有一个BroadcastReceiver，这个BroadcastReceiver正在执行它的 [onReceive()](http://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent)) 方法。杀死前台进程需要用户交互，因为前台进程的优先级是最高的。 2.可见进程 Visible process 如果一个进程不含有任何前台的组件，但是仍然影响着用户在屏幕上可以看到的内容，就是可见进程。 可见进程满足下列情况之一： 1.进程持有一个Activity，这个Activity不在前台，但是仍然被用户可见（处于onPause()调用后又没有调用onStop()的状态）。 这种情况发生在，比如，前台的activity打开了一个对话框，这样activity就会在其后可见。 2.进程持有一个Service，这个Service和一个可见的（或者前台的）Activity绑定。 可见的进程也被认为是很重要的，一般不会被销毁，除非是为了保证所有前台进程的运行而不得不杀死可见进程的时候。 服务进程 Service process 如果一个进程中运行着一个service，这个service是通过 [startService()](http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent)) 开启的，并且不属于上面两种较高优先级的情况，这个进程就是一个服务进程。 尽管服务进程没有和用户可以看到的东西绑定，但是它们一般在做的事情是用户关心的，比如后台播放音乐，后台下载数据等。 后台进程 Background process 如果进程不属于上面三种情况，但是进程持有一个用户不可见的activity（activity的onStop()被调用，但是onDestroy()没有调用的状态），就认为进程是一个后台进程。 后台进程不直接影响用户体验，系统会为了前台进程、可见进程、服务进程而任意杀死后台进程。 通常会有很多个后台进程存在，它们会被保存在一个LRU (least recently used)列表中，这样就可以确保用户最近使用的activity最后被销毁，即最先销毁时间最远的activity。 空进程 如果一个进程不包含任何活跃的应用组件，则认为是空进程。 保存这种进程的唯一理由是为了缓存的需要，为了加快下次要启动这个进程中的组件时的启动时间。 系统为了平衡进程缓存和底层内核缓存的资源，经常会杀死空进程。 相关说明 1.Android会尽可能地把进程放在高的优先级。 比如，一个进程拥有一个可见状态的activity和一个service，这个进程会被认为是可见进程，而不是服务进程。 2.一个进程的等级有可能会因为其他进程的依赖而提高，一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低。 比如，A进程中的一个content provider向B进程中的一个客户提供服务，或A进程中的一个service被绑定在B进程中的一个组件上，则A进程的优先级至少和B进程的优先级一样高。 3.因为服务进程的优先级比后台进程的优先级高，所以对于一个需要启动一个长时间操作的activity来说，开启一个service比创建一个工作线程的方法更好，尤其是对于操作将很可能超出activity的持续时间时。 比如要上传一个图片文件，应该开启一个service来进行上传工作，这样在用户离开activity时工作仍在进行。使用service将会保证操作至少有服务进程的优先级。 总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据。onSaveInstanceState的调用是在onPause（）之后执行的，即：onPause（）—&gt;onSaveInstanceState()–&gt;onStop( );至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。onRestoreInstanceState的bundle参数会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。onRestoreInstanceState()在onStart() 和 onPostCreate(Bundle)之间调用。一般调用方式如下： @Override protected void onRestoreInstanceState(Bundle savedInstanceState) { // TODO Auto-generated method stub //在Activity因为系统额崩溃后，会调用该函数进行数据恢复，恢复的数据就是通过onSaveInstanceState保存的数据 super.onRestoreInstanceState(savedInstanceState); if (savedInstanceState!=null) { String test = savedInstanceState.getString(&quot;test&quot;); if (test!=null) { edit.setText(test); } } } 在新版的SDK中，也就是API大于21的版本中新增了如下两个函数： /** * 系统重启后，数据恢复能力。需要api&gt;21 */ @Override public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) { // TODO Auto-generated method stub //这里保存持久化数据，该函数会调用上面一个函数。因而第一个outState会通过上一个函数保存 String string = edit.getText().toString(); outPersistentState.putString(&quot;test&quot;, string); super.onSaveInstanceState(outState, outPersistentState); } /** * 系统重启后，数据恢复能力。需要api&gt;21就 * 这个方法会调用onRestoreInstanceState(Bundle savedInstanceState)方法。 */ @Override public void onRestoreInstanceState(Bundle savedInstanceState, PersistableBundle persistentState) { // TODO Auto-generated method stub //系统因而意外重启后会调用该方法进行数据恢复，这个需要在manifest.xml里面注册： android:persistableMode=&quot;persistAcrossReboots&quot; super.onRestoreInstanceState(savedInstanceState, persistentState); if (persistentState!=null) { String test = persistentState.getString(&quot;test&quot;); if (test!=null) { edit.setText(test); } } } 这两个函数主要是为了系统重启后的数据恢复，使用时需要在AndroidManifest.xml里面的activity中添加android:persistableMode=”persistAcrossReboots”属性。PersistableBundle和Bundle差不多，是以key-value的形式使用的。具体代码见如下工程。 工程源码：onSaveInstance测试工程","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"onSaveInstanceState","slug":"onSaveInstanceState","permalink":"http://yoursite.com/tags/onSaveInstanceState/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"AppLinks使用详解","slug":"AppLinks使用详解","date":"2018-01-18T08:58:44.000Z","updated":"2018-01-22T13:27:22.000Z","comments":true,"path":"2018/01/18/AppLinks使用详解/","link":"","permalink":"http://yoursite.com/2018/01/18/AppLinks使用详解/","excerpt":"","text":"1. 简介官方介绍Android App Links内容是： Android App Links are a special type of deep link that allow your website URLs to immediately open the corresponding content in your Android app (without requiring the user to select the app). To add Android App Links to your app, define intent filters that open your app content using HTTP URLs (as described in [Create Deep Links to App Content]), and verify that you own both your app and the website URLs (as described in this guide). If the system successfully verifies that you own the URLs, the system automatically routes those URL intents to your app. 意思就是AppLinks是一个特殊的DeepLink，它可以让你的应用和你的网站URL进行绑定，这样当你在点击你网站链接的时候（非浏览器中）就能调起你的App，而不是出现选择界面，使用方法如下Create Deep Links to App Content这种绑定不是在点击的时候才核对链接，下面会介绍在什么情况下核对这种绑定的。 2. 与DeepLink的区别官方是这样介绍DeepLink的。 A [deep link] is an intent filter that allows users to directly enter a specific activity in your Android app. Clicking one of these links might open a disambiguation dialog, which allows the user to select one of multiple apps (including yours) that can hande the given URL. For example, figure 1 shows the disambiguation dialog after the user clicks a map link, asking whether to open the link in Maps or Chrome. Deeplink是一个intent过滤器，他可以使用户直接进入某个Activity页面。但是有个不好的是当匹配到多个intent时就会弹一个让用户选择的框。官方给了下面一张图，而AppLinks就不会有这个弹框：具体区别官方也列了以下： Item Deep links App links Intent URL scheme http, https, or a custom scheme Requires http or https Intent action Any action Requires android.intent.action.VIEW Intent category Any category Requires android.intent.category.BROWSABLE and android.intent.category.DEFAULT Link verification None Requires a Digital Asset Links file served on you website with HTTPS User experience May show a disambiguation dialog for the user to select which app to open the link No dialog; your app opens to handle your website links Compatibility All Android versions Android 6.0 and higher 3.使用步骤官方给的步骤如下Handling Android App Links 3.1 在manifest中开启autoVerify&lt;activity ...&gt; &lt;intent-filter android:autoVerify=&quot;true&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;www.example.com&quot; /&gt; &lt;data android:scheme=&quot;https&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这里注意下，开启autoVerify的activity中的的action必须为android.intent.action.VIEW，category必须包含android.intent.category.BROWSABLE，data的scheme必须包含http/https,否则不生效，而且AppLinks必须在Android 6.0 以上的手机才可生效。验证包含以下几方面： 系统会检查包含以下几方面的所有intent-filter Action: android.intent.action.VIEW Categories: android.intent.category.BROWSABLE and android.intent.category.DEFAULT Data scheme: http or https 原话是：For each unique host name found in the above intent filters, Android queries the corresponding websites for the Digital Asset Links file at https://hostname/.well-known/assetlinks.json.。翻译过来就是系统会读取网站的/.well-known/assetlinks.json文件，然后验证包名和签名是否包含在assetlinks.json文件中。 当且仅当上面两个条件满足时才会形成绑定。 3.2 支持多hosts的绑定。&lt;intent-filter&gt; ... &lt;data android:scheme=&quot;https&quot; android:host=&quot;www.example.com&quot; /&gt; &lt;data android:scheme=&quot;app&quot; android:host=&quot;open.my.app&quot; /&gt; &lt;/intent-filter&gt; 上面在同一个里面写的两个，他们除了组合https://www.example.com和app://open.my.app外app://www.example.com和 https://open.my.app也是满足上面的的。而分开写的时候，不存在上面的问题。 3.3 在网站上创建assetlinks.json文件具体格式如下： [{ &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;], &quot;target&quot;: { &quot;namespace&quot;: &quot;android_app&quot;, &quot;package_name&quot;: &quot;com.example&quot;, &quot;sha256_cert_fingerprints&quot;: [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;] } }] 其中package_name就是应用的包名，sha256_cert_fingerprints为正式版的签名。上传时修改这两个属性值。如果一个应用对于多个网站时，可以配置多个对象，配置如下： [{ &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;], &quot;target&quot;: { &quot;namespace&quot;: &quot;android_app&quot;, &quot;package_name&quot;: &quot;com.example.puppies.app&quot;, &quot;sha256_cert_fingerprints&quot;: [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;] } }, { &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;], &quot;target&quot;: { &quot;namespace&quot;: &quot;android_app&quot;, &quot;package_name&quot;: &quot;com.example.monkeys.app&quot;, &quot;sha256_cert_fingerprints&quot;: [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;] } }] 然后将该文件放在网站的.well-known目录下，放了之后要试试能不能用： https://domain.name/.well-known/assetlinks.json 提交完后确定以下几个是否正确： Be sure of the following: * The `assetlinks.json` file is served with content-type `application/json`. * The `assetlinks.json` file must be accessible over an HTTPS connection, regardless of whether your app&#39;s intent filters declare HTTPS as the data scheme. * The `assetlinks.json` file must be accessible without any redirects (no 301 or 302 redirects) and be accessible by bots (your `robots.txt` must allow crawling `/.well-known/assetlinks.json`). * If your app links support multiple host domains, then you must publish the `assetlinks.json` file on each domain. See [Supporting app linking for multiple hosts](https://developer.android.com/training/app-links/verify-site-associations.html#multi-host). * Do not publish your app with dev/test URLs in the manifest file that may not be accessible to the public (such as any that are accessible accessible only with a VPN). A work-around in such cases is to [configure build variants](https://developer.android.com/studio/build/build-variants.html) to generate a different manifest file for dev builds 还有AppLinks仅支持https的网站。 3.4 测试AppLinks 测试json文件是否正确，请看 Statement List Generator and Tester也可以采用以下链接进行验证：https://digitalassetlinks.googleapis.com/v1/statements:list? source.web.site=https://domain.name:optional_port&amp; relation=delegate_permission/common.handle_all_urls 测试intent是否正确可以使用adb进行测试，命令如下：adb shell am start -a android.intent.action.VIEW \\ -c android.intent.category.BROWSABLE \\ -d &quot;http://domain.name:optional_port&quot; 下面命令测试已经存在的绑定：adb shell dumpsys package domain-preferred-apps 上面命令等价于：adb shell dumpsys package d 如果存在绑定的会显示如下结果：Package: com.android.vending Domains: play.google.com market.android.com Status: always : 200000002 参数含义如下：``` Package - Identifies an app by its package name, as declared in its manifest. Domains - Shows the full list of hosts whose web links this app handles, using blank spaces as delimiters. Status - Shows the current link-handling setting for this app. An app that has passed verification, andwhose manifest contains android:autoVerify=”true”, shows a status of always. The hexadecimal number afterthis status is related to the Android system’s record of the user’s app linkage preferences. This value doesnot indicate whether verification succeeded.``` 4. 总结 优点： 不会弹选择框 可以直接通过url跳到对应的activity 缺点： 网站需要支持https 有个校验过程，步骤麻烦些。 使用该机制可以直接绕过intent方式，直接通过url就能打开对应的界面。不过在设置中还是能关闭这个。目前支持该功能的应用和网站还是很少。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"AppLinks, DeepLinks","slug":"AppLinks-DeepLinks","permalink":"http://yoursite.com/tags/AppLinks-DeepLinks/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"DeepLink用法及原理解析","slug":"DeepLink用法及原理解析","date":"2018-01-18T04:34:20.000Z","updated":"2018-01-18T13:51:00.000Z","comments":true,"path":"2018/01/18/DeepLink用法及原理解析/","link":"","permalink":"http://yoursite.com/2018/01/18/DeepLink用法及原理解析/","excerpt":"","text":"1. 简介DeepLink官网上有这样的解释： When a clicked link or programmatic request invokes a web URI intent, the Android system tries each of the following actions, in sequential order, until the request succeeds: 1. Open the user&#39;s preferred app that can handle the URI, if one is designated. 2. Open the only available app that can handle the URI. 3. Allow the user to select an app from a dialog. Follow the steps below to create and test links to your content. You can also use the [App Links Assistant](https://developer.android.com/studio/write/app-link-indexing.html) in Android Studio to add Android App Links 翻译后的意思就是：当单击链接或编程请求调用Web URI意图时，Android系统按顺序依次尝试以下每一个操作，直到请求成功为止： 打开用户首选的应用程序，它可以处理URI，如果指定的话。 打开可以处理URI的惟一可用应用程序。 允许用户从对话框中选择应用程序。 意思也就是用户可以自己写一串字符串，系统会对该字符串进行解析，然后调起注册过相应scheme的应用，如果有多个注册了，那么就会弹出对话框让用户选择。 2. 用法Google官方给了一个样例：search-samples以下根据Android官方的deep-linking的样例来说明如何使用。 &lt;activity android:name=&quot;com.example.android.GizmosActivity&quot; android:label=&quot;@string/title_gizmos&quot; &gt; &lt;intent-filter android:label=&quot;@string/filter_view_http_gizmos&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;!-- Accepts URIs that begin with &quot;http://www.example.com/gizmos” --&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;www.example.com&quot; android:pathPrefix=&quot;/gizmos&quot; /&gt; &lt;!-- note that the leading &quot;/&quot; is required for pathPrefix--&gt; &lt;/intent-filter&gt; &lt;intent-filter android:label=&quot;@string/filter_view_example_gizmos&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;!-- Accepts URIs that begin with &quot;example://gizmos” --&gt; &lt;data android:scheme=&quot;example&quot; android:host=&quot;gizmos&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 在上面有两个这两个只是在上有所区别，但是官方仍然建议我们分开写。比如： &lt;intent-filter&gt; ... &lt;data android:scheme=&quot;https&quot; android:host=&quot;www.example.com&quot; /&gt; &lt;data android:scheme=&quot;app&quot; android:host=&quot;open.my.app&quot; /&gt; &lt;/intent-filter&gt; 上面在同一个里面写的两个，他们除了组合https://www.example.com和app://open.my.app外app://www.example.com和 https://open.my.app也是满足上面的的。而分开写的时候，不存在上面的问题。当你添加了上面的当你的Activity上面时，其他App，就可以通过一个intent去调起你的应用，官方这样说到： Once you’ve added intent filters with URIs for activity content to your app manifest, Android is able to route any Intent that has matching URIs to your app at runtime.当注册了后，便可以在Activity的中获取其他应用传过来的intent值，具体调用如下： @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Intent intent = getIntent(); String action = intent.getAction(); Uri data = intent.getData(); } getIntent可以在Activity的生命周期的任何时段进行获取，不过一般别人应用要调你应用，肯定都是希望进入你的应用某个界面，或实现某个功能。其他应用会把该传的信息都传给你，最好的解析地方肯定是onCreate（或onStart但onStart还是会晚一些）。对于这个官方给了以下建议： * The deep link should take users directly to the content, without any prompts, interstitial pages, or logins. Make sure that users can see the app content even if they never previously opened the application. It is okay to prompt users on subsequent interactions or when they open the app from the Launcher. This is the same principle as the [first click free](https://support.google.com/webmasters/answer/74536?hl=en) experience for web sites. * Follow the design guidance described in [Navigation with Back and Up](https://developer.android.com/design/patterns/navigation.html) so that your app matches users&#39; expectations for backward navigation after they enter your app through a deep link 意思就是： 打开应用后应该直接到内容，不要有任何提示，间接的页面，或登录。确保用户可以看到应用程序的内容，即使他们以前从未打开过应用程序。可以在随后的交互中提示用户，或者在启动程序中打开应用程序。这与网站第一次点击免费体验的原理是相同的。 遵循导航与后退和向上描述的设计指南，使您的应用程序与用户通过向后链接进入您的应用程序的深度导航的期望相符。 实现上面代码后就可以进行测试了。在测试时可以使用adb的shell命令进行测试，语法格式如下： $ adb shell am start -W -a android.intent.action.VIEW -d &lt;URI&gt; &lt;PACKAGE&gt; 例如我们上面的例子就可以采用如下方式进行打开： $ adb shell am start -W -a android.intent.action.VIEW -d &quot;example://gizmos&quot; com.example.android 上面的intent也可以通过浏览器里面的网页进行设置，现在浏览器都会解析这个intent然后调起对应的应用，即可以直接在网页中调起应用。 DeepLink使得开发网站和自己的App能很好的相互交互。而且一个intent字符串也好发送，比如你想推广你的App，你就可以把这个intent发给广告商，然后点击的时候就把这个intent给手机浏览器，通过浏览器调起你自己的应用。这个最好的应用还在搜索上，在搜索的时候，当用户搜到对应内容的时候，现在一般都是跳网站。但是如果有DeepLink，那么就可以直接通过DeepLink的intent直接跳转到你自己的App，这既方便了用户，也方便了开发者。 3. DeepLink原理分析3.1 DeepLinkDispatch框架DeepLinkDispatch是Airbnb推出的一个以注解形式来实现dispatch跳转的框架。这个它的简单介绍README.md。 3.2 Dispatch框架使用例子@DeepLink(&quot;foo://example.com/deepLink/{id}&quot;) public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = getIntent(); if (intent.getBooleanExtra(DeepLink.IS_DEEP_LINK, false)) { Bundle parameters = intent.getExtras(); String idString = parameters.getString(&quot;id&quot;); // Do something with idString } } } 多个的注解 //多filter的注解 @DeepLink({&quot;foo://example.com/deepLink/{id}&quot;, &quot;foo://example.com/anotherDeepLink&quot;}) public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Intent intent = getIntent(); if (intent.getBooleanExtra(DeepLink.IS_DEEP_LINK, false)) { Bundle parameters = intent.getExtras(); String idString = parameters.getString(&quot;id&quot;); // Do something with idString } } } 某个方法的注解： @DeepLink(&quot;foo://example.com/methodDeepLink/{param1}&quot;) public static Intent intentForDeepLinkMethod(Context context, Bundle extras) { Uri.Builder uri = Uri.parse(extras.getString(DeepLink.URI)).buildUpon(); return new Intent(context, MainActivity.class) .setData(uri.appendQueryParameter(&quot;bar&quot;, &quot;baz&quot;).build()) .setAction(ACTION_DEEP_LINK_METHOD); } 上面的注解相当于DeepLink中在manifest中的Activity标签下注册的，在DeepLinkDispatch中还可以注册一个广播接收者来接收分发的DeepLink字符串。 public class DeepLinkReceiver extends BroadcastReceiver { private static final String TAG = &quot;DeepLinkReceiver&quot;; @Override public void onReceive(Context context, Intent intent) { String deepLinkUri = intent.getStringExtra(DeepLinkHandler.EXTRA_URI); if (intent.getBooleanExtra(DeepLinkHandler.EXTRA_SUCCESSFUL, false)) { Log.i(TAG, &quot;Success deep linking: &quot; + deepLinkUri); } else { String errorMessage = intent.getStringExtra(DeepLinkHandler.EXTRA_ERROR_MESSAGE); Log.e(TAG, &quot;Error deep linking: &quot; + deepLinkUri + &quot; with error message +&quot; + errorMessage); } } } public class YourApplication extends Application { @Override public void onCreate() { super.onCreate(); IntentFilter intentFilter = new IntentFilter(DeepLinkHandler.ACTION); //使用应用内广播注册的，不用担心其他应用收到 LocalBroadcastManager.getInstance(this).registerReceiver(new DeepLinkReceiver(), intentFilter); } } 下面就来分析下它的原理。 3.3 源码剖析3.3.1 根据注解生成对应class文件在AS点击build后即可生成对应的class文件，主要的文件有以下几个：在DeepLinkDispatch框架中主要是通过DeepLinkDelegate代理来处理传来的Uri，在DeepLinkDelegate中主要是dispatchFrom这个方法来处理Uri。代码如下： 收下根据getIntent.getData()即可获取到对应的uri。 然后通过DeepLinkLoader.load()来加载注册的uri。代码如下 调用loader.parseUri去解析Uri，解析完成后返回的是DeepLinkEntry来供我们使用。 解析Uri中的key-value对，代码仍然在dispatchFrom中。 其中DeepLinkUri.getParameters代码如下： 然后调用了该类的parseParameters获取patterns集合。 从DeepLink的intent中获取的就是key，具体跳转的内容就是value。 DeepLinkUri.queryParameterNames通过queryParameterNames就把真实的Uri解析成对应的注解了，之后就会进行分发逻辑了。 具体分发逻辑6.1 首先生成Intent对象6.2 setAction和data，通过以上将action和data放入Intent中。6.3 处理Bundle。6.4 调用callingActivity。6.5 startActivity6.6 createResultAndNotify 通过以上步骤就完成了DeepLink调起应用页面的操作了，具体代码稍后再贴。 4. 总结 DeepLink实现了网页直接和App直接跳转。之前手机上的每个App都相当于一个个孤岛，没有办法和广泛的网站实现直接的跳转。现在比如你在浏览微博的时候看到某个App上面有精彩的内容，你就可以直接点击链接跳转到App里面（甚至可以判断如果按照了App就进入App里面，如果不安装那么就进入应用市场的该App下载界面），这样的交互很方便，很好的将App连接到了整个网络世界，以后有个浏览器就能随意的跳转。 DeepLink完全可以在搜索中使用，目前的搜索都是搜到了内容还是调网页。以后如果开发者把自己的DeepLink链接提交给搜索公司，那么在搜索到对应的结果的时候就可以直接点击搜到的结果跳转到自己的App了。这个还能应用到广告上去。推广自己的App就更容易了。 DeepLink使得大企业的众多App之间相互拉活，相互跳转。假如某公司有个超级App，那么想推广自己的其他App就可以使用DeepLink在开启自己某个子页面的时候，把这个子页面交给其他App进行处理。这样就拉活了自己的其他App了。 在DeepLink的基础上，Google又新出了一个AppLinks，AppLinks就是你自己的网站和你自己的App相互关联了。比如用户在短信中点击了你的网站，那么就可以直接跳转到你的App，而不会出现选择对话框。Google官方是这样说的：```Android App Links are a special type of deep link that allow your website URLs to immediately open thecorresponding content in your Android app (without requiring the user to select the app). To add Android App Links to your app, define intent filters that open your app content using HTTP URLs (as described in [Create Deep Links to App Content]), and verify that you own both your app and the website URLs (as described in this guide). If thesystem successfully verifies that you own the URLs, the system automatically routes those URL intents to your app.```创建你自己的AppLinks，可以参考如下Create Deep Links to App Content。后续我会专门写篇文章介绍下AppLinks及其用法。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android DeepLink 源码解析","slug":"Android-DeepLink-源码解析","permalink":"http://yoursite.com/tags/Android-DeepLink-源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Android应用内部广播机制详解","slug":"Android应用内部广播机制详解","date":"2018-01-17T10:07:47.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"2018/01/17/Android应用内部广播机制详解/","link":"","permalink":"http://yoursite.com/2018/01/17/Android应用内部广播机制详解/","excerpt":"","text":"1. 简介通常我们在使用Android广播的时候都会直接将广播注册到系统的AMS当中，由于AMS任务繁忙，一般可能不会立即能处理到我们发出的广播，如果我们使用广播是在应用内的单个进程中使用，则完全可以采用LocalBroadcastManager来处理。LocalBroadcastManager采用的是Handler的消息机制来处理的广播，而注册到系统中的是通过Binder机制实现的，速度是应用内广播要快很多。不过由于Handler的消息机制是为了同一个进程的多线程间进行通信的，因而跨进程时无法使用应用内广播。 1.1 使用在使用上和普通的Broadcast类似，主要分5步。具体如下： //1. 自定义广播接收者 public class LocalReceiver extends BroadcastReceiver { public void onReceive(Context context, Intent intent) { ... } } LocalReceiver localReceiver = new LocalReceiver(); //2. 注册广播 LocalBroadcastManager.getInstance(context) .registerReceiver(localReceiver, new IntentFilter(“test”)); //4. 发送广播 LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(&quot;test&quot;)); //5. 取消注册广播 LocalBroadcastManager.getInstance(context).unregisterReceiver(localReceiver); 自定义广播和普通的广播一样，在注册广播的时候将该广播接受者注册到LocalBroadcatManager中。当发生时也是调用LocalBroadcastManager的sendBroadcast进行发生。同样在不使用时记得取消广播注册。 2. LocalBroadcastManager2.1 初始化LocalBroadcastManager采用的是单例模式，其构造函数是私有的，获取该类实例的方法是getInstance，具体代码如下： private final Handler mHandler; private static final Object mLock = new Object(); private static LocalBroadcastManager mInstance; public static LocalBroadcastManager getInstance(Context context) { synchronized (mLock) { if (mInstance == null) { mInstance = new LocalBroadcastManager(context.getApplicationContext()); } return mInstance; } } private LocalBroadcastManager(Context context) { mAppContext = context; //mHandler是主线程的 mHandler = new Handler(context.getMainLooper()) { @Override public void handleMessage(Message msg) { switch (msg.what) { case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts();//这里去执行广播分发 break; default: super.handleMessage(msg); } } }; } 在构造函数中创建了一个mHandler，该mHandler关联的是主线程的Looper。即消息处理时都在主线程中处理。 2.2 registerReceiverpublic void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) { //在注册，取消注册，发送广播的时候都需要先获取mReceivers的锁 synchronized (mReceivers) { //新建一个ReceiverRecord实体表示该receiver及对应的filter ReceiverRecord entry = new ReceiverRecord(filter, receiver); //获取receiver对应的filters ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver); if (filters == null) { //如果该receiver没有对应的filters则，新建一个。 filters = new ArrayList&lt;IntentFilter&gt;(1); mReceivers.put(receiver, filters); } //将filter放入该receiver对应的filters中 filters.add(filter); for (int i=0; i&lt;filter.countActions(); i++) { String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) { entries = new ArrayList&lt;ReceiverRecord&gt;(1); //将action放入mActions中 mActions.put(action, entries); } entries.add(entry); } } } 注册的时候也就是将receiver自己和对应的filter及action放入到mReceivers和mActions当中。代码比较简单。 2.3 发送广播sendBroadcastpublic boolean sendBroadcast(Intent intent) { synchronized (mReceivers) { final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); final boolean debug = DEBUG || ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0); if (debug) Log.v( TAG, &quot;Resolving type &quot; + type + &quot; scheme &quot; + scheme + &quot; of intent &quot; + intent); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction()); if (entries != null) { if (debug) Log.v(TAG, &quot;Action list: &quot; + entries); ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) { ReceiverRecord receiver = entries.get(i); if (debug) Log.v(TAG, &quot;Matching against filter &quot; + receiver.filter); if (receiver.broadcasting) { if (debug) { Log.v(TAG, &quot; Filter&#39;s target already added&quot;); } continue; } int match = receiver.filter.match(action, type, scheme, data, categories, &quot;LocalBroadcastManager&quot;); if (match &gt;= 0) { if (debug) Log.v(TAG, &quot; Filter matched! match=0x&quot; + Integer.toHexString(match)); if (receivers == null) { receivers = new ArrayList&lt;ReceiverRecord&gt;(); } receivers.add(receiver); receiver.broadcasting = true; } else { if (debug) { String reason; switch (match) { case IntentFilter.NO_MATCH_ACTION: reason = &quot;action&quot;; break; case IntentFilter.NO_MATCH_CATEGORY: reason = &quot;category&quot;; break; case IntentFilter.NO_MATCH_DATA: reason = &quot;data&quot;; break; case IntentFilter.NO_MATCH_TYPE: reason = &quot;type&quot;; break; default: reason = &quot;unknown reason&quot;; break; } Log.v(TAG, &quot; Filter did not match: &quot; + reason); } } } if (receivers != null) { for (int i=0; i&lt;receivers.size(); i++) { receivers.get(i).broadcasting = false; } mPendingBroadcasts.add(new BroadcastRecord(intent, receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) { mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); } return true; } } } return false; } 主要步骤：1.根据Intent的action来查询相应的广播接收者列表；2.创建相应广播，添加到mPendingBroadcasts队列；3.发送MSG_EXEC_PENDING_BROADCASTS消息。将消息传给主线程进行处理。4.主线程mHandler接受到后就由该类的handlerMessage进行处理。在该方法中调用executePendingBroadcasts()进行处理 private void executePendingBroadcasts() { while (true) { BroadcastRecord[] brs = null; synchronized (mReceivers) {//注意多线程下的同步 final int N = mPendingBroadcasts.size(); if (N &lt;= 0) { return; } brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs);//把待处理的广播转成数组形式 mPendingBroadcasts.clear();//然后就可以把mPendingBroadcasts清空 } //for循环变量每个接受者，然后调用对应的onReceive for (int i=0; i&lt;brs.length; i++) { BroadcastRecord br = brs[i]; for (int j=0; j&lt;br.receivers.size(); j++) { br.receivers.get(j).receiver.onReceive(mAppContext, br.intent); } } } } 处理也很简单，查询相应的变量，找到有多少个接受者，然后调用接受者的onReceive，该调用在主线程中，因而不要做耗时操作。在LocalBroadcastManager中还提供了同步发送广播处理的方法： //使用该方法会立即去让接受者处理广播。 public void sendBroadcastSync(Intent intent) { if (sendBroadcast(intent)) { executePendingBroadcasts(); } } 2.4 广播的注销 public void unregisterReceiver(BroadcastReceiver receiver) { synchronized (mReceivers) { ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver); if (filters == null) { return; } for (int i=0; i&lt;filters.size(); i++) { IntentFilter filter = filters.get(i); for (int j=0; j&lt;filter.countActions(); j++) { String action = filter.getAction(j); ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action); if (receivers != null) { for (int k=0; k&lt;receivers.size(); k++) { if (receivers.get(k).receiver == receiver) { receivers.remove(k); k--; } } if (receivers.size() &lt;= 0) { mActions.remove(action); } } } } } } 注销广播也很简单，找到注册时候添加到List中的变量，然后remove掉。注意要讲mReceivers,mActions里面保存的都remove了。 3.总结和普通广播比，应用内广播安全，速度快。缺点是只能在应用的一个进程中使用，不能跨进程使用。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"应用内部广播,LocalBroadcastManager","slug":"应用内部广播-LocalBroadcastManager","permalink":"http://yoursite.com/tags/应用内部广播-LocalBroadcastManager/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"SharedPreferences源码详解","slug":"SharedPreferences源码详解","date":"2018-01-17T03:59:33.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"2018/01/17/SharedPreferences源码详解/","link":"","permalink":"http://yoursite.com/2018/01/17/SharedPreferences源码详解/","excerpt":"","text":"1.简介写这篇博客目的在于巩固自己对SharedPreferences的理解。SharePreferences是Android系统提供的轻量级数据存储方案，主要基于键值对方式保存数据，真实的数据是保存在/data/data/packageName/shared_pref/目录下面的。可以保存多种数据到该文件中，以下是一个简单的Sharepreference文件。 &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt; &lt;map&gt; &lt;boolean name=&quot;btest&quot; value=&quot;true&quot; /&gt; &lt;string name=&quot;stest&quot;&gt;string&lt;/string&gt; &lt;int name=&quot;itest&quot; value=&quot;999&quot; /&gt; &lt;long name=&quot;ltest&quot; value=&quot;1516358782&quot; /&gt; &lt;int name=&quot;itest_1&quot; value=&quot;2&quot; /&gt; &lt;/map&gt; 从文件中可以看出就是采用简单xml方式进行保存的。 1.1使用实例SharedPreferences preferences = context.getSharedPreferences(&quot;share&quot;, Context.MODE_PRIVATE); SharedPreferences.Editor editor = preferences.edit(); editor.putBoolean(&quot;btest&quot;, true); editor.putString(&quot;stest&quot;, &quot;string test&quot;); //editor.apply();//异步保存 editor.commit();//同步保存 1.2基本结构这里借用Gityuan博客中的类继承图在Sharepreference中，Sharepreference和Editor只是两个接口，在这两个接口中定义了一个普通的键值对存储的数据一些常用的操作。然后具体你想把这键值对存哪，你可以自己定义相应的文件或数据库，甚至你可以写个保存到网络中去。在Android系统中给出的是采用xml方式存在xml的文件中，具体实现类是SharepreferenceImpl和SharepreferenceImpl.EditorImpl。同时在ContextImpl中有Sharepreference的对应内存中的数据。 2.Sharepreference源码分析2.1获取SharepreferenceActivity.java public SharedPreferences getPreferences(int mode) { return getSharedPreferences(getLocalClassName(), mode); } @Override public SharedPreferences getSharedPreferences(String name, int mode) { return mBase.getSharedPreferences(name, mode); } Context采用的是装饰模式，其中正在干活的是ContextImpl，mBase即为ContextImpl，具体代码如下：ContextImpl.java //ContextImpl类中的静态Map声明，全局的一个sSharedPrefs private static ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt; sSharedPrefs; @Override public SharedPreferences getSharedPreferences(String name, int mode) { SharedPreferencesImpl sp; synchronized (ContextImpl.class) { if (sSharedPrefs == null) { //静态变量，全局唯一 sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;(); } final String packageName = getPackageName();//通过包名找到对应的prefs集合 ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName); if (packagePrefs == null) { packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;(); sSharedPrefs.put(packageName, packagePrefs); } // At least one application in the world actually passes in a null // name. This happened to work because when we generated the file name // we would stringify it to &quot;null.xml&quot;. Nice. if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt; Build.VERSION_CODES.KITKAT) { if (name == null) { name = &quot;null&quot;; } } sp = packagePrefs.get(name);//这里获取sp if (sp == null) {//如果为空，则构建一个sp，并将它放入packagePrefs里面 File prefsFile = getSharedPrefsFile(name);//正在获取文件的地方 sp = new SharedPreferencesImpl(prefsFile, mode); packagePrefs.put(name, sp); return sp; } } //下面是为了跨进程使用Sharepreference的，跨进程使用也就是重新装载一次sharepreference if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 || getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) { // If somebody else (some other process) changed the prefs // file behind our back, we reload it. This has been the // historical (if undocumented) behavior. sp.startReloadIfChangedUnexpectedly(); } return sp; } 正在保存的文件获取是getSharedPrefsFile(name)，代码如下： @Override public File getSharedPrefsFile(String name) { //文件以.xml结尾 return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;); } private File makeFilename(File base, String name) { if (name.indexOf(File.separatorChar) &lt; 0) { //name中不能存在文件路径分隔符 return new File(base, name); } throw new IllegalArgumentException( &quot;File &quot; + name + &quot; contains a path separator&quot;); } private File getPreferencesDir() {//sharepreference文件的目录/data/data/{包名}/shared_prefs synchronized (mSync) { if (mPreferencesDir == null) { mPreferencesDir = new File(getDataDirFile(), &quot;shared_prefs&quot;); } return mPreferencesDir; } } 在ContextImpl中存在一个静态的sSharedPrefs，通过它来获取对应应用的prefs，在通过prefs找到对应名称的Sharepreference的引用。在系统中共用一个sSharedPrefs，每个应该在获取sp的时候都会将创建后sp加入到sSharedPrefs中以便后续进行访问。 2.2 SharepreferenceImpl从上面我们可以看到我们要获取的是Sharepreference，但是返回的是SharepreferenceImpl，这就赤裸裸的告诉我们SharepreferenceImpl是Sharepreference接口的实现类，具体代码如下： final class SharedPreferencesImpl implements SharedPreferences { private static final String TAG = &quot;SharedPreferencesImpl&quot;; private static final boolean DEBUG = false; // Lock ordering rules: // - acquire SharedPreferencesImpl.this before EditorImpl.this // - acquire mWritingToDiskLock before EditorImpl.this private final File mFile; private final File mBackupFile; private final int mMode; private Map&lt;String, Object&gt; mMap; // guarded by &#39;this&#39; private int mDiskWritesInFlight = 0; // guarded by &#39;this&#39; private boolean mLoaded = false; // guarded by &#39;this&#39; private long mStatTimestamp; // guarded by &#39;this&#39; private long mStatSize; // guarded by &#39;this&#39; private final Object mWritingToDiskLock = new Object(); private static final Object mContent = new Object(); private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt; mListeners = new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;(); SharedPreferencesImpl(File file, int mode) { mFile = file; mBackupFile = makeBackupFile(file); //创建临时备份文件，这样写入失败的时候就用这个备份的还原 mMode = mode; mLoaded = false; mMap = null; startLoadFromDisk();//异步加载文件内容到内存 } private void startLoadFromDisk() { synchronized (this) { mLoaded = false; } new Thread(&quot;SharedPreferencesImpl-load&quot;) { public void run() { //由于是多线程加载的时候注意同步处理 synchronized (SharedPreferencesImpl.this) { loadFromDiskLocked(); } } }.start(); } ... private static File makeBackupFile(File prefsFile) { return new File(prefsFile.getPath() + &quot;.bak&quot;); } ... } 在获取sp的时候，如果通过sSharedPrefs获取为空就会先创建一个sp，在new SharepreferenceImpl的时候，在构造函数中最后就会异步加载文件到内存，异步开启一个线程后就调用loadFromDiskLocked()函数进行加载：SharepreferenceImpl.java private void loadFromDiskLocked() { if (mLoaded) {//加载过了就返回 return; } if (mBackupFile.exists()) {//如果存在备份就直接使用备份 mFile.delete(); mBackupFile.renameTo(mFile); } // Debugging if (mFile.exists() &amp;&amp; !mFile.canRead()) { Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;); } Map map = null; StructStat stat = null; try { stat = Os.stat(mFile.getPath()); if (mFile.canRead()) { BufferedInputStream str = null; try { str = new BufferedInputStream( new FileInputStream(mFile), 16*1024); map = XmlUtils.readMapXml(str);//利用XmlUtils进行解析 } catch (XmlPullParserException e) { Log.w(TAG, &quot;getSharedPreferences&quot;, e); } catch (FileNotFoundException e) { Log.w(TAG, &quot;getSharedPreferences&quot;, e); } catch (IOException e) { Log.w(TAG, &quot;getSharedPreferences&quot;, e); } finally { IoUtils.closeQuietly(str); } } } catch (ErrnoException e) { } mLoaded = true; if (map != null) { mMap = map; mStatTimestamp = stat.st_mtime; mStatSize = stat.st_size; } else { mMap = new HashMap&lt;String, Object&gt;(); } notifyAll();//没加载完前，所有操作（get等）都会等待加载完成，加载完成后通知其他操作可以进行操作了。 } 一旦加载完成后，就会notifyAll()，我们先看下get的操作 public Map&lt;String, ?&gt; getAll() { synchronized (this) { awaitLoadedLocked(); //noinspection unchecked return new HashMap&lt;String, Object&gt;(mMap); } } @Nullable public String getString(String key, @Nullable String defValue) { synchronized (this) { awaitLoadedLocked();//没有加载就阻塞等待 String v = (String)mMap.get(key);//加载完成了就直接去内存中的值，记住是从内存中取。不会再次读取文件总内容。 return v != null ? v : defValue; } } ... private void awaitLoadedLocked() {//这里判断是否已经加载文件到内存了，没有加载就会阻塞等待 if (!mLoaded) { // Raise an explicit StrictMode onReadFromDisk for this // thread, since the real read will be in a different // thread and otherwise ignored by StrictMode. BlockGuard.getThreadPolicy().onReadFromDisk(); } while (!mLoaded) { try { wait(); } catch (InterruptedException unused) { } } } 在get数据时，首先判断文件是否加载到内存，然后就直接读取内存中的值，这里可以看出一旦装载了，那么读取的速度就很快。 2.3 EditorImpl上面SharepreferenceImpl是实现了get操作，真正的写入是Editor接口来完成的，而EditorImpl是具体的实现类。其代码如下： public final class EditorImpl implements Editor { private final Map&lt;String, Object&gt; mModified = Maps.newHashMap(); private boolean mClear = false; //从这里可以看出每次存的时候都是先存入内存中的mModified变量中 public Editor putString(String key, @Nullable String value) { synchronized (this) { mModified.put(key, value); return this; } } public Editor putStringSet(String key, @Nullable Set&lt;String&gt; values) { synchronized (this) { mModified.put(key, (values == null) ? null : new HashSet&lt;String&gt;(values)); return this; } } public Editor putInt(String key, int value) { synchronized (this) { mModified.put(key, value); return this; } } ... public Editor remove(String key) { synchronized (this) { mModified.put(key, this); return this; } } public Editor clear() { synchronized (this) { mClear = true; return this; } } public void apply() { final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() { public void run() { try { mcr.writtenToDiskLatch.await(); } catch (InterruptedException ignored) { } } }; QueuedWork.add(awaitCommit); Runnable postWriteRunnable = new Runnable() { public void run() { awaitCommit.run(); QueuedWork.remove(awaitCommit); } }; SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // Okay to notify the listeners before it&#39;s hit disk // because the listeners should always get the same // SharedPreferences instance back, which has the // changes reflected in memory. notifyListeners(mcr); } } 首先查看下存入的代码： //从这里可以看出每次存的时候都是先存入内存中的mModified变量中 public Editor putString(String key, @Nullable String value) { synchronized (this) { mModified.put(key, value); return this; } } 存入的时候首先获取同步锁，然后将存入的数据放入EditorImpl中的一个mModified变量中，也就是存入的时候并没有放入Sharepreference中，只有在使用了apply或者commit后才真正存入。下面来看看commit操作： public boolean commit() { MemoryCommitResult mcr = commitToMemory();//步骤1 SharedPreferencesImpl.this.enqueueDiskWrite( mcr, null /* sync write on this thread okay */);//步骤2 try { mcr.writtenToDiskLatch.await();//等待写入完成 } catch (InterruptedException e) { return false; } notifyListeners(mcr);//步骤3 return mcr.writeToDiskResult;步骤4 } 步骤1： // Returns true if any changes were made 真正存入文件中 private MemoryCommitResult commitToMemory() { MemoryCommitResult mcr = new MemoryCommitResult(); synchronized (SharedPreferencesImpl.this) { // We optimistically don&#39;t make a deep copy until // a memory commit comes in when we&#39;re already // writing to disk. if (mDiskWritesInFlight &gt; 0) { // We can&#39;t modify our mMap as a currently // in-flight write owns it. Clone it before // modifying it. // noinspection unchecked mMap = new HashMap&lt;String, Object&gt;(mMap); } mcr.mapToWriteToDisk = mMap; mDiskWritesInFlight++; boolean hasListeners = mListeners.size() &gt; 0; if (hasListeners) { mcr.keysModified = new ArrayList&lt;String&gt;(); mcr.listeners = new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet()); } synchronized (this) { if (mClear) { if (!mMap.isEmpty()) { mcr.changesMade = true; mMap.clear(); } mClear = false; } for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) { String k = e.getKey(); Object v = e.getValue(); // &quot;this&quot; is the magic value for a removal mutation. In addition, // setting a value to &quot;null&quot; for a given key is specified to be // equivalent to calling remove on that key. //删除一些需要删除的数据 if (v == this || v == null) { if (!mMap.containsKey(k)) { continue; } mMap.remove(k); } else { if (mMap.containsKey(k)) { Object existingValue = mMap.get(k); if (existingValue != null &amp;&amp; existingValue.equals(v)) { continue; } } //将变化的数据放入SharepreferenceImpl的mMap中 mMap.put(k, v); } mcr.changesMade = true; if (hasListeners) { mcr.keysModified.add(k); } } //变化的数据都加入了mMap后就可以清除mModified内容了。 mModified.clear(); } } //返回封装mMap的MemoryCommitResult数据 return mcr; } 步骤2： private void enqueueDiskWrite(final MemoryCommitResult mcr, final Runnable postWriteRunnable) { final Runnable writeToDiskRunnable = new Runnable() { public void run() { synchronized (mWritingToDiskLock) { writeToFile(mcr); } synchronized (SharedPreferencesImpl.this) { mDiskWritesInFlight--; } if (postWriteRunnable != null) { postWriteRunnable.run(); } } }; final boolean isFromSyncCommit = (postWriteRunnable == null);//如果postWriteRunnable为null就是同步 // Typical #commit() path with fewer allocations, doing a write on // the current thread. if (isFromSyncCommit) {//同步就直接运行写入数据writeToDiskRunnable boolean wasEmpty = false; synchronized (SharedPreferencesImpl.this) { wasEmpty = mDiskWritesInFlight == 1; } if (wasEmpty) { writeToDiskRunnable.run(); return; } } QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable); } // 写入数据 private void writeToFile(MemoryCommitResult mcr) { // Rename the current file so it may be used as a backup during the next read if (mFile.exists()) { if (!mcr.changesMade) { // If the file already exists, but no changes were // made to the underlying map, it&#39;s wasteful to // re-write the file. Return as if we wrote it // out. mcr.setDiskWriteResult(true); return; } if (!mBackupFile.exists()) { if (!mFile.renameTo(mBackupFile)) { Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile + &quot; to backup file &quot; + mBackupFile); mcr.setDiskWriteResult(false); return; } } else { mFile.delete(); } } // Attempt to write the file, delete the backup and return true as atomically as // possible. If any exception occurs, delete the new file; next time we will restore // from the backup. try { FileOutputStream str = createFileOutputStream(mFile); if (str == null) { mcr.setDiskWriteResult(false); return; } XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str); FileUtils.sync(str); str.close(); ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0); try { final StructStat stat = Os.stat(mFile.getPath()); synchronized (this) { mStatTimestamp = stat.st_mtime; mStatSize = stat.st_size; } } catch (ErrnoException e) { // Do nothing } // Writing was successful, delete the backup file if there is one. mBackupFile.delete(); mcr.setDiskWriteResult(true); return; } catch (XmlPullParserException e) { Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e); } catch (IOException e) { Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e); } // Clean up an unsuccessfully written file if (mFile.exists()) { if (!mFile.delete()) { Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile); } } mcr.setDiskWriteResult(false); } 步骤3通知写入数据发生变化 private void notifyListeners(final MemoryCommitResult mcr) { if (mcr.listeners == null || mcr.keysModified == null || mcr.keysModified.size() == 0) { return; } if (Looper.myLooper() == Looper.getMainLooper()) { for (int i = mcr.keysModified.size() - 1; i &gt;= 0; i--) { final String key = mcr.keysModified.get(i); for (OnSharedPreferenceChangeListener listener : mcr.listeners) { if (listener != null) { listener.onSharedPreferenceChanged(SharedPreferencesImpl.this, key); } } } } else { // Run this function on the main thread. ActivityThread.sMainThreadHandler.post(new Runnable() { public void run() { notifyListeners(mcr); } }); } } 步骤4返回写入的结果。 2.3.2 Editor.apply()代码如下： public void apply() { //写数据到内存，返回数据结构 final MemoryCommitResult mcr = commitToMemory(); final Runnable awaitCommit = new Runnable() { public void run() { try { //等待写文件结束 mcr.writtenToDiskLatch.await(); } catch (InterruptedException ignored) { } } }; QueuedWork.add(awaitCommit); //一个收尾的Runnable Runnable postWriteRunnable = new Runnable() { public void run() { awaitCommit.run(); QueuedWork.remove(awaitCommit); } }; //这里postWriteRunnable不为null，所以会在一个新的线程池调运postWriteRunnable的run方法 SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable); // Okay to notify the listeners before it&#39;s hit disk // because the listeners should always get the same // SharedPreferences instance back, which has the // changes reflected in memory. //通知变化 notifyListeners(mcr); } apply会将写入放入到一个线程池中操作，这不会阻塞调用的线程。其他的都和commit类似。QueuedWork.java public class QueuedWork { private static final ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers = new ConcurrentLinkedQueue&lt;Runnable&gt;(); public static void add(Runnable finisher) { sPendingWorkFinishers.add(finisher); } public static void remove(Runnable finisher) { sPendingWorkFinishers.remove(finisher); } public static void waitToFinish() { Runnable toFinish; while ((toFinish = sPendingWorkFinishers.poll()) != null) { toFinish.run(); } } public static boolean hasPendingWork() { return !sPendingWorkFinishers.isEmpty(); } } 总结apply 与commit的对比 apply没有返回值, commit有返回值能知道修改是否提交成功apply是将修改提交到内存，再异步提交到磁盘文件; commit是同步的提交到磁盘文件;多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。获取SP与Editor: getSharedPreferences()是从ContextImpl.sSharedPrefsCache唯一的SPI对象;edit()每次都是创建新的EditorImpl对象.优化建议: 强烈建议不要在sp里面存储特别大的key/value, 有助于减少卡顿/anr请不要高频地使用apply, 尽可能地批量提交;commit直接在主线程操作, 更要注意了不要使用MODE_MULTI_PROCESS;高频写操作的key与高频读操作的key可以适当地拆分文件, 由于减少同步锁竞争;不要一上来就执行getSharedPreferences().edit(), 应该分成两大步骤来做, 中间可以执行其他代码.不要连续多次edit(), 应该获取一次获取edit(),然后多次执行putxxx(), 减少内存波动; 经常看到大家喜欢封装方法, 结果就导致这种情况的出现.每次commit时会把全部的数据更新的文件, 所以整个文件是不应该过大的, 影响整体性能; 参考Gityuan博客工匠若水","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"SharedPreferences Editor","slug":"SharedPreferences-Editor","permalink":"http://yoursite.com/tags/SharedPreferences-Editor/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"adb常用命令","slug":"adb常用命令","date":"2018-01-17T02:15:31.000Z","updated":"2018-01-17T15:06:13.000Z","comments":true,"path":"2018/01/17/adb常用命令/","link":"","permalink":"http://yoursite.com/2018/01/17/adb常用命令/","excerpt":"","text":"adb简介adb全称Android Debug Bridge，意为安卓调试桥接，即常用于Android手机调试的工具。adb提供了一系列命令可以操作手机，比如安装卸载软件，运行shell命令等等。adb工作方式是采用监听Socket TCP5554等端口的方式让IDE和Qemu通讯。 常用的adb命令 取得当前连接电脑的设备的状态adb devices 安装卸载软件adb install &lt;-r&gt; 文件.apk //-r表示替换掉原来的apk adb uninstall &lt;-k&gt; {package} //packageName表示应用包名 -k表示保留配置和缓存 获取设备的序列号adb get-serialno //获取设备序列号 访问手机SQLit数据库（手机内部需有sqilte3命令支持）adb shell sqlite3 {数据库文件名} 从电脑上发送文件到手机端adb push {文件路径} {手机端路径} //文件表示要发送文件的全路径（当前路径下只需写上文件名 {手机端路径}表示拷贝到手机上的路径，/sdcard/表示sd卡根路径 从手机端拉取文件到电脑端adb pull {手机端路径} {保存到电脑端路径} 查看bug报告adb bugreport //Android7.0及以后支持该功能 获取手机中的第三方包名adb shell pm list packages -3 查看当前正在交互的程序adb shell dumpsys activity | grep &quot;Running activities&quot; -A 7 获取包名所在路径adb shell pm path {package} Monkey命令全模块：adb shell &quot;monkey --ignore-crashes --ignore-timeouts --throttle 500 --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes 10000 &gt; sdcard/monkey.txt&quot; 单模块adb shell monkey -p com.android.contacts --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes --throttle 500 -v 10000 &gt; sdcard/monkey.txt&quot; 强行停止monkeyadb shell ps | grep monkey kill monkey对应的pid 列出所有可以dump的选项adb shell dumpsys -l 查看内存信息adb shell dumpsys meminfo 列出dumpsys能提供的所有服务列表adb shell dumpsys service list //得到该列表后，就可以在dumpsys后面加上service的名称来查看指定service的信息了 查看ActvityManagerService 所有信息adb shell dumpsys activity 查看Activity组件信息adb shell dumpsys activity activities 查看Service组件信息adb shell dumpsys activity services 产看ContentProvider组件信息adb shell dumpsys activity providers 查看BraodcastReceiver信息adb shell dumpsys activity broadcasts 查看Intent信息adb shell dumpsys activity intents 查看进程信息adb shell dumpsys activity processes 关闭或开启adb服务adb kill-server adb start-server 显示或导出log信息adb logcat &lt;-s&gt; //在命令行显示log信息 -s表示指定标签tag adb logcat &gt; log.txt //将log信息保存到当前目录的log.txt文件中 启动Activitiesadb shell am start -n {包名}/{包名＋类名}（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等） 设置系统属性信息adb shell setprop {key} {value} 常用的adb shell命令ps //列出所有进程 ls //列出当前目录下文件 df //检查文件系统的磁盘空间占用情况 cat //查看某个文件 kill {pid}//杀死某个进程 cd //进入其他目录 rm //删除 rmdir //删除非空文件夹（有文件的文件夹可能不成功） 显示WiFi信息adb shell dumpsys wifi 模拟用户点击adb shell input tap {x} {x} //例子：adb shell input tap 50 250 模拟用户滑动adb shell input swipe {start.x} {start.y} {end.x} {end.y} {time} //例子：adb shell input swipe 50 250 250 250 500 //划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒） 模拟输入字符串adb shell input text &#39;abc&#39; 模拟点击手机自带的功能键：Home，Menu，Backadb shell input keyevent keyCode keyCode对应表： KEYCODE_UNKNOWN=0; KEYCODE_SOFT_LEFT=1; KEYCODE_SOFT_RIGHT=2; KEYCODE_HOME=3; KEYCODE_BACK=4; KEYCODE_CALL=5; KEYCODE_ENDCALL=6; KEYCODE_0=7; KEYCODE_1=8; KEYCODE_2=9; KEYCODE_4=11; KEYCODE_5=12; KEYCODE_6=13; KEYCODE_7=14; KEYCODE_8=15; KEYCODE_9=16; KEYCODE_STAR=17; KEYCODE_POUND=18; KEYCODE_DPAD_UP=19; KEYCODE_DPAD_DOWN=20; KEYCODE_DPAD_LEFT=21; KEYCODE_DPAD_RIGHT=22; KEYCODE_DPAD_CENTER=23; KEYCODE_VOLUME_UP=24; KEYCODE_VOLUME_DOWN=25; KEYCODE_POWER=26; KEYCODE_CAMERA=27; KEYCODE_CLEAR=28; KEYCODE_A=29; KEYCODE_B=30; KEYCODE_C=31; KEYCODE_D=32; KEYCODE_E=33; KEYCODE_F=34; KEYCODE_G=35; KEYCODE_H=36; KEYCODE_I=37; KEYCODE_J=38; KEYCODE_K=39; KEYCODE_L=40; KEYCODE_M=41; KEYCODE_N=42; KEYCODE_O=43; KEYCODE_P=44; KEYCODE_Q=45; KEYCODE_R=46; KEYCODE_S=47; KEYCODE_T=48; KEYCODE_U=49; KEYCODE_V=50; KEYCODE_W=51; KEYCODE_X=52; KEYCODE_Y=53; KEYCODE_Z=54; KEYCODE_COMMA=55; KEYCODE_PERIOD=56; KEYCODE_ALT_LEFT=57; KEYCODE_ALT_RIGHT=58; KEYCODE_SHIFT_LEFT=59; KEYCODE_SHIFT_RIGHT=60; KEYCODE_TAB=61; KEYCODE_SPACE=62; KEYCODE_SYM=63; KEYCODE_EXPLORER=64; KEYCODE_ENVELOPE=65; KEYCODE_ENTER=66; KEYCODE_DEL=67; KEYCODE_GRAVE=68; KEYCODE_MINUS=69; KEYCODE_EQUALS=70; KEYCODE_LEFT_BRACKET=71; KEYCODE_RIGHT_BRACKET=72; KEYCODE_BACKSLASH=73; KEYCODE_SEMICOLON=74; KEYCODE_APOSTROPHE=75; KEYCODE_SLASH=76; KEYCODE_AT=77; KEYCODE_NUM=78; KEYCODE_HEADSETHOOK=79; KEYCODE_FOCUS=80;//*Camera*focus KEYCODE_PLUS=81; KEYCODE_MENU=82; KEYCODE_NOTIFICATION=83; KEYCODE_SEARCH=84; KEYCODE_MEDIA_PLAY_PAUSE=85; KEYCODE_MEDIA_STOP=86; KEYCODE_MEDIA_NEXT=87; KEYCODE_MEDIA_PREVIOUS=88; KEYCODE_MEDIA_REWIND=89; KEYCODE_MEDIA_FAST_FORWARD=90; KEYCODE_MUTE=91;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"adb命令","slug":"adb命令","permalink":"http://yoursite.com/tags/adb命令/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"onAttachedToWindow和onDetachedFromWindow调用时机源码解析","slug":"onAttachedToWindow和onDetachedFromWindow调用时机源码解析","date":"2018-01-09T14:56:44.000Z","updated":"2018-01-09T15:06:58.000Z","comments":true,"path":"2018/01/09/onAttachedToWindow和onDetachedFromWindow调用时机源码解析/","link":"","permalink":"http://yoursite.com/2018/01/09/onAttachedToWindow和onDetachedFromWindow调用时机源码解析/","excerpt":"","text":"1.示例先上测试代码：MyView.java public class MyView extends TextView { public MyView(Context context) { super(context); } public MyView(Context context, AttributeSet attrs) { super(context, attrs); Log.e(&quot;test&quot;,&quot;view constructor&quot;); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); Log.e(&quot;test&quot;, &quot;onAttachedToWindow&quot;); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); Log.e(&quot;test&quot;, &quot;onDetachedFromWindow&quot;); } } MainActivity.java public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.e(&quot;test&quot;, &quot;before setContextView&quot;); setContentView(R.layout.activity_main); Log.e(&quot;test&quot;, &quot;after setContextView&quot;); } @Override protected void onResume() { super.onResume(); Log.e(&quot;test&quot;, &quot;onResume&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.e(&quot;test&quot;, &quot;onDestroy&quot;); } } 运行后输出的Log如下： 点击返回键退出后，输出的Log如下： 根据Log的onAttachedToWindow和onDetachedFromWindow的输出情况一目了然。 2.源码分析下面通过源码分析下，他两的调用时机到底在哪。 首先看下onAttachedToWindow的调用时机，在Android源码中onResume调用前会先调用了ActivityThread中的handleResumeActivity，下面是相应的代码： ActivityThread.java final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) { final Activity a = r.activity; if (localLOGV) Slog.v( TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn&#39;t yet been added to the window manager, // and this guy didn&#39;t finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { } } if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l);//这里调用了ViewManager中的addView方法。 } // If the window has already been added, but during resume // we started another activity, then don&#39;t yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } .... } 看代码中的wm.addView(devor,l);通过该方法将View添加到Window当中（在当前Window也就是Activity，不过Window也可以是Dialog或Toast），而wm是ViewManager类型的，查看对应代码是： /** Interface to let you add and remove child views to an Activity. To get an instance * of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}. */ public interface ViewManager { /** * Assign the passed LayoutParams to the passed View and add the view to the window. * &lt;p&gt;Throws {@link android.view.WindowManager.BadTokenException} for certain programming * errors, such as adding a second view to a window without removing the first view. * &lt;p&gt;Throws {@link android.view.WindowManager.InvalidDisplayException} if the window is on a * secondary {@link Display} and the specified display can&#39;t be found * (see {@link android.app.Presentation}). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view); } 该类是一个接口，在他下面还有一个WindowManager继承于ViewManager，而真正的实现代码在WindowManagerImpl类中，代码如下：WindowManagerImpl.java /* * @see WindowManager * @see WindowManagerGlobal * @hide */ ublic final class WindowManagerImpl implements WindowManager { private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Display mDisplay; private final Window mParentWindow; private IBinder mDefaultToken; public WindowManagerImpl(Display display) { this(display, null); } private WindowManagerImpl(Display display, Window parentWindow) { mDisplay = display; mParentWindow = parentWindow; } public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mDisplay, parentWindow); } public WindowManagerImpl createPresentationWindowManager(Display display) { return new WindowManagerImpl(display, mParentWindow); } /** * Sets the window token to assign when none is specified by the client or * available from the parent window. * * @param token The default token to assign. */ public void setDefaultToken(IBinder token) { mDefaultToken = token; } @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow); } @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.updateViewLayout(view, params); } private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) { // Only use the default token if we don&#39;t have a parent window. if (mDefaultToken != null &amp;&amp; mParentWindow == null) { if (!(params instanceof WindowManager.LayoutParams)) { throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); } // Only use the default token if we don&#39;t already have a token. final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (wparams.token == null) { wparams.token = mDefaultToken; } } } @Override public void removeView(View view) { mGlobal.removeView(view, false); } @Override public void removeViewImmediate(View view) { mGlobal.removeView(view, true); } @Override public Display getDefaultDisplay() { return mDisplay; } 从中可以看到addView又调用了 WindowManagerGlobal.java类中的addView，下面看看WindowManagerGlobal.java类的源码：WindowManagerGlobal.java public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } if (display == null) { throw new IllegalArgumentException(&quot;display must not be null&quot;); } if (!(params instanceof WindowManager.LayoutParams)) { throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); } final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) { parentWindow.adjustLayoutParamsForSubWindow(wparams); } else { // If there&#39;s no parent, then hardware acceleration for this view is // set from the application&#39;s hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) { wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; } } ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // Start watching for system property changes. if (mSystemPropertyUpdater == null) { mSystemPropertyUpdater = new Runnable() { @Override public void run() { synchronized (mLock) { for (int i = mRoots.size() - 1; i &gt;= 0; --i) { mRoots.get(i).loadSystemProperties(); } } } }; SystemProperties.addChangeCallback(mSystemPropertyUpdater); } int index = findViewLocked(view, false); if (index &gt;= 0) { if (mDyingViews.contains(view)) { // Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue. mRoots.get(index).doDie(); } else { throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); } // The previous removeView() had not completed executing. Now it has. } // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) { final int count = mViews.size(); for (int i = 0; i &lt; count; i++) { if (mRoots.get(i).mWindow.asBinder() == wparams.token) { panelParentView = mViews.get(i); } } } root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView);//这里调用ViewRootImpl类中的setView方法，在该方法中触发了&lt;span style=&quot;color: rgb(101, 123, 131); font-family: Menlo, Monaco, Consolas, &#39;Courier New&#39;, monospace; line-height: 20.4px; white-space: pre-wrap; background-color: rgb(246, 246, 246);&quot;&gt;ViewRootImpl.performTraversals()&lt;/span&gt; } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) { final int index = findViewLocked(view, false); if (index &gt;= 0) { removeViewLocked(index, true); } } throw e; } } 在该方法中的root.setView(view,wparams,panelParentView)方法，调用的是ViewRootImpl类中的setView方法，正是该setView方法触发了ViewRootImpl.performTraversals()方法，也就是View绘制的起点，之后会进行measure,layout,draw三个步骤从而完成一个View的显示工作。 ViewRootImpl.java /** * We have one child */ public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized (this) { if (mView == null) { mView = view; mAttachInfo.mDisplayState = mDisplay.getState(); mDisplayManager.registerDisplayListener(mDisplayListener, mHandler); ... mSoftInputMode = attrs.softInputMode; mWindowAttributesChanged = true; mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED; mAttachInfo.mRootView = view; mAttachInfo.mScalingRequired = mTranslator != null; mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale; if (panelParentView != null) { mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken(); } mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. requestLayout();//这里开始请求view的绘制 if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) { mInputChannel = new InputChannel(); } try { mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); } catch (RemoteException e) { mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(&quot;Adding window failed&quot;, e); } finally { if (restore) { attrs.restore(); } } .... } } } 在setView的requestLayout方法中开始View的绘制。ViewRootImpl.java void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing(&quot;ViewAncestor&quot;); } performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } 在scheduleTraversals()方法中向mChoreographer中postCallback，而具体的Runable内容在TraversalRunnable类中，该类在run函数中直接执行doTraversal()方法，可以看到在该方法中最终调用了performTraversals()开启View的绘制工作。查看ViewRootImpl.java中的performTraversals()的源码如下： ViewRootImpl.java中的performTraversals()方法 private void performTraversals() { // cache mView since it is used so much below... final View host = mView; ... if (host == null || !mAdded) return; mIsInTraversal = true; mWillDrawSoon = true; boolean windowSizeMayChange = false; boolean newSurface = false; boolean surfaceChanged = false; WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; final int viewVisibility = getHostVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility || mNewSurfaceNeeded; WindowManager.LayoutParams params = null; if (mWindowAttributesChanged) { mWindowAttributesChanged = false; surfaceChanged = true; params = lp; } CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo(); if (compatibilityInfo.supportsScreen() == mLastInCompatMode) { params = lp; mFullRedrawNeeded = true; mLayoutRequested = true; if (mLastInCompatMode) { params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW; mLastInCompatMode = false; } else { params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW; mLastInCompatMode = true; } } mWindowAttributesChangesFlag = 0; Rect frame = mWinFrame; if (mFirst) { mFullRedrawNeeded = true; mLayoutRequested = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) { // NOTE -- system code, won&#39;t try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; } else { DisplayMetrics packageMetrics = mView.getContext().getResources().getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; } // We used to use the following condition to choose 32 bits drawing caches: // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888 // However, windows are now always 32 bits by default, so choose 32 bits mAttachInfo.mUse32BitDrawingCache = true; mAttachInfo.mHasWindowFocus = false; mAttachInfo.mWindowVisibility = viewVisibility; mAttachInfo.mRecomputeGlobalAttributes = false; viewVisibilityChanged = false; mLastConfiguration.setTo(host.getResources().getConfiguration()); mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility; // Set the layout direction if it has not been set before (inherit is the default) if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) { host.setLayoutDirection(mLastConfiguration.getLayoutDirection()); } host.dispatchAttachedToWindow(mAttachInfo, 0);//这里调用了View的dispatchAttachedToWindow，也就是这里回调了onAttachedToWindow方法。 mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); //Log.i(TAG, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn); } else { desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) { if (DEBUG_ORIENTATION) Log.v(TAG, &quot;View &quot; + host + &quot; resized to: &quot; + frame); mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; } } ... } 在该方法中调用了host.dispatchAttachedToWindow(mAttachInfo, 0);方法。host是上面传下来的DecodView，该类继承与FrameLayout类，也就是ViewGroup的子类，所以先调用的是ViewGroup中的dispatchAttachedToWindow，其代码如下： ViewGroup.java @Override void dispatchAttachedToWindow(AttachInfo info, int visibility) { mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; super.dispatchAttachedToWindow(info, visibility);//这里先调用父类，也就是View的dispathcAttachedToWindow。 mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) { final View child = children[i]; child.dispatchAttachedToWindow(info, combineVisibility(visibility, child.getVisibility()));//这里调用子View的&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;dispatchAttachedToWindow&lt;/span&gt; } final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); for (int i = 0; i &lt; transientCount; ++i) { View view = mTransientViews.get(i); view.dispatchAttachedToWindow(info, combineVisibility(visibility, view.getVisibility())); } } 下面查看对应的View类中的dispatchAttacToWindow。代码如下： View.java void dispatchAttachedToWindow(AttachInfo info, int visibility) { //System.out.println(&quot;Attached! &quot; + this); mAttachInfo = info; if (mOverlay != null) { mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility); } mWindowAttachCount++; // We will need to evaluate the drawable state at least once. mPrivateFlags |= PFLAG_DRAWABLE_STATE_DIRTY; if (mFloatingTreeObserver != null) { info.mTreeObserver.merge(mFloatingTreeObserver); mFloatingTreeObserver = null; } if ((mPrivateFlags&amp;PFLAG_SCROLL_CONTAINER) != 0) { mAttachInfo.mScrollContainers.add(this); mPrivateFlags |= PFLAG_SCROLL_CONTAINER_ADDED; } performCollectViewAttributes(mAttachInfo, visibility); onAttachedToWindow();//快看，快看，在这里！终于找到这个方法调用的位置了 ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) { // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) { listener.onViewAttachedToWindow(this);// } } int vis = info.mWindowVisibility; if (vis != GONE) { onWindowVisibilityChanged(vis); } // Send onVisibilityChanged directly instead of dispatchVisibilityChanged. // As all views in the subtree will already receive dispatchAttachedToWindow // traversing the subtree again here is not desired. onVisibilityChanged(this, visibility); if ((mPrivateFlags&amp;PFLAG_DRAWABLE_STATE_DIRTY) != 0) { // If nobody has evaluated the drawable state yet, then do it now. refreshDrawableState(); } needGlobalAttributesUpdate(false); } 从上面代码可以看出一个布局的onAttachedToWindow会先调用自己的，然后再调用自己孩子的。而且从View.java的代码中也可以看出onAttachedToWindow和View自身的visibility无关，即使visibility==GONE，该方法也会调用。好，下面来分析下onDetachedFromWindow方法的调用时机。在onDestory调用前会调用ActivityThread.java中的handleDestroyActivity方法，贴出代码： ActivityThread.java private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance); if (r != null) { cleanUpPendingRemoveWindows(r); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) { if (r.activity.mVisibleFromServer) { mNumVisibleActivities--; } IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) { if (r.onlyLocalRequest) { // Hold off on removing this until the new activity&#39;s // window is being added. r.mPendingRemoveWindow = v; r.mPendingRemoveWindowManager = wm; } else { wm.removeViewImmediate(v);//看这里，看这里 } } if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) { WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), &quot;Activity&quot;); } r.activity.mDecor = null; } if (r.mPendingRemoveWindow == null) { // If we are delaying the removal of the activity window, then // we can&#39;t clean up all windows here. Note that we can&#39;t do // so later either, which means any windows that aren&#39;t closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), &quot;Activity&quot;); } // Mocked out contexts won&#39;t be participating in the normal // process lifecycle, but if we&#39;re running with a proper // ApplicationContext we need to have it tear down things // cleanly. Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) { ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), &quot;Activity&quot;); } } if (finishing) { try { ActivityManagerNative.getDefault().activityDestroyed(token); } catch (RemoteException ex) { // If the system process has died, it&#39;s game over for everyone. } } mSomeActivitiesChanged = true; } 看代码中的wm.removeViewImmediate方法，还是走到WindowManagerImpl类中的removeViewImmediate，代码如下：WindowManagerImpl.java @Override public void removeViewImmediate(View view) { mGlobal.removeView(view, true); } 好熟悉啊，还是走到了WindowManagerGlobal类中的removeView，代码如下：WindowManagerGlobal.java public void removeView(View view, boolean immediate) { if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) { return; } throw new IllegalStateException(&quot;Calling with view &quot; + view + &quot; but the ViewAncestor is attached to &quot; + curView); } } private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } 跟着代码继续走，到了ViewRootImpl类中的die，代码如下：ViewRootImpl.java /** * @param immediate True, do now if not in traversal. False, put on queue and do later. * @return True, request has been queued. False, request has been completed. */ boolean die(boolean immediate) { // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) { doDie(); return false; } if (!mIsDrawing) { destroyHardwareRenderer(); } else { Log.e(TAG, &quot;Attempting to destroy the window while drawing!\\n&quot; + &quot; window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle()); } mHandler.sendEmptyMessage(MSG_DIE); return true; } void doDie() { checkThread(); if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface); synchronized (this) { if (mRemoved) { return; } mRemoved = true; if (mAdded) { dispatchDetachedFromWindow();//看这里，看这里 } if (mAdded &amp;&amp; !mFirst) { destroyHardwareRenderer(); if (mView != null) { int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) { // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try { if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) { mWindowSession.finishDrawing(mWindow); } } catch (RemoteException e) { } } mSurface.release(); } } mAdded = false; } WindowManagerGlobal.getInstance().doRemoveView(this); } 在doDie里面调用了dispatchDetachedFromWindow()方法，代码如下：ViewRootImpl.java void dispatchDetachedFromWindow() { if (mView != null &amp;&amp; mView.mAttachInfo != null) { mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false); mView.dispatchDetachedFromWindow();//看这里，看这里 } mAccessibilityInteractionConnectionManager.ensureNoConnection(); mAccessibilityManager.removeAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mAccessibilityManager.removeHighTextContrastStateChangeListener( mHighContrastTextManager); removeSendWindowContentChangedCallback(); destroyHardwareRenderer(); setAccessibilityFocus(null, null); mView.assignParent(null); mView = null; mAttachInfo.mRootView = null; mSurface.release(); if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) { mInputQueueCallback.onInputQueueDestroyed(mInputQueue); mInputQueue.dispose(); mInputQueueCallback = null; mInputQueue = null; } if (mInputEventReceiver != null) { mInputEventReceiver.dispose(); mInputEventReceiver = null; } try { mWindowSession.remove(mWindow); } catch (RemoteException e) { } // Dispose the input channel after removing the window so the Window Manager // doesn&#39;t interpret the input channel being closed as an abnormal termination. if (mInputChannel != null) { mInputChannel.dispose(); mInputChannel = null; } mDisplayManager.unregisterDisplayListener(mDisplayListener); unscheduleTraversals(); } 还记着在WindowManagerGlobal里面的root.setView(view, wparams, panelParentView);调用吧，这里的mView.dispatchDetachedFromWindow();这个mView也即是上面传过来的view。也就是先看DecorView即ViewGroup里面的dispatchDetachedFromWindow，代码如下：ViewGroup.java @Override void dispatchDetachedFromWindow() { // If we still have a touch target, we are still in the process of // dispatching motion events to a child; we need to get rid of that // child to avoid dispatching events to it after the window is torn // down. To make sure we keep the child in a consistent state, we // first send it an ACTION_CANCEL motion event. cancelAndClearTouchTargets(null); // Similarly, set ACTION_EXIT to all hover targets and clear them. exitHoverTargets(); // In case view is detached while transition is running mLayoutCalledWhileSuppressed = false; // Tear down our drag tracking mDragNotifiedChildren = null; if (mCurrentDrag != null) { mCurrentDrag.recycle(); mCurrentDrag = null; } final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i &lt; count; i++) { children[i].dispatchDetachedFromWindow();//这里会先调子类的dispatchDetachedFromWindow } clearDisappearingChildren(); final int transientCount = mTransientViews == null ? 0 : mTransientIndices.size(); for (int i = 0; i &lt; transientCount; ++i) { View view = mTransientViews.get(i); view.dispatchDetachedFromWindow(); } super.dispatchDetachedFromWindow();//然后这里才调用自己的。 } 这之后又到View的dispatchDetachedFromWindow了，代码如下：View.java void dispatchDetachedFromWindow() { AttachInfo info = mAttachInfo; if (info != null) { int vis = info.mWindowVisibility; if (vis != GONE) { onWindowVisibilityChanged(GONE); } } onDetachedFromWindow();//绕了一大圈，还是找到你了。快看快看，揪出来了。 onDetachedFromWindowInternal(); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) { imm.onViewDetachedFromWindow(this); } ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) { // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) { listener.onViewDetachedFromWindow(this); } } if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) { mAttachInfo.mScrollContainers.remove(this); mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED; } mAttachInfo = null; if (mOverlay != null) { mOverlay.getOverlayView().dispatchDetachedFromWindow(); } } 看代码终于找到了onDetachedFromWindow的调用地方了。这里总结下： 1.onAttachedToWindow调用顺序：ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView-&gt;WindowManagerGlobal.addView-&gt;ViewRootImpl.performTraversals-&gt;ViewGroup.dispatchAttachedToWindow-&gt;View.dispatchAttachedToWindow-&gt;onAttachedToWindow 2.onDetachedFromWindow调用顺序：ActivityThread.handleDestroyActivity-&gt;WindowManagerImpl.removeViewImmediate-&gt;WindowManagerGlobal.removeView-&gt;ViewRootImpl.die-&gt;ViewRootImpl.doDie-&gt;ViewRootImpl.dispatchDetachedFromWindow-&gt;ViewGroup.dispatchDetachedFromWindow-&gt;View.dispatchDetachedFromWindow-&gt;onDetachedToWindow 3.onAttachedToWindow和onDetachedFromWindow的调用与visibility无关。 4.onAttachedToWindow是先调用自己，然后调用儿子View的。onDetachedFromWindow是先调用儿子View的，然后再调用自己的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"onAttachedToWindow和onDetachedFromWindow,源码解析","slug":"onAttachedToWindow和onDetachedFromWindow-源码解析","permalink":"http://yoursite.com/tags/onAttachedToWindow和onDetachedFromWindow-源码解析/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":" 在git命令行下查看git stash里面文件的内容","slug":"在git命令行下查看git-stash里面文件的内容","date":"2018-01-08T12:51:31.000Z","updated":"2018-01-09T14:15:30.000Z","comments":true,"path":"2018/01/08/在git命令行下查看git-stash里面文件的内容/","link":"","permalink":"http://yoursite.com/2018/01/08/在git命令行下查看git-stash里面文件的内容/","excerpt":"","text":"需求在使用git的时候往往会保存一些东西，在保存的时候使用的就是git stash，强大的git使得保存修改和恢复修改变的很容易，但有时候时间久了不记得stash里面的内容是什么了。 原英文地址通过在stackflow里面查找，找到了一个好的方法。其网址是：http://stackoverflow.com/questions/10725729/git-see-whats-in-a-stash-without-applying-stash 方法当利用git stash pop弹出来会有些耗费时间，这时可以使用git stash show来查看stash里面保存的内容。在git bash上可以使用git –help stash来查看git stash命令的用法，当在stash后加show时，官方给出的介绍如下： show stash Show the changes recorded in the stash as a diff between the stashed state and its original parent. When no is given, shows the latest one. By default, the command shows the diffstat, but it will accept any format known to git diff(e.g., git stash show -p stash@{1} to view the second most recent stash in patch form). You can use stash.showStat and/or stash.showPatch config variables to change the default behavior. 翻译如下：显示修改在stash状态与原版本之间的不同变化。当没有给定时，显示最新stash的变化。默认情况下，命令显示diffstat，它可以接受任何已知的git diff格式（例如，git stash show -p stash@{1}是查看第二最近stash的变化）。你可以使用stash.showstat和/或stash.showpatch配置变量来改变默认的行为。 总结也就是使用git stash show -p stash@{1}来查看stash的内容变化。","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"查看git bash内容","slug":"查看git-bash内容","permalink":"http://yoursite.com/tags/查看git-bash内容/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}]},{"title":"通过adb shell命令查看当前交互的Activity名称","slug":"通过adb-shell命令查看当前交互的Activity名称","date":"2018-01-08T12:46:09.000Z","updated":"2018-01-09T14:15:30.000Z","comments":true,"path":"2018/01/08/通过adb-shell命令查看当前交互的Activity名称/","link":"","permalink":"http://yoursite.com/2018/01/08/通过adb-shell命令查看当前交互的Activity名称/","excerpt":"","text":"需求在做android逆向的时候，有时候会需要知道当前的界面处于哪个Activity，这时候就可以使用adb shell命令来查看当前与用户交互的Activity名称。 原文地址先给出原文地址：http://stackoverflow.com/questions/11549366/print-the-current-back-stack-in-the-log/26424943#26424943 方法有如下几种方法可以获取： 方法一：adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39; 其中TaskRecord即为查询到的记录。其中com.sina.weibo为包名，.VisitorMainTabActivity为对应的Activity名称。 方法二：adb shell dumpsys activity | grep -i run 查询结果为： 方法三：adb shell dumpsys activity | grep &quot;mFoc&quot; 查询结果为：其中mFocusedActivity就是当前和用户交互的Activity。如果在Windows下使用时，则先通过adb shell进入到adb shell里，然后把adb shell去了，再将余下的复制到$后面进行执行，例如：这样就不会提示：“grep”不是内部或外部命令，也不是可运行查询了","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"adb查看交互Activity名称","slug":"adb查看交互Activity名称","permalink":"http://yoursite.com/tags/adb查看交互Activity名称/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"自定义控件View之onMeasure调用时机源码分析","slug":"自定义控件View之onMeasure调用时机源码分析","date":"2018-01-03T15:52:03.000Z","updated":"2018-01-03T15:53:14.000Z","comments":true,"path":"2018/01/03/自定义控件View之onMeasure调用时机源码分析/","link":"","permalink":"http://yoursite.com/2018/01/03/自定义控件View之onMeasure调用时机源码分析/","excerpt":"","text":"先上测试代码： MainActivity.java import android.app.Activity; import android.os.Bundle; import android.util.Log; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.e(&quot;hty&quot;, &quot;before setContextView&quot;); setContentView(R.layout.activity_main); Log.e(&quot;hty&quot;, &quot;after setContextView&quot;); } @Override protected void onResume() { super.onResume(); Log.e(&quot;hty&quot;, &quot;onResume&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.e(&quot;hty&quot;, &quot;onDestroy&quot;); } } MyView.java import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.util.AttributeSet; import android.util.Log; import android.view.View; public class MyView extends View { Paint paint; public MyView(Context context) { this(context, null); } public MyView(Context context, AttributeSet attrs) { super(context, attrs); Log.e(&quot;hty&quot;,&quot;view constructor&quot;); paint = new Paint(); paint.setColor(Color.RED); paint.setTextSize(20); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.e(&quot;hty&quot;,&quot;view onMeasure&quot;); } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); Log.e(&quot;hty&quot;,&quot;view onLayout&quot;); } String str = &quot;这里是测试&quot;; @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); Log.e(&quot;hty&quot;,&quot;view onDraw&quot;); canvas.drawText(str, getWidth()/2-paint.measureText(str)/2,getHeight()/2, paint); } } activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.zqc.mytest.MainActivity&quot;&gt; &lt;com.zqc.mytest.MyView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; /&gt; &lt;/RelativeLayout&gt; 正常运行后，查看对应的Log：从Log输出可以看出在一个View的绘制过程中，onMeasure是被多次调用了的。下面通过源码来一步步分析 onMeasure(int widthMeasureSpec, int heightMeasureSpec)函数，尤其是传过来的两个参数到底是从哪里来的。 首先看下MainActivity里面的setContentView，进入该函数后，其对应的代码如下： Activity.java public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 即调用了getWindow()的setContentView方法，查看getWindow方法，其返还的是类Window的一个实例mWindow，该类是一个抽象类，其具体实现类是PhoneWindow，即调用的是PhoneWindow的setContentView方法，查看相应的代码如下：PhoneWindow.java @Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 该方法首先判断mContentParent是否为空，不为空则调用installDecor()方法来初始化mContentParent，查看具体的代码：PhoneWindow.java private void installDecor() { if (mDecor == null) { mDecor = generateDecor();//这里生成了mDecor,它是所有应用窗口的根View 。 mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } if (mContentParent == null) { mContentParent = generateLayout(mDecor);//这里就生成了mContentParent，这个generateLayout会根据设定的style来布局显示的界面 // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); .... } } 其中generateDecor方法就直接返回一个DecorView，代码如下：PhoneWindow.java protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 而generateLayout(mDecor)方法会根据程序Activity设定的style来布局显示的界面，其代码如下：PhoneWindow.java protected ViewGroup generateLayout(DecorView decor) { // Apply data from current theme. TypedArray a = getWindowStyle();//获取窗口的style 。。。。 if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) { requestFeature(FEATURE_NO_TITLE);//看到没，你在xml里面设置的FEATURE_NO_TITLE，在这里生效了 } else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) { // Don&#39;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); } 。。。。 final Context context = getContext(); 。。。。 WindowManager.LayoutParams params = getAttributes(); if (!hasSoftInputMode()) { params.softInputMode = a.getInt( R.styleable.Window_windowSoftInputMode, params.softInputMode); } if (a.getBoolean(R.styleable.Window_backgroundDimEnabled, mIsFloating)) { /* All dialogs should have the window dimmed */ if ((getForcedWindowFlags()&amp;WindowManager.LayoutParams.FLAG_DIM_BEHIND) == 0) { params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND; } if (!haveDimAmount()) { params.dimAmount = a.getFloat( android.R.styleable.Window_backgroundDimAmount, 0.5f); } } 。。。。 int layoutResource; int features = getLocalFeatures(); 。。。。 View in = mLayoutInflater.inflate(layoutResource, null);//这里把给定的布局加载出来，然后加到decor中 decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//看到没这个ID_ANDROID_CONTENT，也就是一个窗口的根布局 if (contentParent == null) { throw new RuntimeException(&quot;Window couldn&#39;t find content container view&quot;); } 。。。。 mDecor.finishChanging(); return contentParent; } 通过一张图来分析下一个窗口的布局具体是怎样的。图上标的很详细，在最外层是一个FramLayout，其实也就是DecorView，是所有窗口的根布局，在该根布局下有一个(0)LinearLayout和一个(1)View，这个(1)View就是状态栏，(0)LinearLayout里面有个FrameLayout，在里面的多个View有固定的id，在图中已经标明，所有在一个Activity通过findViewById获取的ID_ANDROID_CONTENT就是(0)FrameLayout-&gt;(0)LinearLayout-&gt;(0)FrameLayout-&gt;(1)FrameLayout对应的View。要知道onMeasure两个参数到底是从哪里来的，还得再找下View是如何绘制的，上一篇文章有分析。View的绘制从ViewRootImpl的performTraversals()函数开始，下面进入该方法中具体分析下。 ViewRootImpl.java private void performTraversals() { // cache mView since it is used so much below... final View host = mView; 。。。。 mIsInTraversal = true; mWillDrawSoon = true; boolean windowSizeMayChange = false; boolean newSurface = false; boolean surfaceChanged = false; WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; final int viewVisibility = getHostVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility || mNewSurfaceNeeded; WindowManager.LayoutParams params = null; if (mWindowAttributesChanged) { mWindowAttributesChanged = false; surfaceChanged = true; params = lp; } 。。。。 Rect frame = mWinFrame; if (mFirst) { mFullRedrawNeeded = true; mLayoutRequested = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) { // NOTE -- system code, won&#39;t try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; } else { DisplayMetrics packageMetrics = mView.getContext().getResources().getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; } 。。。。 } else { desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) { if (DEBUG_ORIENTATION) Log.v(TAG, &quot;View &quot; + host + &quot; resized to: &quot; + frame); mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; } } if (viewVisibilityChanged) { mAttachInfo.mWindowVisibility = viewVisibility; host.dispatchWindowVisibilityChanged(viewVisibility); if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) { destroyHardwareResources(); } if (viewVisibility == View.GONE) { // After making a window gone, we will count it as being // shown for the first time the next time it gets focus. mHasHadWindowFocus = false; } } 。。。。 boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw); if (layoutRequested) { final Resources res = mView.getContext().getResources(); if (mFirst) { // make sure touch mode code executes by setting cached value // to opposite of the added touch mode. mAttachInfo.mInTouchMode = !mAddedTouchMode; ensureTouchModeLocally(mAddedTouchMode); } else { 。。。。 if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) { windowSizeMayChange = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) { // NOTE -- system code, won&#39;t try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; } else { DisplayMetrics packageMetrics = res.getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; } } } // Ask host how big it wants to be windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); } 。。。。 if (!mStopped || mReportNextDraw) { boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) { int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);//获取 int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//看这里，看这里 // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight &gt; 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(TAG, &quot;And hey let&#39;s measure once more: width=&quot; + width + &quot; height=&quot; + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//看这里，看这里 } layoutRequested = true; } } } 。。。。 mIsInTraversal = false; } private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 看performTraversals方法中调用的performMeasure的地方，performMeasure即调用了View的measure方法，而measure方法会去调用onMeasure方法。看下如下两行代码 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);//获取 int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 在这两行代码中获取了child的宽高，使用的方法是getRootMeasureSpec，其中参数lp.width是传入的MATCH_PARENT或者WRAP_CONTENT，mWidth是窗口期望的大小，getRootMeasureSpec代码如下：ViewRootImpl.java private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&#39;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec; } 这里应该很好理解了，其中调用了MeasureSpec类中的方法，关于MeasureSpec类网上资料很多，该类中用一个int值的两部分分别表示Mode和具体的尺寸。其中最高两位表示 Mode，而最低的30位表示具体的尺寸值，这里计算完之后就进入了View的measure函数中，代码如下： View.java public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) { // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension } 该方法是final的，因而不能被继承，但是里面提供了onMeasure回调，这样子类就可以直接继承onMeasure函数来实现相应的操作。这个View类型的，但是还有一种是ViewGroup类型，也就是容器类型的控件，在具体容器类型的控件里面可以通过重写onMeasure来实现，比如FrameLayout中的onMeasure函数如下：FrameLayout.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground&#39;s minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } } 大概也就是回调本容器里面的子View的measure函数实现尺寸计算。这里通过方法ViewGroup类中的getChildMeasureSpec()来获取子类期望自己获取的宽高大小。其代码是ViewGroup.java public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&#39;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&#39;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 在重写onMeasure方法时一定要调用setMeasuredDimension，该方法会将mPrivateFlags经过或使得View知道已经经过了measure这个步骤了。代码如下：View.java protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 至此分析结束，所以说一个View的大小是由自己和父类两者共同决定的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View onMeasure","slug":"View-onMeasure","permalink":"http://yoursite.com/tags/View-onMeasure/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"应用内存优化之OnLowMemory&OnTrimMemory","slug":"应用内存优化之OnLowMemory-OnTrimMemory","date":"2018-01-03T15:39:09.000Z","updated":"2018-01-03T15:41:49.000Z","comments":true,"path":"2018/01/03/应用内存优化之OnLowMemory-OnTrimMemory/","link":"","permalink":"http://yoursite.com/2018/01/03/应用内存优化之OnLowMemory-OnTrimMemory/","excerpt":"","text":"1.应用内存onLowMemory&amp; onTrimMemory优化onLowMemory&amp; onTrimMemory简介：OnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。OnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。根据不同的内存状态，来响应不同的内存释放策略。 1.1 onLowMemory&amp; onTrimMemory优化，需要释放什么资源？在内存紧张的时候，会回调OnLowMemory/OnTrimMemory，需要在回调方法中编写释放资源的代码。可以在资源紧张的时候，释放UI 使用的资源资：Bitmap、数组、控件资源。 1.2 OnLowMemoryOnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。系统提供的回调有：Application.onLowMemory()Activity.OnLowMemory()Fragement.OnLowMemory()Service.OnLowMemory()ContentProvider.OnLowMemory() 除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如： public static class MyCallback implements ComponentCallbacks { @Override public void onConfigurationChanged(Configuration arg) { } @Override public void onLowMemory() { //do release operation } 然后，通过Context.registerComponentCallbacks ()在合适的时候注册回调就可以了。通过这种自定义的方法，可以在很多地方注册回调，而不需要局限于系统提供的组件。onLowMemory 当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。 1.3 OnTrimMemoryOnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。系统提供的回调有：Application.onTrimMemory()Activity.onTrimMemory()Fragement.OnTrimMemory()Service.onTrimMemory()ContentProvider.OnTrimMemory()OnTrimMemory的参数是一个int数值，代表不同的内存状态：TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。以上4个是4.0增加TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存以上3个是4.1增加系统也提供了一个ComponentCallbacks2，通过Context.registerComponentCallbacks()注册后，就会被系统回调到。 1.4 OnLowMemory和OnTrimMemory的比较1，OnLowMemory被回调时，已经没有后台进程；而onTrimMemory被回调时，还有后台进程。2，OnLowMemory是在最后一个后台进程被杀时调用，一般情况是low memory killer 杀进程后触发；而OnTrimMemory的触发更频繁，每次计算进程优先级时，只要满足条件，都会触发。3，通过一键清理后，OnLowMemory不会被触发，而OnTrimMemory会被触发一次。 使用举例： @Override public void onTrimMemory(int level) { Log.e(TAG, &quot; onTrimMemory ... level:&quot; + level); } @Override public void onLowMemory() { Log.e(TAG, &quot; onLowMemory ... &quot;); } 2.系统回调优化2.1 回调原理：在Application、 Activity、Fragement、Service、ContentProvider中都可以重写回调方法，对OnLowMemory/OnTrimMemory进行回调，在回调方法中实现资源释放的实现。以Activity为例，在Activity源码中能够看到对于onTrimMemory的定义，因此在回调的时候重写方法即可。 public void onTrimMemory(int level) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onTrimMemory &quot; + this + &quot;: &quot; + level); mCalled = true; mFragments.dispatchTrimMemory(level); } 2.2 释放资源：在onTrimMemory释放资源，释放图片、数组、缓存等资源。 @Override public void onTrimMemory(int level) { // TODO Auto-generated method stub DLog.d(&quot; onTrimMemory ... level:&quot; + level); switch(level) { case TRIM_MEMORY_UI_HIDDEN: //释放资源 /*编写释放资源代码*/ } break; } super.onTrimMemory(level); } 下面是释放Bitmap的示例代码片段： 1 // 先判断是否已经回收 2 if(bitmap != null &amp;&amp; !bitmap.isRecycled()){ 3 // 回收并且置为null 4 bitmap.recycle(); 5 bitmap = null; 6 } 7 System.gc(); 复制代码 list占用方法： list.clear();然后在置空。 3.实现ComponentCallbacksOnLowMemory除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如： public static class ViewComponentCallbacks implements ComponentCallbacks { @Override public void onConfigurationChanged(Configuration arg) { } @Override public void onLowMemory() { //do release operation } } 注册自定义的回调类： ViewComponentCallbacks callBacks =new ViewComponentCallbacks(); this.registerComponentCallbacks( callBacks );回调之后，即可进行重写： @Override public void onLowMemory() { // TODO Auto-generated method stub //释放资源的方法 super.onLowMemory(); } Android onTrimMemory方法的一些疑惑？当你的app进程正在被cached时，你可能会接受到从onTrimMemory()中返回的下面的值之一: TRIM_MEMORY_BACKGROUND: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的app进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的app的时候才能够迅速恢复。TRIM_MEMORY_MODERATE: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。TRIM_MEMORY_COMPLETE: 系统正运行与低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的app恢复状态的资源。这个地方讲的进程正在被cache 是什么意思呢？是指我的进程 还没有结束 正在内存中 但是因为没有执行任何操作 不占有cpu的意思吗？此外当我们监听onTrimMemory回调方法的时候，假设我的缓存里最大的部分就是bitmap，请问就直接把bitmap从内存里抹去就可以了么？ 那如果这么做，在进程重新被加载到前台来的时候，我怎么迅速恢复这些bitmap资源？ 答疑答疑1：android进程回收主要涉及两个组件：ActivityManagerService（Ams）和lowmemorykiller。当手机内存不足时，lowmemorykiller就要开始杀进程了。但是lowmemorykiller呢只知道进程占用的内存大小，不知道进程对用户的重要性。Ams则负责管理android四大组件，当然知道进程的重要性了，所以呢还需要与Ams充分交换意见。 当app状态发生改变时，比如退到后台时，ams会对app的进程计算出一个值，即Oomadj（ams#computeOomAdjLocked），然后把这个值传给linux内核，lowmemorykiller呢就可以拿到这个值了，lowmemorykiller则就有了所有app进程的Oomadj值，即进程对用户的重要程度。当手机内存不足时，lowmemorykiller就有了足够的信息决定干掉哪个进程了。那，lowmemorykiller决定干掉哪个进程呢？这个要根据手机还有多少空闲内存，比如还有16MB空闲内存，如下lowmemorykiller.c static short lowmem_adj[6] = { 0, 1, 6, 12, }; static int lowmem_adj_size = 4; static int lowmem_minfree[6] = { 3 * 512, /* 6MB */ 2 * 1024, /* 8MB */ 4 * 1024, /* 16MB */ 16 * 1024, /* 64MB */ }; 16MB在lowmem_minfree第三个位置，取lowmem_adj第三个位置即6，ok所有Oomadj大于6的进程就被选中了。而lowmemorykiller不是把这些选中的进程都干掉，而是先干掉oomAdj最大而且占用内存最大的进程。如下lowmemorykiller.c#lowmem_scan： for_each_process(tsk) { ... oom_score_adj = p-&gt;signal-&gt;oom_score_adj; if (oom_score_adj &lt; min_score_adj) { task_unlock(p); continue; } tasksize = get_mm_rss(p-&gt;mm); task_unlock(p); if (tasksize &lt;= 0) continue; if (selected) { if (oom_score_adj &lt; selected_oom_score_adj) continue; if (oom_score_adj == selected_oom_score_adj &amp;&amp; tasksize &lt;= selected_tasksize) continue; } selected = p; selected_tasksize = tasksize; selected_oom_score_adj = oom_score_adj; } 总之一句话：进程对用户越不重要（Oomadj值就越大），占用内存越大，进程就越容易被干掉。 应对策略： 1 ams计算出一个危险的Oomadj值会调用onTrimMemory通知app，此时app应该把不重要的内存释放掉，只要比友商app占用的内存小被lowmemorykiller干掉的概率就小。 2 当然我们也可以先把忧伤的app干掉。。。帮用户释放内存（开玩笑啦） 3 如果我们的app能预置到手机中，并且manifest设置为persistence（Oomadj=0），或者coreserver则不必担心被lowmemorykiller干掉了。不过还有可能被linux层的oomkiller干掉的。当然这也是某些手机预置一堆app导致越用越慢的一个原因，所以我们尽量把这些预置app卸载掉。 答疑2：理解进程和组件之间的关系 一般来说，你的App在启动的时候，系统都会为你的APP创建一个进程。 比如我有一个App，其包名为com.performance.liferecord 当这个App启动的时候，我们可以通过ps命令来看其对应的进程 信息： 结果如下： USER PID PPID VSIZE RSS WCHAN PC NAME 可以看到系统为这个进程分配的PD是32452，那么 PPID是什么呐？ 使用PS命令来看：adb shell ps | grep 379 可以看到PPID的NAME是zygote64，也就是说32452这个进程是从Android的zygote64这个进程fork过来的。 那么 组件又是怎么回事呐？我们常说四大组件，Activity、Service、Broadcast、ContentProvider。这些个组件都是依附于一个进程来运行的，一个进程可以有多个Activity、Service等，也可以一个组件都没有。 Cache状态 当你的应用程序到了后台之后，会进入Cached状态，这时候进程还存在，但是组件是否存在就不一定了。 不过一般我们认为，当你按Back键回到桌面之后，如果Activity没有被释放，那么我们认为了内容泄漏，这个有兴趣可以自己看看。 以上面我提到的com.performance.liferecord这个应用为例子，当我启动这个应用之后，我们可以使用命令adb shell dumpsys meminfo来查看整个系统的状态，此时com.performance.liferecord这个进程状态为Foreground: Foreground意味着此时你的进程处于前台进程，你的程序的界面可以被用户看到。此时我们使用adb shell dumpsys meminfo com.preformance.liferecord来看这个进程的状态： 可以看到Activity的数量为1（因为我只起了一个Activity） 当我们点击Back键的时候，我们可以使用命令adb shell dumpsys meminfo来查看 整个系统的状态，此时com.performance.liferecord这个进程状态为Cached: Cached状态标识你的应用进程变成了后台进程，位于LRU list里面。 此时我们使用adb shell dumpsys meminfo com.performance.liferecord来看这个进程的状态： Activity的数量妥妥变成0了，说明没有内存泄漏。此时你的进程里面，是没有任何组件的。当然也不占用cpu的资源，但是会点内存（例子中我们可以看到占用了20706kb）的内存。 将后台进程放到Cached列表里而不是直接杀掉，其好处就是下一次这个进程的某个组件（最常见的就是Activity）启动的时候，不需要再创建新的进程 ，速度杠杠的（比如就应用的热启动）。 onTrimMemory 此外当我们监听onTrimMemory回调方法的时候，假设我的缓存里最大的部分就是bitmap，请问就直接把bitmap从内存里抹去就可以了么？ 那如果这么做，在进程重新被加载到前台来的时候，我怎么迅速恢复这些bitmap资源？ 如答疑1所述： 对于 图片，一般采用三层缓存机制，即内存、文件、网络、释放内存后从文件中读取就好 一般的图片加载库都会提供内存/文件的缓存，即使内存中的Bitmap清除掉了，下一次从文件中读取也会很快的。 至少onTrimMemory的优点，比如你的应用Cache了20MB的Bitmap没有清除，当手机内存不足的时候，如果你没有及时释放 这些内存，那么 很可能你的进程 就被系统给杀掉了，这会你的Bitmap当然也就没了。用户下次启动你的应用的时候，我曹这货又被杀了，这手机系统有毛病吧？ 是吧。。。做系统的还得背这个锅！ 关于onTrimMemory的使用，可以参考博客http://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory.html","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"内存优化","slug":"内存优化","permalink":"http://yoursite.com/tags/内存优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RoboBinding(MVVM)架构介绍","slug":"RoboBinding-MVVM-架构介绍","date":"2018-01-03T15:08:14.000Z","updated":"2018-01-09T14:38:55.000Z","comments":true,"path":"2018/01/03/RoboBinding-MVVM-架构介绍/","link":"","permalink":"http://yoursite.com/2018/01/03/RoboBinding-MVVM-架构介绍/","excerpt":"","text":"[TOC] 1. 什么是RoboBinding?同步差异 - RoboBinding 是一个数据绑定器。 Presentation Model framework（著名的MVVM框架）是安卓上的一个框架. RoboBinding帮助你在写UI代码时能方便的阅读、测试和维护。 2.AndroidMVVM(Presentation Model)框架通过RoboBinding建立的一个activity由三个部分组成：layout布局，activity类，还有一个演示模型类。这里有个简单的事例AndroidMVVM。 2.1. Layout布局在布局文件总，我们声明一下RoboBinding的命名空间，属性和一些事件的attribute绑定。例如activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:bind=&quot;http://robobinding.org/android&quot;&gt; &lt;TextView bind:text=&quot;{hello}&quot; /&gt; ... &lt;Button android:text=&quot;Say Hello&quot; bind:onClick=&quot;sayHello&quot;/&gt; &lt;/LinearLayout&gt; 2.2. Presentation Model(简单的Java对象)在演示层中，我们声明一个对应的属性和方法。代码如下org.robobinding.androidmvvm.PresentationModel.java org.robobinding.annotation.PresentationModel public class PresentationModel implements HasPresentationModelChangeSupport { private String name; public String getHello() { return name + &quot;: hello Android MVVM(Presentation Model)!&quot;; } ... public void sayHello() { firePropertyChange(&quot;hello&quot;); } } 2.3. Activity类通过RoboBinding框架将布局和演示层的model绑定在activity界面上。org.robobinding.androidmvvm.MainActivity.java public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { ... PresentationModel presentationModel = new PresentationModel(); View rootView = Binders.inflateAndBindWithoutPreInitializingViews(this, R.layout.activity_main, presentationModel); setContentView(rootView); } } 这样一个简单的AndroidMVVM事例就写完了。我们使用工具类Binders将UI空间和数据Model很简单的进行绑定。在真正使用时我们推荐使用org.robobinding.binder.BinderFactoryBuilder类。我们可以将BinderFactoryBuilder以单例模式保存在整个工程中，也可以使用第三方法库，例如 RoboGuice ，来帮忙管理BinderFactory对象实例，这样可以在全局共享和重复使用该实例。 2.4. 介绍视频2012年2月 Robert Taylor 录了一个介绍RoboBinding的视频，下载地址.2014年7月Cheng Wei录了一个中文的介绍视频，下载地址. 3. 环境设置3.1. Eclipse下安装使用安装Eclipse. 3.1.1. 没有AspectJ时将robobinding-[version]-with-dependencies.jar 或者robobinding-[version].jar + [google guava]-[11.0.1+].jar 放到工程的libs目录下，然后把他们添加到classpath上。点击顺序： project→Properties→Java Build Path→Libraries→Add JARs.在展开的列表上点击对应的jar包。 3.1.2. 在有AspectJ时RoboBinding能帮我们减少一些自动绑定的代码。首先安装Android Development Tools 插件。然后右击项目→Configure→Convert to AspectJ Project. 这样就可以将AspectJ特性加入到项目当中。按同样的方法将 robobinding-[version]-with-aop-and-dependencies.jar 或者 the robobinding-[version]-with-aop.jar + [google guava]-[11.0.1+].jar加入的libs目录下，然后添加的项目的classpath中。最后确保RoboBinding的jar是加入到Aspect路径中，具体方法如下： 3.1.3. Annotaton Processing 设置下载RoboBindingcodegen-[version]-with-dependencies.jar的jar包。按如下方式添加到工程，注意项目不要依赖这个jar。 3.2. Android Studio安装方法3.2.1. 没有AspectJ时将robobinding依赖添加到gradle.build中。 dependencies { ... compile&quot;org.robobinding:robobinding:${robobindingVersion}&quot; //alternatively we can use with-dependencies jar(RoboBinding provide a minimal Proguarded with-dependencies jar.). compile(&quot;org.robobinding:robobinding:${robobindingVersion}:with-dependencies&quot;) { exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39; } } RoboBinding是完全免费的，可以随意引用,例如：AndroidMVVM, RoboBinding-album-sample 和 RoboBinding-gallery. 3.2.2. 有AspectJ时在gradle.build中应用RoboBinding的Android aspcetj插件。 buildscript { repositories { ... maven() { name &#39;RoboBinding AspectJPlugin Maven Repository&#39; url &quot;https://github.com/RoboBinding/RoboBinding-aspectj-plugin/raw/master/mavenRepo&quot; } } dependencies { ... classpath &#39;org.robobinding:aspectj-plugin:0.8.+&#39; } } ... apply plugin: &#39;org.robobinding.android-aspectj&#39; 添加RoboBinding 依赖到 gradle.build中 dependencies { ... compile &quot;org.robobinding:robobinding:$robobindingVersion&quot; aspectPath &quot;org.robobinding:robobinding:$robobindingVersion&quot; //alternatively we can use with-aop-and-dependencies jar(RoboBinding provides a minimal Proguarded with-aop-and-dependencies jar.). compile (&quot;org.robobinding:robobinding:$robobindingVersion:with-aop-and-dependencies&quot;) { exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39; } aspectPath (&quot;org.robobinding:robobinding:$robobindingVersion:with-aop-and-dependencies&quot;) { exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39; } } RoboBinding是完全免费的，可以随意引用,例如：AndroidMVVM, RoboBinding-album-sample 和 RoboBinding-gallery. 3.2.3. Annotation Processing 设置在gradle.build中添加apt插件。 buildscript { repositories { ... } dependencies { ... classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.+&#39; } } ... apply plugin: &#39;com.neenbedankt.android-apt&#39; 3.3. ProGuard设置在proguard中需要保存PresentationModel和生成的构造方法，我们也需要保存所以的注解。在proguard配置中进行如下设置： -keepattributes *Annotation*,Signature -keep,allowobfuscation @interface org.robobinding.annotation.PresentationModel -keep @org.robobinding.annotation.PresentationModel class * { public *** *(...); } -keep class * implements org.robobinding.itempresentationmodel.ItemPresentationModel{ public *** *(...); } -keep class * extends org.robobinding.presentationmodel.AbstractPresentationModelObject{ public &lt;init&gt;(...); } -keep class * extends org.robobinding.presentationmodel.AbstractItemPresentationModelObject{ public &lt;init&gt;(...); } 添加如下几行以便保持view监听的构造函数。 -keepclassmembers class * implements org.robobinding.viewattribute.ViewListeners { public &lt;init&gt;(...); } 添加如下几行来抑制Google的javax.annotation.XX 引用警告。 -dontwarn javax.annotation.** 在如下链接中有相关样例 RoboBinding organization. 4. 概念和特性一个安卓应用中包含若干个activity界面和其他一些元素。在以RoboBinding架构编写的安卓应用中，一个activity包含一个activity类，一个layout布局和一个PresentationModel的普通类（而在普通安卓应用中，一个activity仅仅包含activity类和layout布局文件）。原先都在Activity类中编写展示逻辑的现在都提取到一个独立PresentationModel的简单类中。布局中视图控件的展示数据都绑定在PresentationModel的属性上，视图控件的各个事件都绑定在PresentationModel的方法上。RoboBinding可以帮助我们减少或者删除在Activity类中的UI相关代码，通过简单的在layout布局进行绑定。理想的PresentationModel仅仅包含UI展示逻辑，不包含UI代码或者UI连接代码，并且能够被单独的、简单的测试。这部分样例代码可以通过如下链接查看Robobinding Gallery. 4.1. 单向属性绑定当我们将一根属性绑定到一个presentation模型时，任何对该属性的更改都会直接传给相应的View。activity_view.xml &lt;TextView bind:visibility=&quot;{integerVisibility}&quot;/&gt; ViewPresentationModel.java public int getIntegerVisibility() { return integerVisibilityRotation.value(); } robobinding遵循JavaBeans规范也提供getters和setters方法。在单方向绑定中，仅仅需要提供getters方法，即view的任何改变不需要更新给对应的presentation模型。更多关于属性绑定的内容可以参考API和属性绑定文档 4.2. 双向属性绑定双方向属性绑定顾名思义就是对presentation model的任何改变会反映到对应的view上，同时对view的任何改变也会更改对应的presentation Model。EditText控件中的text属性是支持双向绑定的。考虑这种情况，无论何时用户更改了EditText的text内容，对应的presentation Model都会相应的进行更改。双向属性绑定仅仅需要在大括号外加一个美元$符，例如：activity_edittext.xml &lt;EditText bind:text=&quot;${text}&quot;/&gt; 为了支持双向绑定，需要在对应的presentation model中添加setter方法：org.robobinding.gallery.presentationmodel.EditTextPresentationModel.java PresentationModel public class EditTextPresentationModel { private String text; public String getText() { return text; } public void setText(String text) { this.text = text; } } 4.3. 事件绑定将view的事件绑定到presentation model的方法上，可以通过bind:onClick=”showDemo”来实现。activity_gallery.xml &lt;Button bind:onClick=&quot;showDemo&quot;/&gt; org.robobinding.gallery.presentationmodel.GalleryPresentationModel.java PresentationModel public class GalleryPresentationModel { ... public void showDemo() { ... } } 当点击事件被触发时，presentation Model绑定的方法将被执行。我们能选择性的支持一个事件的参数，在上面例子中对应的参数是org.robobinding.widget.view.ClickEvent更多关于UI事件绑定可以参考API和属性绑定文档 4.4. AdapterViews的绑定当我们绑定一个AdapterViews时，RoboBinding首先要求我们指出对于presentation model基础的数据。可以是以下几个类型：an Array, List or org.robobinding.itempresentationmodel.TypedCursor.在有基础数据后，RoboBinding需要知道presentation模型和子view对应的绑定关系。我们可以通过 @ItemPresentationModel注解实现。例如：activity_adapter_view.xml &lt;ListView bind:itemLayout=&quot;@android:layout/simple_list_item_1&quot; bind:itemMapping=&quot;[text1.text:{value}]&quot; bind:source=&quot;{dynamicStrings}&quot;/&gt; org.robobinding.gallery.presentationmodel.AdapterViewPresentationModel.java PresentationModel public class AdapterViewPresentationModel { ... @ItemPresentationModel(value=StringItemPresentationModel.class) public List&lt;String&gt; getDynamicStrings() { return getSelectedSource().getSample(); } ··· 提供的基础数据需要继承自ItemPresentationModel 接口。org.robobinding.gallery.presentationmodel.StringItemPresentationModel.java public class StringItemPresentationModel implements ItemPresentationModel&lt;String&gt; { private String value; @Override public void updateData(int index, String bean) { value = bean; } public String getValue() { return value; } } 然后我们给每一个条目行定义一个布局。在该例中我们使用Android库给的simple_list_item_1.xml布局。通过bind:itemMapping=”[text1.text:{value}]”进行绑定我们将simple_list_item_1.xml中的text1.text绑定到StringItemPresentationModel.value中。在@ItemPresentationModel中有一个工厂方法属性(factoryMethod)。当ItemPresentationModels有一些扩展的依赖时，我们能增加一个工厂方法(factoryMethod)到PresentationModel里面以便ItemPresentationModels能通过该方法进行创建。通过这种方式，我们能将任何依赖让到ItemPresentationModel中，通过完全自由的方式。下面是一个简单的例子。 @PresentationModel public class PresentationModelSample { ... @ItemPresentationModel(value=ItemPresentationModelSample.class, factoryMethod=&quot;createItemPresentationModelSample&quot;) public List&lt;String&gt; getDynamicStrings() { return getSelectedSource().getSample(); } public ItemPresentationModelSample createItemPresentationModelSample() { return ItemPresentationModelSample(dependency1, dependency2, ...); } 4.5. 轻量级关系cursor游标映射对应的对象cursor游标在AdapterViews绑定中提到数据类型org.robobinding.itempresentationmod el.TypedCursor。由于我们经常操作对象甚过操作对象数据，因而我们希望能将操作关系数据库的代码进行分离。RoboBinding增加了一个轻量级的对象cursor游标-TypedCursor。通过org.robobinding.itempresentationmodel.RowMapper类，我们能将一条数据转换为一个对象。示例如下：org.robobinding.gallery.presentationmodel.TypedCursorPresentationModel.java @PresentationModel public class TypedCursorPresentationModel { ... @ItemPresentationModel(value=ProductItemPresentationModel.class) public TypedCursor&lt;Product&gt; getProducts() { return allProductsQuery.execute(db); } } org.robobinding.gallery.model.typedcursor.GetAllQuery.java public class GetAllQuery&lt;T&gt; { private String tableName; private final RowMapper&lt;T&gt; rowMapper; public GetAllQuery(String tableName, RowMapper&lt;T&gt; rowMapper) { ... this.tableName = tableName; this.rowMapper = rowMapper; } public TypedCursor&lt;T&gt; execute(SQLiteDatabase db) { Cursor cursor = db.query( tableName, null, null, null, null, null, BaseColumns._ID+&quot; ASC&quot;); return new TypedCursorAdapter&lt;T&gt;(cursor, rowMapper); } } org.robobinding.gallery.model.typedcursor.ProductRowMapper.java public class ProductRowMapper implements RowMapper&lt;Product&gt; { @Override public Product mapRow(Cursor cursor) { String name = cursor.getString(cursor.getColumnIndex(ProductTable.NAME)); String description = cursor.getString(cursor.getColumnIndex(ProductTable.DESCRIPTION)); return new Product(name, description); } } 4.6. 菜单绑定将一个res/menu中的菜单资源绑定到一个Presentation Models中。看如下例子：res/menu/context_menu.xml &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://robobinding.org/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:title=&quot;Delete Product&quot; bind:onMenuItemClick=&quot;deleteProduct&quot; android:id=&quot;@+id/deleteProduct&quot; app:showAsAction=&quot;always&quot;/&gt; &lt;/menu&gt; org.robobinding.gallery.presentationmodel.ContextMenuPresentationModel.java @PresentationModel public class ContextMenuPresentationModel { ... public void deleteProduct(MenuItem menuItem) { ... } } 4.7. Presentation Models（演示models）我们将任何一个presentationModel添加@org.robobinding.annotation.PresentationModel注解。当一个presentationmodel需要org.robobinding.presentationmodel.PresentationModelChangeSupport支持时，presentationmodel必须继承自org.robobinding.presentationmodel.HasPresentationModelChangeSupport 接口，以便于框架层能在内部使用PresentationModelChangeSupport对象。 有两种方式可以实现一个Presentationmodel，一个是有AspectJ时，一个是没有AspectJ时， 4.7.1.没有 AspectJ 使用robobinding-[version].jar或者robobinding-[version]-with-dependencies.jar库 这种方式的好处是没有额外的依赖，可以使最终的apk尽可能的小 不好的地方在我们需要手动设置每一个firePropertyChange(“propertyName”).以下有具体的样例AndroidMVVM 和 Android-CleanArchitecture 4.7.2. 有 AspectJ 使用robobinding-[version]-with-aop.jar 或者robobinding-[version]-with-aop-and-dependencies.jar库 好处是许多firePropertyChange(“propertyName”) 可以自动生成 不好的地方是在AspectJ运行库里面包含依赖，这轻微的增加了最终apk的大小。以下是具体样例Album Sample 和 Gallery 5. 创造我们自己的view绑定这一节的样例代码是： Robobinding Gallery. 5.1. 单向绑定在如下的例子中我们增加了View的enable属性绑定- source code. @ViewBinding(simpleOneWayProperties = {&quot;enabled&quot;}) public class ViewBindingForView extends CustomViewBinding&lt;View&gt; { } 然后添加到 BinderFactoryBuilder - source code. new BinderFactoryBuilder() .add(new ViewBindingForView().extend(View.class)) .build(); RoboBinding能够生成如下代码： public class ViewBindingForView$$VB implements ViewBinding&lt;View&gt;{ final ViewBindingForView customViewBinding; public ViewBindingForView$$VB(ViewBindingForView customViewBinding) { this.customViewBinding = customViewBinding; } @Override public void mapBindingAttributes(BindingAttributeMappings&lt;View&gt; mappings) { mappings.mapOneWayProperty(ViewBindingForView$$VB.EnabledAttribute.class, &quot;enabled&quot;); customViewBinding.mapBindingAttributes(mappings); } public static class EnabledAttribute implements OneWayPropertyViewAttribute&lt;View, Boolean&gt; { @Override public void updateView(View view, Boolean newValue) { view.setEnabled(newValue); } } } 所以的绑定都是静态static的，这意味着每一性能的影响。 5.2. 其他类型的绑定除了单向属性绑定外，这里还有事件event绑定，多类型属性绑定和其他组属性类型的绑定。为了能实现这些绑定，我们需要扩展CustomViewBinding和手动实现对应的继承。具体例子如下： @ViewBinding public class MyCustomViewBinding extends CustomViewBinding&lt;CustomView&gt; { @Override public void mapBindingAttributes(BindingAttributeMappings&lt;CustomView&gt; mappings) { mappings.mapEvent(OnCustomEventAttribute.class, &quot;onCustomEvent&quot;); } public class OnCustomEventAttribute implements EventViewAttributeForView { ... } } 对于这些绑定，我们能在如下链接找到例子：- source code under widget package. 5.3. 自定义控件或者第三方控件我们能对于任何自定义控件、第三方控件、Android widgets创建view绑定，以便更容易的使用它们。在RoboBinding中，这些绑定是一样的。 下面是一个简单的自定义控件的例子，该View有一个白色的边框。这个控件有一个标题和一个描述组成。当我们输入新的标题和描述后，然后点击应用（Apply），控件自己讲对于的更新。 这个需求可以用以下简单的代码实现：activity_custom_component.xml &lt;org.robobinding.gallery.model.customcomponent.TitleDescriptionBar bind:title=&quot;{title}&quot; bind:description=&quot;{description}&quot;/&gt; 这个TitleDescriptionBar控件的代码如下：(对于如何实现一个自定义控件，参考如下：Android Reference): public class TitleDescriptionBar extends LinearLayout { private TextView title; private TextView description; public TitleDescriptionBar(Context context, AttributeSet attrs) { this(context, attrs, R.layout.title_description_bar); } protected TitleDescriptionBar(Context context, AttributeSet attrs, int layoutId) { super(context, attrs); LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); inflater.inflate(layoutId, this); title = (TextView) findViewById(R.id.title); description = (TextView) findViewById(R.id.description); ... } public void setTitle(CharSequence titleText) { title.setText(titleText); } public void setDescription(CharSequence descriptionText) { description.setText(descriptionText); } } 对于的布局是： title_description_bar.xml: &lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://robobinding.org/android&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot;/&gt; &lt;TextView android:text=&quot;: &quot;/&gt; &lt;TextView android:id=&quot;@+id/description&quot;/&gt; 5.3.1. 实现属性绑定这个控件有两个简单的单向属性绑定- source code. @ViewBinding(simpleOneWayProperties = {&quot;title&quot;, &quot;description&quot;}) public class TitleDescriptionBarBinding extends CustomViewBinding&lt;TitleDescriptionBar&gt; { } 5.3.2. 注册ViewBindingsViewBindings能够通过org.robobinding.binder.BinderFactoryBuilder 进行绑定- source code. BinderFactory binderFactory = new BinderFactoryBuilder() .add(new TitleDescriptionBarBinding().forView(TitleDescriptionBar.class)) .build(); 这样就行了。我们能用同样的方法绑定第三方控件或者Android Widgets。 5.4. 替换已有的view绑定当一个已经存在的view绑定不能满足我们需求时，我们通过注册去替代默认的继承implementations. BinderFactory binderFactory = new BinderFactoryBuilder() .add(new MyViewBindingForView().forView(View.class)) .build(); @ViewBinding static class MyViewBindingForView extends CustomViewBinding&lt;View&gt; { ... } 5.4.1. 扩展一个已经存在的view绑定扩展一个已经存在的TextViewBinding，并且增加一个属性绑定。 BinderFactory binderFactory = new BinderFactoryBuilder() .add(new MyTextViewBinding().extend(TextView.class)) .build(); @ViewBinding(simpleOneWayProperties={&quot;typeface&quot;}) static class MyTextViewBinding extends CustomViewBinding&lt;TextView&gt; { ... } 6. Album例子的具体步骤Album工程是一个Martin Fowler的翻译版本original one. 源代码如下： 这里.在接下来的几节，包名是已org.robobinding.albumsample开头的 上面是这个项目的原型。这个项目遵循RoboBinding工程的架构。一个Activity由一个Activity类，布局.xml和一个原型Model组成。在项目中你能看到如下几个包：org.robobinding.albumsample.activity,该包包含所有的Activity界面类；org.robobinding.albumsample.presentationmodel,该包包含所有的原型类；org.robobinding.albumsample.model,该包包含所有的Album实现类；org.robobinding.albumsample.store,该包包含所有的AlbumStore实现类。在原型中有5个表格，分别代表如下：[Home Activity]表格由.activity.HomeActivity,home_activity.xml和.presentationmodel.HomePresentationModel组成。[View Albums Activity]由.activity.ViewAlbumsActivity, view_albums_activity.xml和.presentationmodel.ViewAlbumsPresentationModel组成; 每一个album条目由.presentationmodel.AlbumItemPresentationModel 和album_row.xml来构成; 当album列表是空时，用albums_empty_view.xml布局来代替。[Create Album Activity]和[Edit Album Activity]两者都使用.activity.CreateEditAlbumActivity, create_edit_album_activity.xml 和.presentationmodel.CreateEditAlbumPresentationModel来构成。[View Album Activity].activity.ViewAlbumActivity, view_album_activity.xml 和.presentationmodel.ViewAlbumPresentationModel组成; 它的album 删除对话框.activity.DeleteAlbumDialog, delete_album_dialog.xml和 .presentationmodel.DeleteAlbumDialogPresentationModel构成。把[View Albums Activity]作为一个简单的例子来阐述如何使用RoboBinding。ViewAlbumsActivity是关联到view_albums_activity.xml和ViewAlbumsPresentationModel上面的。view_albums_activity.xml包含3个子View，一个TextView，一个ListView和一个Button。这个TextView不包含任何绑定信息。在ListView中bind:source=”{albums}”绑定到 ViewAlbumsPresentationModel.albums dataset property. bind:onItemClick=”viewAlbum” 绑定到ViewAlbumsPresentationModel.viewAlbum(ItemClickEvent) 方法上. 当album的一个条目被点击时，这个方法将被调用。当数据为空时会使用albums_empte_view.xml布局bind:emptyViewLayout=”@layout/albums_empty_view” 。bind:itemLayout=”@layout/album_row”对应每一行布局，在该布局中有两个TextView，绑定信息如下：bind:text=”{title}” and bind:text=”{artist}” 绑定到AlbumItemPresentationModel.title/artist respectively.在view_albums_activity.xml布局中的子布局是一个 Button. 它的点击事件bind:onClick=”createAlbum” 绑定到ViewAlbumsPresentationModel.createAlbum()方法上。 7. Gallery Demos的组成The entry classes mentioned below are from the package org.robobinding.gallery.activity of Robobinding Gallery project. Binding attributes demo for View. The entry class is ViewActivity. Binding attributes demo for EditText. The entry class is EditTextActivity. Binding attributes demo for AdapterView. The entry class is AdapterViewActivity. Binding attributes demo for ListView. The entry class is ListViewActivity. Binding attributes demo for RecyclerView. The entry class is RecyclerViewActivity. Binding attributes demo for Custom Components. The entry class is CustomComponentActivity. Demo for Object Cursor. The entry class is TypedCursorActivity. Demo for Fragment &amp; ViewPager Binding. The entry class is ListFragmentDemoActivity. Demo for Options Menu Binding. The entry class is OptionsMenuActivity. Demo for Context Menu Binding. The entry class is ContextMenuDemoActivity. Demo for Contextual Action Mode Binding. The entry class is ContextualActionModeActivity. 8. 项目结构和项目实践Involved from MVC pattern, the major motive of Presentation Model(MVVM) pattern is to further decouple UI state and logic into a pure POJO Presentation Model, which can be easily Unit tested. Meanwhile, the dependency of View→Presentation Model→Model becomes unidirectional. When applying the pattern, these are the basic rules we will follow. Album Sample is an example that follows the best practices. Recommend to read Martin Fowler’s original article on Presentation Model. 8.1. 整个项目框架In Android app, the view layer consists of activities(fragments) and their layouts and the model layer(or business model layer) consists of various services, persistence layer, networking services, business services and so on. The diagram indicates the dependency between different layers. The view layer for example never directly accesses the business model. 8.2. 常见问题解决方案 When we are not using a third-party dependency injection lib, we may instantiate business model objects in Activities and then pass them into presentation models, but the view layer(or any activities) will not directly access any business model objects. Sometimes presentation models may need to call some functionalities in the view layer. We can add view interfaces in between to decouple the relationship. Presentation models depends on view interfaces instead of the view layer, which keeps the testability of presentation models. If you prefer, you can shift these view interfaces into presentation model layer or presentation model package, so that the dependency remains unidirectional. Let us have a look a simple example below:``` javainterface MainView {void doSomeViewLogic();} class MainActivity extends Activity implements MainView {…@Overrideprotected void onCreate(Bundle savedInstanceState) {…PresentationModel presentationModel = new PresentationModel(this);…} public void doSomeViewLogic() {…}} class PresentationModel {private MainView mainView; public PresentationModel(MainView mainView) {this.mainView = mainView;} public void someEvent() {mainView.doSomeViewLogic();}}``` 9. 其他资源Jan 2012 Robert Taylor has written a couple of introductory articles here and here. Feb 2012 A video of a talk on RoboBinding at SkillsMatter, London can be found here. Jul 2014 A video of a talk on RoboBinding in Chinese by Cheng Wei can be found here. Sep 2014 A talk at YOW 2014 Android MVVM by Adil Mughal on Write cleaner, maintainable and testable code in Android using MVVM. AndroidMVVM A minimal android app with MVVM. RoboBinding album sample is an Android translation of Martin Fowler’s original sample code on Presentation Model pattern. RoboBinding Gallery demonstrates RoboBinding features. Version 0.8.10Last updated 2015-10-24 16:50:07","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"RoboBinding,MVC,MVP","slug":"RoboBinding-MVC-MVP","permalink":"http://yoursite.com/tags/RoboBinding-MVC-MVP/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}]},{"title":"AsyncTask研究","slug":"AsyncTask研究","date":"2018-01-03T14:32:22.000Z","updated":"2018-01-18T13:51:00.000Z","comments":true,"path":"2018/01/03/AsyncTask研究/","link":"","permalink":"http://yoursite.com/2018/01/03/AsyncTask研究/","excerpt":"","text":"1. AsyncTask概述在Android平台上，要执行异步工作时，我们常常会用到AsyncTask。这个类可以算是历史悠久，早在Android 1.5版时，它就存在了。 AsyncTask的使用方法比较简单，无非是创建一个AsyncTask派生类对象，重写其doInBackground()函数，然后在合适世纪调用这个对象的execute()或executeOnExecutor()函数即可。 private static class MyTask extends AsyncTask&lt;Void, Void, Void&gt; ｛ // . . . . . . @Override public Void doInBackground(Void... param) { //. . . . . . return null; } ｝ private class TestClickListener implements View.OnClickListener { public void onClick(View v) { switch (v.getId()) { case R.id.scan_btn: testTask(); break; . . . . . . } private void testTask() { for (int i = 0; i &lt; 5; i++) { MyTask t = new MyTask(i+100); t.execute(); // 调用execute()即可 } } 一般情况下，我们会像上面代码中这样调用AsyncTask的execute()函数，这样，投入执行的task会串行执行。不过，有时候我们也希望task们可以并行执行，此时只需把execute()换成executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)即可。 2. AsyncTask的内部机制AsyncTask本身是个抽象的泛型基类，正如前面所说，在实际使用时，我们必须定义它的派生类，并在实现AsyncTask派生类时，重写其doInBackground()成员函数。 AysncTask的声明如下：【frameworks/base/core/java/android/os/AsyncTask.java】 public abstract class AsyncTask作为一种异步执行的任务，AsyncTask是依靠内部的线程池来完成任务调度的。大体上说，AsyncTask内部搞了两个静态的执行器，分别表示成AsyncTask.THREAD_POOL_EXECUTOR 和 AsyncTask.SERIAL_EXECUTOR，前者是可并行执行的执行器（线程池），后者是串行执行的执行器（线程池）。 AsyncTask的构造函数如下： /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 构造函数的注释中说的很明确，必须在UI线程里构造AsyncTask对象。而且构造函数里为两个重要的成员：mWorker和mFuture赋了值，这个我们后文再细说。 2.1 AsyncTask的execute()我们先回过头看前文曾经提到的AsyncTask的execute()函数，其代码如下：【frameworks/base/core/java/android/os/AsyncTask.java】 MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 因为params参数是可变长参数，所以execute()可以接受0到n个参数。注意，execute()和executeOnExecutor()都必须在UI线程里调用。 execute()只是简单地调用executeOnExecutor()而已，它传递的静态变量sDefaultExecutor引用的就是串行执行器AsyncTask.SERIAL_EXECUTOR：private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;executeOnExecutor()的代码截选如下： MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { . . . . . . . . . . . . mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); // 注意，mFuture本身实现了Runnable接口 return this; } 也就是说，最终还是在调用执行器的execute()函数，只不过会把一个mFuture委托给执行器去回调。 默认情况下使用的串行执行器类是SerialExecutor，它的代码如下： private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { // 参数r一般就是mFuture引用的对象 mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 从代码里可以看到，所谓的串行执行器内部，其实也是在复用THREAD_POOL_EXECUTOR，只不过利用对mActive的判断，把调用的流程改成串行的了。 SerialExecutor内部使用的是java.util.ArrayDeque队列，它的poll()函数可以检索并移除此队列的头部，如果返回null，则表示此队列已经取空了。每次摘取一个列头，并记录在mActive变量里，然后交给THREAD_POOL_EXECUTOR来处理。 ThreadPoolExecutor是java提供的线程池实现。总之，线程池会在后续的某个时刻，回调上面插入的Runnable对象的run()。在executeOnExecutor()函数里，我们已经看到向执行器添加了AsynctTask的mFuture成员，而mFuture本身实现了Runnable接口，以后回调就是回调mFuture的run()函数。 2.2 AsyncTask和线程池的协作2.2.1 AsyncTask里的mFutureAsyncTask的mFuture非常重要，它的定义如下： private final FutureTask mFuture;类型为FutureTask，其实现可以参考JDK里的代码：【java/util/concurrent/FutureTask.java】public class FutureTask implements RunnableFuture【java/util/concurrent/FunnableFuture.java】public interface RunnableFuture extends Runnable, Future在前文列出AsyncTask构造函数时，我们已经看到mFuture的创建代码了，注意，在创建FutureTask对象时，传入了mWorker，它会被记入mFuture内部（如果分析JDK的代码，可以看到大体上就是记入mFuture.sync.callable了）。后续在被线程池执行时，这个mWorker才是最核心的对象。 欲了解详情，我们先得看看AsyncTask机制运用的线程池。在AsyncTask类里这样定义线程池成员的： private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 注意，线程池都是记在静态变量里的，它的生命期和进程的生命期基本一致。 细心的同学还记得，前文在定义AsyncTask派生类时，我们写的是private static class，大家不要忘记加static，否则就是写了一个普通内嵌类，而普通内嵌类对象内部会隐式地引用其外部类，这样当我们的task对象记入线程池后，就有可能导致task的外部类（很有可能是个Activity或Service）对象在较长时间内都不能被垃圾回收机制回收，从而导致内存泄漏。 本文的重点并不想太深入线程池的内部机理，我们只做必要的探讨即可。我们大体上只需知道线程池里的线程会执行FutureTask的run()函数即可。而FutureTask的run()代码如下：【java/util/concurrent/FutureTask.java】 public void run() { sync.innerRun(); } 而FutureTask.Sync的innerRun()代码如下： void innerRun() { if (!compareAndSetState(READY, RUNNING)) return; runner = Thread.currentThread(); if (getState() == RUNNING) { // recheck after setting thread V result; try { result = callable.call(); // 这一步间接调用到AsyncTask的doInBackground()。 } catch (Throwable ex) { setException(ex); return; } set(result); // 如果不出异常的话，会对call返回的结果执行set()操作。 } else { releaseShared(0); // cancel } } 其中会调用callable.call()，这一步就会间接调用到AsyncTask的doInBackground()。再接下来，如果不出异常的话，会对call()返回的结果执行set()操作。大家还记得前文WorkerRunnable实现的call()函数吗？它最后返回语句为：return postResult(result);现在设置的就是这个postResult对象。 FutureTask的set()函数的代码如下：【java/util/concurrent/FutureTask.java】 protected void set(V v) { sync.innerSet(v); } void innerSet(V v) { for (;;) { int s = getState(); if (s == RAN) return; if (s == CANCELLED) { releaseShared(0); return; } if (compareAndSetState(s, RAN)) { result = v; releaseShared(0); done(); return; } } } 结果记录进Sync类的result成员，然后回调FutureTask的done()函数，这也就回调到前文我们看到的AysncTask的mFuture的done()函数了。我们再列一下mFuture的代码：【frameworks/base/core/java/android/os/AsyncTask.java】 mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; done()里面做的无法一些善后处理。 private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } 2.2.2 AsyncTask里的mWorkerAsyncTask的另一个重要成员是mWorker， private final WorkerRunnable mWorker;除了在executeOnExecutor()里会为mWorker的mParams成员赋值外，AsyncTask一般不会直接操作mWorker。mWorker会间接记录进mFuture。当mFuture被回调时，系统会间接回调mWorker的call()成员函数，而这个call()函数是整个AsyncTask的核心行为。 现在我们可以画一张AsyncTask的示意图： 其实，当一个AsyncTask被安插进线程池时，线程池主要关心的是其mFuture成员引用的FutureTask。所以我们可以画出如下示意图： 当回调发生时，最终间接执行到mWorker成员的call()函数，在介绍AsyncTask的构造函数时，我们已经见过该函数的代码，现在再列一遍： mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 设为后台线程 //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); // ??? return postResult(result); } }; 看到了吗，当线程池里的某个线程回调到上面的call()函数时，会先把线程优先级设置为“后台线程”，然后会调用doInBackground()函数。大家还记得吧，前文说过我们在实现一个AsyncTask派生类时，主要重写的就是这个doInBackground()函数，现在终于派上用场了。 上面代码中还调用了一个不常见的函数：Binder.flushPendingCommands()。这个函数对应的注释是这样说的：（本函数）会将所有在当前线程里挂起的“Binder命令”扔回内核驱动。一般可以在执行那些有可能阻塞较长时间的操作之前调用一下该函数，这样可以确保挂起的对象引用被及时释放，避免“持有执行对象的进程”占据比“实际需要持有的时间”更长的时间。所以，我判断此处的调用多少有点儿问题，也许更合理的调用地方是在doInBackground()一句之前。 2.2.3 UI线程和AsyncTask工作线程之间的协作回调的call()函数最终还会通过postResult()，发回一条MESSAGE_POST_RESULT消息。postResult()的代码如下： private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 此处的getHandler()得到的实际是一个可向UI线程发送消息的handler（即AsyncTask的静态成员sHandler）。getHandler()的代码如下： private static Handler getHandler() { synchronized (AsyncTask.class) { if (sHandler == null) { sHandler = new InternalHandler(); } return sHandler; } } 这里搞了个类似单例的sHandler，类型为InternalHandler： private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); // 用于向UI线程发送消息！ } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 从InternalHandler的构造函数可以看到，postResult()最终就是向UI线程发回MESSAGE_POST_RESULT消息的。 当UI线程最终处理MESSAGE_POST_RESUTL消息时，会调用AsyncTask的finish()。 private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 另一方面，用户在编写doInBackground()时，还可以在合适时机调用publishProgress()，向UI线程发出MESSAGE_POST_PROGRESS消息。publishProgress()的代码如下： @WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); } } 这个消息同样被刚刚说到的InternalHandler处理，处理时会回调AsyncTask的onProgressUpdate()。 关于UI线程和执行AsyncTask的线程之间的交互，我们可以画一张示意图如下： 这张图反映了一个AsyncTask对象在运作时，大体上是如何被UI线程和工作线程调用执行的。 2.2.4 AsyncTask的内部状态细心的读者还会发现，AsyncTask在finish()时会把自己的状态置为Status.FINISHED。简单说来，AsyncTask可以处于3种状态，分别是PENDING、RUNNING、FINISHED。这3种状态的切换很简单，示意图如下： 2.2.5 cancel动作当然，用户还可以随时中途放弃执行当前任务。不管是在主线程处理MESSAGE_POST_PROGRESS时，还是在工作线程处理doInBackground()时，用户都可以调用cancel()函数。该函数的代码如下：【frameworks/base/core/java/android/os/AsyncTask.java】 public final boolean cancel(boolean mayInterruptIfRunning) { mCancelled.set(true); return mFuture.cancel(mayInterruptIfRunning); } 【java/util/concurrent/FutureTask.java】 public boolean cancel(boolean mayInterruptIfRunning) { return sync.innerCancel(mayInterruptIfRunning); } 【java/util/concurrent/FutureTask.java】 boolean innerCancel(boolean mayInterruptIfRunning) { for (;;) { int s = getState(); if (ranOrCancelled(s)) return false; if (compareAndSetState(s, CANCELLED)) break; } if (mayInterruptIfRunning) { Thread r = runner; if (r != null) r.interrupt(); } releaseShared(0); done(); return true; } 简单地说，cancel()动作会将mCancelled设为true，这样以后再调用isCancelled()时，就会返回true。前文我们已经看过AsyncTask的finish()的代码，现在再列一下： private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 可以看到，如果该任务是被用户cancel的，那么finish时执行的会是onCancelled()，而不是onPostExecute()。另外，为了确保在用户cancel任务之后，该任务能真的快速退出，我们应该在doInBackground()里周期性地检查一下isCancelled()的返回值，一旦发现，就立即退出。 2.3 线程退出在将当前任务加入到AsyncTask执行时，如果想取消可以直接调用cancel，进行取消。cancel会把没有具体进入线程中的这个任务给取消了，但如果当前任务已经在线程中执行，那么可以在当前任务中不断判断是否cancel了，如果cancel了就return，这样达到线程退出的目的。具体代码如下： @Override protected Void doInBackground(Void... voids) { if (isCancelled()) { return null; } // 耗时任务中依然要判断是否cancel了， for(int i = 0; i &lt; n; i++) { if (isCancelled()) { return null; } //TODO 原有循环内逻辑。 } return null; } 通过上面两个isCanceled进行判断，当当前任务cancel了，就能快速退出当前任务，避免不必要的消耗。 3 小结关于AsyncTask的知识，我们就先说这么多。现在大体总结一下：1）使用AsyncTask时，主要是重写其派生类的doInBackground()，而且该函数会在线程池的某个工作线程里被回调的；2）必须在UI线程调用AsyncTask的execute()或executeOnExecutor()；3）可以在doInBackground()里的合适时机调用publishProgress()，向UI线程通知工作进展；4）可以随时调用cancel()，放弃执行任务。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android学习","slug":"Android学习","permalink":"http://yoursite.com/tags/Android学习/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"DexClassLoader加载过程分析","slug":"DexClassLoader加载过程分析","date":"2017-12-27T10:02:07.000Z","updated":"2018-01-03T13:20:32.000Z","comments":true,"path":"2017/12/27/DexClassLoader加载过程分析/","link":"","permalink":"http://yoursite.com/2017/12/27/DexClassLoader加载过程分析/","excerpt":"","text":"在动态加载dex时，均采用的是DexClassLoader类进行加载，网上也有很多对如何加载进行分析的，现结合Android5.1源码进行分析。 实例先来看一个实例，实例完成动态加载SD卡上的一个jar包，在jar包中Toast一段话。 public class ToastTest { private Context context; public ToastTest(Context context){ this.context = context; } public void call() { Toast.makeText(context, &quot;call method&quot;, 0).show(); } public String getData() { return &quot;ToastTest&quot;; } } 将这个Java类打包生成test.jar包，然后放到SD目录下，然后利用DexClassLoader动态加载该jar包。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); File file = new File(Environment.getExternalStorageDirectory() .toString() + File.separator + &quot;test.jar&quot;); final File optimizedDexOutputPath = getDir(&quot;temp&quot;, Context.MODE_PRIVATE); /* * Parameters * dexPath 需要装载的APK或者Jar文件的路径。包含多个路径用File.pathSeparator间隔开,在Android上默认是 &quot;:&quot; * optimizedDirectory 优化后的dex文件存放目录，不能为null * libraryPath 目标类中使用的C/C++库的列表,每个目录用File.pathSeparator间隔开; 可以为 null * parent 该类装载器的父装载器，一般用当前执行类的装载器 */ new DexClassLoader(file.getAbsolutePath(), optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader()); //利用反射原理去调用 try { Class&lt;?&gt; testClass = classLoader.loadClass(&quot;com.demo.ToastTest&quot;); Constructor&lt;?&gt; istructor = testClass.getConstructor(Context.class); Method method = iclass.getMethod(&quot;call&quot;, null); String data = (String) method.invoke(istructor.newInstance(this), null); //System.out.println(data); Log.d(&quot;ToastTest&quot;,data); } catch (Exception e) { e.printStackTrace(); } } } 上面代码new DexClassLoader(file.getAbsolutePath(),optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader());完成了jar包的加载，下面从该步骤开始分析DexClassLoader是如何加载一个jar包或者dex的。 代码分析DexClassLoader类文件在\\libcore\\dalvik\\src\\main\\java\\dalvik\\system\\ DexClassLoader.java文件下 public class DexClassLoader extends BaseDexClassLoader { /** * Creates a {@code DexClassLoader} that finds interpreted and native * code. Interpreted classes are found in a set of DEX files contained * in Jar or APK files. * * &lt;p&gt;The path lists are separated using the character specified by the * {@code path.separator} system property, which defaults to {@code :}. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; must not be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } 代码很简单，直接调用了父类的构造方法。 public class BaseDexClassLoader extends ClassLoader { private final DexPathList pathList; /** * Constructs an instance. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; may be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } ... } 父类构造函数也很简单，首先调用了它自己的父类构造函数，然后new DaxPathList。下面先分析下DexPathList的构造函数。 /** * Constructs an instance. * * @param definingContext the context in which any as-yet unresolved * classes should be defined * @param dexPath list of dex/resource path elements, separated by * {@code File.pathSeparator} * @param libraryPath list of native library directory path elements, * separated by {@code File.pathSeparator} * @param optimizedDirectory directory where optimized {@code .dex} files * should be found and written to, or {@code null} to use the default * system directory for same */ public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) { if (definingContext == null) { throw new NullPointerException(&quot;definingContext == null&quot;); } if (dexPath == null) { throw new NullPointerException(&quot;dexPath == null&quot;); } if (optimizedDirectory != null) { if (!optimizedDirectory.exists()) { throw new IllegalArgumentException( &quot;optimizedDirectory doesn&#39;t exist: &quot; + optimizedDirectory); } if (!(optimizedDirectory.canRead() &amp;&amp; optimizedDirectory.canWrite())) { throw new IllegalArgumentException( &quot;optimizedDirectory not readable/writable: &quot; + optimizedDirectory); } } //前面做了一些检查和异常处理 this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); if (suppressedExceptions.size() &gt; 0) { this.dexElementsSuppressedExceptions = suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]); } else { dexElementsSuppressedExceptions = null; } this.nativeLibraryDirectories = splitLibraryPath(libraryPath); } 其中关键代码是makeDexElements /** * Makes an array of dex/resource path elements, one per element of * the given array. */ private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) { ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); /* * Open all files and load the (direct or contained) dex files * up front. */ for (File file : files) { File zip = null; DexFile dex = null; String name = file.getName(); //对每个文件进行处理 if (file.isDirectory()) { //如果是文件直接加入到elements中 // We support directories for looking up resources. // This is only useful for running libcore tests. elements.add(new Element(file, true, null, null)); } else if (file.isFile()){ if (name.endsWith(DEX_SUFFIX)) {//是dex // Raw dex file (not inside a zip/jar). try { dex = loadDexFile(file, optimizedDirectory); } catch (IOException ex) { System.logE(&quot;Unable to load dex file: &quot; + file, ex); } } else {//不是dex。即是压缩文件：jar zip apk zip = file; try { dex = loadDexFile(file, optimizedDirectory); } catch (IOException suppressed) { /* * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if * the zip file turns out to be resource-only (that is, no classes.dex file * in it). * Let dex == null and hang on to the exception to add to the tea-leaves for * when findClass returns null. */ suppressedExceptions.add(suppressed); } } } else { System.logW(&quot;ClassLoader referenced unknown path: &quot; + file); } if ((zip != null) || (dex != null)) { elements.add(new Element(file, false, zip, dex)); } } return elements.toArray(new Element[elements.size()]); } 先看DexPathList内部是如何解析dex文件的，即分析loadDexFile代码 /** * Constructs a {@code DexFile} instance, as appropriate depending * on whether {@code optimizedDirectory} is {@code null}. */ private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException { if (optimizedDirectory == null) { return new DexFile(file); } else { String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); } } 如果被优化后的路径是空，那么直接返回new DexFile(file)。optimizedPathFor是判断优化路径，代码如下： /** * Converts a dex/jar file path and an output directory to an * output file path for an associated optimized dex file. */ private static String optimizedPathFor(File path, File optimizedDirectory) { /* * Get the filename component of the path, and replace the * suffix with &quot;.dex&quot; if that&#39;s not already the suffix. * * We don&#39;t want to use &quot;.odex&quot;, because the build system uses * that for files that are paired with resource-only jar * files. If the VM can assume that there&#39;s no classes.dex in * the matching jar, it doesn&#39;t need to open the jar to check * for updated dependencies, providing a slight performance * boost at startup. The use of &quot;.dex&quot; here matches the use on * files in /data/dalvik-cache. */ String fileName = path.getName(); if (!fileName.endsWith(DEX_SUFFIX)) { int lastDot = fileName.lastIndexOf(&quot;.&quot;); if (lastDot &lt; 0) { fileName += DEX_SUFFIX; } else { StringBuilder sb = new StringBuilder(lastDot + 4); sb.append(fileName, 0, lastDot); sb.append(DEX_SUFFIX); fileName = sb.toString(); } } File result = new File(optimizedDirectory, fileName); return result.getPath(); } 真正执行代码优化的是DexFile.loadDex，代码如下： /** * Open a DEX file, specifying the file in which the optimized DEX * data should be written. If the optimized form exists and appears * to be current, it will be used; if not, the VM will attempt to * regenerate it. * * This is intended for use by applications that wish to download * and execute DEX files outside the usual application installation * mechanism. This function should not be called directly by an * application; instead, use a class loader such as * dalvik.system.DexClassLoader. * * @param sourcePathName * Jar or APK file with &quot;classes.dex&quot;. (May expand this to include * &quot;raw DEX&quot; in the future.) * @param outputPathName * File that will hold the optimized form of the DEX data. * @param flags * Enable optional features. (Currently none defined.) * @return * A new or previously-opened DexFile. * @throws IOException * If unable to open the source or output file. */ static public DexFile loadDex(String sourcePathName, String outputPathName, int flags) throws IOException { /* * TODO: we may want to cache previously-opened DexFile objects. * The cache would be synchronized with close(). This would help * us avoid mapping the same DEX more than once when an app * decided to open it multiple times. In practice this may not * be a real issue. */ return new DexFile(sourcePathName, outputPathName, flags); } 也就是直接返回了DexFile，下面看看DexFile构造函数做了哪些事情： /** * Opens a DEX file from a given filename, using a specified file * to hold the optimized data. * * @param sourceName * Jar or APK file with &quot;classes.dex&quot;. * @param outputName * File that will hold the optimized form of the DEX data. * @param flags * Enable optional features. */ private DexFile(String sourceName, String outputName, int flags) throws IOException { if (outputName != null) { try { String parent = new File(outputName).getParent(); if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) { throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent + &quot; is not owned by the current user. Shared storage cannot protect&quot; + &quot; your application from code injection attacks.&quot;); } } catch (ErrnoException ignored) { // assume we&#39;ll fail with a more contextual error later } } //前面是异常判断 mCookie = openDexFile(sourceName, outputName, flags); mFileName = sourceName; guard.open(&quot;close&quot;); //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName); } 关键代码:openDexFile /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ private static long openDexFile(String sourceName, String outputName, int flags) throws IOException { // Use absolute paths to enable the use of relative paths when testing on host. return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags); } /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ private static native long openDexFileNative(String sourceName, String outputName, int flags); 这里也就直接调用了native方法进行优化。继续跟进代码在\\dalvik\\vm\\native\\dalvik_system_DexFile.cpp文件中的openDexFileNative() 函数，接下重点就在这个函数： static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args, JValue* pResult) { //args[0]: sourceName java层传入的 //args[1]: outputName StringObject* sourceNameObj = (StringObject*) args[0]; StringObject* outputNameObj = (StringObject*) args[1]; DexOrJar* pDexOrJar = NULL; JarFile* pJarFile; RawDexFile* pRawDexFile; //DexOrJar* JarFile* RawDexFile* 目录 char* sourceName; char* outputName; //…… sourceName = dvmCreateCstrFromString(sourceNameObj); if (outputNameObj != NULL) outputName = dvmCreateCstrFromString(outputNameObj); else outputName = NULL; /*判断要加载的dex是否为系统中的dex文件 * gDvm ？？？ */ if (dvmClassPathContains(gDvm.bootClassPath, sourceName)) { ALOGW(&quot;Refusing to reopen boot DEX &#39;%s&#39;&quot;, sourceName); dvmThrowIOException( &quot;Re-opening BOOTCLASSPATH DEX files is not allowed&quot;); free(sourceName); free(outputName); RETURN_VOID(); } /* * Try to open it directly as a DEX if the name ends with &quot;.dex&quot;. * If that fails (or isn&#39;t tried in the first place), try it as a * Zip with a &quot;classes.dex&quot; inside. */ //判断sourcename扩展名是否是.dex if (hasDexExtension(sourceName) &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) == 0) { ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex = true; pDexOrJar-&gt;pRawDexFile = pRawDexFile; pDexOrJar-&gt;pDexMemory = NULL; //.jar文件 } else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) == 0) { ALOGV(&quot;Opening DEX file &#39;%s&#39; (Jar)&quot;, sourceName); pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex = false; pDexOrJar-&gt;pJarFile = pJarFile; pDexOrJar-&gt;pDexMemory = NULL; } else { //都不满足，抛出异常 ALOGV(&quot;Unable to open DEX file &#39;%s&#39;&quot;, sourceName); dvmThrowIOException(&quot;unable to open DEX file&quot;); } if (pDexOrJar != NULL) { pDexOrJar-&gt;fileName = sourceName; //把pDexOr这个结构体中的内容加到gDvm中的userDexFile结构的hash表中，便于Dalvik以后的查找 addToDexFileTable(pDexOrJar); } else { free(sourceName); } free(outputName); RETURN_PTR(pDexOrJar); } 再看对.dex文件的处理函数dvmRawDexFileOpen（\\dalvik\\vm\\RawDexFile.cpp）的处理 /* See documentation comment in header. */ int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName, RawDexFile** ppRawDexFile, bool isBootstrap) { DvmDex* pDvmDex = NULL; char* cachedName = NULL; int result = -1; int dexFd = -1; int optFd = -1; u4 modTime = 0; u4 adler32 = 0; size_t fileSize = 0; bool newFile = false; bool locked = false; dexFd = open(fileName, O_RDONLY); //打开dex文件 if (dexFd &lt; 0) goto bail; /* If we fork/exec into dexopt, don&#39;t let it inherit the open fd. */ dvmSetCloseOnExec(dexFd);//dexfd不继承 //校验dex文件的标志，将第8字节开始的4个字节赋值给adler32。 if (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0) { ALOGE(&quot;Error with header for %s&quot;, fileName); goto bail; } //得到dex文件的大小和修改时间，保存在modTime和filesize中 if (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; 0) { ALOGE(&quot;Error with stat for %s&quot;, fileName); goto bail; } //odexOutputName就是odex文件名，如果odexOutputName为空，则自动生成一个。 if (odexOutputName == NULL) { cachedName = dexOptGenerateCacheFileName(fileName, NULL); if (cachedName == NULL) goto bail; } else { cachedName = strdup(odexOutputName); } //主要是验证缓存文件名的正确性，之后将dexOptHeader结构写入fd中 optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime, adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true); locked = true; if (newFile) { u8 startWhen, copyWhen, endWhen; bool result; off_t dexOffset; dexOffset = lseek(optFd, 0, SEEK_CUR); //文件指针的位置 result = (dexOffset &gt; 0); if (result) { startWhen = dvmGetRelativeTimeUsec(); //将dex文件中的内容拷贝到当前odex文件，也就是dexOffset开始 result = copyFileToFile(optFd, dexFd, fileSize) == 0; copyWhen = dvmGetRelativeTimeUsec(); } if (result) { //优化odex文件 result = dvmOptimizeDexFile(optFd, dexOffset, fileSize, fileName, modTime, adler32, isBootstrap); } } /* * Map the cached version. This immediately rewinds the fd, so it * doesn&#39;t have to be seeked anywhere in particular. */ //将odex文件映射到内存空间(mmap)，并用mprotect将属性置为只读属性，并将映射的dex结构放在pDvmDex数据结构中，具体代码在下面。 if (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != 0) { ALOGI(&quot;Unable to map cached %s&quot;, fileName); goto bail; } …… } //Dalvik/vm/RewDexFile.cpp static int verifyMagicAndGetAdler32(int fd, u4 *adler32) { u1 headerStart[12]; ssize_t amt = read(fd, headerStart, sizeof(headerStart)); if (amt &lt; 0) { ALOGE(&quot;Unable to read header: %s&quot;, strerror(errno)); return -1; } if (amt != sizeof(headerStart)) { ALOGE(&quot;Unable to read full header (only got %d bytes)&quot;, (int) amt); return -1; } if (!dexHasValidMagic((DexHeader*) (void*) headerStart)) { return -1; } *adler32 = (u4) headerStart[8] | (((u4) headerStart[9]) &lt;&lt; 8) | (((u4) headerStart[10]) &lt;&lt; 16) | (((u4) headerStart[11]) &lt;&lt; 24); return 0; } //dalvik\\vm\\DvmDex.cpp /* * Given an open optimized DEX file, map it into read-only shared memory and * parse the contents. * * Returns nonzero on error. */ int dvmDexFileOpenFromFd(int fd, DvmDex** ppDvmDex) { DvmDex* pDvmDex; DexFile* pDexFile; MemMapping memMap; int parseFlags = kDexParseDefault; int result = -1; if (gDvm.verifyDexChecksum) parseFlags |= kDexParseVerifyChecksum; if (lseek(fd, 0, SEEK_SET) &lt; 0) { ALOGE(&quot;lseek rewind failed&quot;); goto bail; } //mmap映射fd文件,就是我们之前的odex文件 if (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != 0) { ALOGE(&quot;Unable to map file&quot;); goto bail; } pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags); if (pDexFile == NULL) { ALOGE(&quot;DEX parse failed&quot;); sysReleaseShmem(&amp;memMap); goto bail; } pDvmDex = allocateAuxStructures(pDexFile); if (pDvmDex == NULL) { dexFileFree(pDexFile); sysReleaseShmem(&amp;memMap); goto bail; } /* tuck this into the DexFile so it gets released later */ //将映射odex文件的内存拷贝到DvmDex的结构中 sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap); pDvmDex-&gt;isMappedReadOnly = true; *ppDvmDex = pDvmDex; result = 0; bail: return result; } /*dalvik\\libdex\\SysUtil.cpp */ int sysMapFileInShmemWritableReadOnly(int fd, MemMapping* pMap) { off_t start; size_t length; void* memPtr; assert(pMap != NULL); //获得文件长度和文件开始地址 if (getFileStartAndLength(fd, &amp;start, &amp;length) &lt; 0) return -1; //映射文件 memPtr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_FILE | MAP_PRIVATE, fd, start); //…… //将保护属性置为只读属性 if (mprotect(memPtr, length, PROT_READ) &lt; 0) { //……. } pMap-&gt;baseAddr = pMap-&gt;addr = memPtr; pMap-&gt;baseLength = pMap-&gt;length = length; return 0; //…… } 这些就是对dex的文件处理，对压缩包zip,jar,apk的有兴趣的可以直接分析下源码。 总结首先是对文件名的修正，后缀名置为”.dex”作为输出文件，然后生个一个DexPathList对象函数直接返回一个DexPathList对象， 在DexPathList的构造函数中调用makeDexElements()函数，在makeDexElement()函数中调用loadDexFile()开始对.dex或者是.jar .zip .apk文件进行处理， 跟入loadDexFile()函数中，会发现里面做的工作很简单，调用optimizedPathFor()函数对optimizedDiretcory路径进行修正。 之后才真正通过DexFile.loadDex()开始加载文件中的数据，其中的加载也只是返回一个DexFile对象。 在DexFile类的构造函数中，重点便放在了其调用的openDexFile()函数，在openDexFile()中调用了openDexFileNative()真正进入native层， 在openDexFileNative()的真正实现中，对于后缀名为.dex的文件或者其他文件(.jar .apk .zip)分开进行处理： .dex文件调用dvmRawDexFileOpen()；其他文件调用dvmJarFileOpen()。 在dvmRawDexFileOpen()函数中，检验dex文件的标志，检验odex文件的缓存名称，之后将dex文件拷贝到odex文件中，并对odex进行优化 调用dvmDexFileOpenFromFd()对优化后的odex文件进行映射，通过mprotect置为”只读”属性并将映射的内存结构保存在DvmDex*结构中。 dvmJarFileOpen()先对文件进行映射，结构保存在ZipArchive中，然后再尝试以文件名作为dex文件名来“打开”文件，如果失败，则调用dexZipFindEntry在ZipArchive的名称hash表中找名为”class.dex”的文件,然后创建odex文件，下面就和dvmRawDexFileOpen()一样了，就是对dex文件进行优化和映射。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Dex类加载","slug":"Dex类加载","permalink":"http://yoursite.com/tags/Dex类加载/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Hexo+GitHub搭建个人博客","slug":"Hexo-GitHub搭建个人博客","date":"2017-12-27T07:19:06.000Z","updated":"2018-01-03T13:20:32.000Z","comments":true,"path":"2017/12/27/Hexo-GitHub搭建个人博客/","link":"","permalink":"http://yoursite.com/2017/12/27/Hexo-GitHub搭建个人博客/","excerpt":"","text":"什么是HexoHexo是一个轻量级的博客，使用Markdown解析文章。上传到后台的是静态的网页，因而加载速度快。 Hexo和jekyll两者对比Hexo的主题更多，更好看。 安装使用Hexo 申请github账号免费申请，直接到GitHub官网上面申请。具体步骤参考：GitHub的注册与使用（详细图解） 安装Git，Node.js工具 Node.js安装好后执行以下命令 $ npm install hexo-cli -g npm是Node.js安装时自带的类库,是目前全球最大的类库之一,比Maven仓库还大,类似CentOS的yum源,Mac OX中brew的软件库 通过npm install可以直接安装基于Node.js的所有插件 创建站点 新建文件夹 mkdir blog 初始化站点 hexo init blog 安装npm插件支持 npm install 启动站点 hexo server通过上面就可以在http://localhost:4000/ 上查看生成的站点了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo搭建","slug":"Hexo搭建","permalink":"http://yoursite.com/tags/Hexo搭建/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2017-12-27T04:11:02.000Z","updated":"2018-01-03T13:20:32.000Z","comments":true,"path":"2017/12/27/hexo常用命令/","link":"","permalink":"http://yoursite.com/2017/12/27/hexo常用命令/","excerpt":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title:使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要以上是文章摘要","text":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title:使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要以上是文章摘要 以下是余下全文 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git解决方法 npm install hexo-deployer-git –save 2.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 DeploymentDocs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@.github.com:/*.github.io.git branch: master xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt RSS不显示安装RSS插件 npm install hexo-generator-feed –save 开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 开启评论 我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\\landscape\\layout_partial\\article.ejs把&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 改为&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&#39;&lt;%= config.disqus_shortname %&gt;&#39;}; (function() { var ds = document.createElement(&#39;script&#39;); ds.type = &#39;text/javascript&#39;;ds.async = true; ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;; ds.charset = &#39;UTF-8&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo学习","slug":"Hexo学习","permalink":"http://yoursite.com/tags/Hexo学习/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]}]}