{"meta":{"title":"天宇","subtitle":null,"description":null,"author":"黄天宇","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"DexClassLoader加载过程分析","slug":"DexClassLoader加载过程分析","date":"2017-12-27T10:02:07.000Z","updated":"2017-12-27T11:33:35.961Z","comments":true,"path":"2017/12/27/DexClassLoader加载过程分析/","link":"","permalink":"http://yoursite.com/2017/12/27/DexClassLoader加载过程分析/","excerpt":"","text":"在动态加载dex时，均采用的是DexClassLoader类进行加载，网上也有很多对如何加载进行分析的，现结合Android5.1源码进行分析。 实例先来看一个实例，实例完成动态加载SD卡上的一个jar包，在jar包中Toast一段话。 public class ToastTest { private Context context; public ToastTest(Context context){ this.context = context; } public void call() { Toast.makeText(context, &quot;call method&quot;, 0).show(); } public String getData() { return &quot;ToastTest&quot;; } } 将这个Java类打包生成test.jar包，然后放到SD目录下，然后利用DexClassLoader动态加载该jar包。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); File file = new File(Environment.getExternalStorageDirectory() .toString() + File.separator + &quot;test.jar&quot;); final File optimizedDexOutputPath = getDir(&quot;temp&quot;, Context.MODE_PRIVATE); /* * Parameters * dexPath 需要装载的APK或者Jar文件的路径。包含多个路径用File.pathSeparator间隔开,在Android上默认是 &quot;:&quot; * optimizedDirectory 优化后的dex文件存放目录，不能为null * libraryPath 目标类中使用的C/C++库的列表,每个目录用File.pathSeparator间隔开; 可以为 null * parent 该类装载器的父装载器，一般用当前执行类的装载器 */ new DexClassLoader(file.getAbsolutePath(), optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader()); //利用反射原理去调用 try { Class&lt;?&gt; testClass = classLoader.loadClass(&quot;com.demo.ToastTest&quot;); Constructor&lt;?&gt; istructor = testClass.getConstructor(Context.class); Method method = iclass.getMethod(&quot;call&quot;, null); String data = (String) method.invoke(istructor.newInstance(this), null); //System.out.println(data); Log.d(&quot;ToastTest&quot;,data); } catch (Exception e) { e.printStackTrace(); } } } 上面代码new DexClassLoader(file.getAbsolutePath(),optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader());完成了jar包的加载，下面从该步骤开始分析DexClassLoader是如何加载一个jar包或者dex的。 代码分析DexClassLoader类文件在\\libcore\\dalvik\\src\\main\\java\\dalvik\\system\\ DexClassLoader.java文件下 public class DexClassLoader extends BaseDexClassLoader { /** * Creates a {@code DexClassLoader} that finds interpreted and native * code. Interpreted classes are found in a set of DEX files contained * in Jar or APK files. * * &lt;p&gt;The path lists are separated using the character specified by the * {@code path.separator} system property, which defaults to {@code :}. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; must not be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } 代码很简单，直接调用了父类的构造方法。 public class BaseDexClassLoader extends ClassLoader { private final DexPathList pathList; /** * Constructs an instance. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; may be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } ... } 父类构造函数也很简单，首先调用了它自己的父类构造函数，然后new DaxPathList。下面先分析下DexPathList的构造函数。 /** * Constructs an instance. * * @param definingContext the context in which any as-yet unresolved * classes should be defined * @param dexPath list of dex/resource path elements, separated by * {@code File.pathSeparator} * @param libraryPath list of native library directory path elements, * separated by {@code File.pathSeparator} * @param optimizedDirectory directory where optimized {@code .dex} files * should be found and written to, or {@code null} to use the default * system directory for same */ public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) { if (definingContext == null) { throw new NullPointerException(&quot;definingContext == null&quot;); } if (dexPath == null) { throw new NullPointerException(&quot;dexPath == null&quot;); } if (optimizedDirectory != null) { if (!optimizedDirectory.exists()) { throw new IllegalArgumentException( &quot;optimizedDirectory doesn&#39;t exist: &quot; + optimizedDirectory); } if (!(optimizedDirectory.canRead() &amp;&amp; optimizedDirectory.canWrite())) { throw new IllegalArgumentException( &quot;optimizedDirectory not readable/writable: &quot; + optimizedDirectory); } } //前面做了一些检查和异常处理 this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); if (suppressedExceptions.size() &gt; 0) { this.dexElementsSuppressedExceptions = suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]); } else { dexElementsSuppressedExceptions = null; } this.nativeLibraryDirectories = splitLibraryPath(libraryPath); } 其中关键代码是makeDexElements /** * Makes an array of dex/resource path elements, one per element of * the given array. */ private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) { ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); /* * Open all files and load the (direct or contained) dex files * up front. */ for (File file : files) { File zip = null; DexFile dex = null; String name = file.getName(); //对每个文件进行处理 if (file.isDirectory()) { //如果是文件直接加入到elements中 // We support directories for looking up resources. // This is only useful for running libcore tests. elements.add(new Element(file, true, null, null)); } else if (file.isFile()){ if (name.endsWith(DEX_SUFFIX)) {//是dex // Raw dex file (not inside a zip/jar). try { dex = loadDexFile(file, optimizedDirectory); } catch (IOException ex) { System.logE(&quot;Unable to load dex file: &quot; + file, ex); } } else {//不是dex。即是压缩文件：jar zip apk zip = file; try { dex = loadDexFile(file, optimizedDirectory); } catch (IOException suppressed) { /* * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if * the zip file turns out to be resource-only (that is, no classes.dex file * in it). * Let dex == null and hang on to the exception to add to the tea-leaves for * when findClass returns null. */ suppressedExceptions.add(suppressed); } } } else { System.logW(&quot;ClassLoader referenced unknown path: &quot; + file); } if ((zip != null) || (dex != null)) { elements.add(new Element(file, false, zip, dex)); } } return elements.toArray(new Element[elements.size()]); } 先看DexPathList内部是如何解析dex文件的，即分析loadDexFile代码 /** * Constructs a {@code DexFile} instance, as appropriate depending * on whether {@code optimizedDirectory} is {@code null}. */ private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException { if (optimizedDirectory == null) { return new DexFile(file); } else { String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); } } 如果被优化后的路径是空，那么直接返回new DexFile(file)。optimizedPathFor是判断优化路径，代码如下： /** * Converts a dex/jar file path and an output directory to an * output file path for an associated optimized dex file. */ private static String optimizedPathFor(File path, File optimizedDirectory) { /* * Get the filename component of the path, and replace the * suffix with &quot;.dex&quot; if that&#39;s not already the suffix. * * We don&#39;t want to use &quot;.odex&quot;, because the build system uses * that for files that are paired with resource-only jar * files. If the VM can assume that there&#39;s no classes.dex in * the matching jar, it doesn&#39;t need to open the jar to check * for updated dependencies, providing a slight performance * boost at startup. The use of &quot;.dex&quot; here matches the use on * files in /data/dalvik-cache. */ String fileName = path.getName(); if (!fileName.endsWith(DEX_SUFFIX)) { int lastDot = fileName.lastIndexOf(&quot;.&quot;); if (lastDot &lt; 0) { fileName += DEX_SUFFIX; } else { StringBuilder sb = new StringBuilder(lastDot + 4); sb.append(fileName, 0, lastDot); sb.append(DEX_SUFFIX); fileName = sb.toString(); } } File result = new File(optimizedDirectory, fileName); return result.getPath(); } 真正执行代码优化的是DexFile.loadDex，代码如下： /** * Open a DEX file, specifying the file in which the optimized DEX * data should be written. If the optimized form exists and appears * to be current, it will be used; if not, the VM will attempt to * regenerate it. * * This is intended for use by applications that wish to download * and execute DEX files outside the usual application installation * mechanism. This function should not be called directly by an * application; instead, use a class loader such as * dalvik.system.DexClassLoader. * * @param sourcePathName * Jar or APK file with &quot;classes.dex&quot;. (May expand this to include * &quot;raw DEX&quot; in the future.) * @param outputPathName * File that will hold the optimized form of the DEX data. * @param flags * Enable optional features. (Currently none defined.) * @return * A new or previously-opened DexFile. * @throws IOException * If unable to open the source or output file. */ static public DexFile loadDex(String sourcePathName, String outputPathName, int flags) throws IOException { /* * TODO: we may want to cache previously-opened DexFile objects. * The cache would be synchronized with close(). This would help * us avoid mapping the same DEX more than once when an app * decided to open it multiple times. In practice this may not * be a real issue. */ return new DexFile(sourcePathName, outputPathName, flags); } 也就是直接返回了DexFile，下面看看DexFile构造函数做了哪些事情： /** * Opens a DEX file from a given filename, using a specified file * to hold the optimized data. * * @param sourceName * Jar or APK file with &quot;classes.dex&quot;. * @param outputName * File that will hold the optimized form of the DEX data. * @param flags * Enable optional features. */ private DexFile(String sourceName, String outputName, int flags) throws IOException { if (outputName != null) { try { String parent = new File(outputName).getParent(); if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) { throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent + &quot; is not owned by the current user. Shared storage cannot protect&quot; + &quot; your application from code injection attacks.&quot;); } } catch (ErrnoException ignored) { // assume we&#39;ll fail with a more contextual error later } } //前面是异常判断 mCookie = openDexFile(sourceName, outputName, flags); mFileName = sourceName; guard.open(&quot;close&quot;); //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName); } 关键代码:openDexFile /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ private static long openDexFile(String sourceName, String outputName, int flags) throws IOException { // Use absolute paths to enable the use of relative paths when testing on host. return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags); } /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ private static native long openDexFileNative(String sourceName, String outputName, int flags); 这里也就直接调用了native方法进行优化。继续跟进代码在\\dalvik\\vm\\native\\dalvik_system_DexFile.cpp文件中的openDexFileNative() 函数，接下重点就在这个函数： static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args, JValue* pResult) { //args[0]: sourceName java层传入的 //args[1]: outputName StringObject* sourceNameObj = (StringObject*) args[0]; StringObject* outputNameObj = (StringObject*) args[1]; DexOrJar* pDexOrJar = NULL; JarFile* pJarFile; RawDexFile* pRawDexFile; //DexOrJar* JarFile* RawDexFile* 目录 char* sourceName; char* outputName; //…… sourceName = dvmCreateCstrFromString(sourceNameObj); if (outputNameObj != NULL) outputName = dvmCreateCstrFromString(outputNameObj); else outputName = NULL; /*判断要加载的dex是否为系统中的dex文件 * gDvm ？？？ */ if (dvmClassPathContains(gDvm.bootClassPath, sourceName)) { ALOGW(&quot;Refusing to reopen boot DEX &#39;%s&#39;&quot;, sourceName); dvmThrowIOException( &quot;Re-opening BOOTCLASSPATH DEX files is not allowed&quot;); free(sourceName); free(outputName); RETURN_VOID(); } /* * Try to open it directly as a DEX if the name ends with &quot;.dex&quot;. * If that fails (or isn&#39;t tried in the first place), try it as a * Zip with a &quot;classes.dex&quot; inside. */ //判断sourcename扩展名是否是.dex if (hasDexExtension(sourceName) &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) == 0) { ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex = true; pDexOrJar-&gt;pRawDexFile = pRawDexFile; pDexOrJar-&gt;pDexMemory = NULL; //.jar文件 } else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) == 0) { ALOGV(&quot;Opening DEX file &#39;%s&#39; (Jar)&quot;, sourceName); pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex = false; pDexOrJar-&gt;pJarFile = pJarFile; pDexOrJar-&gt;pDexMemory = NULL; } else { //都不满足，抛出异常 ALOGV(&quot;Unable to open DEX file &#39;%s&#39;&quot;, sourceName); dvmThrowIOException(&quot;unable to open DEX file&quot;); } if (pDexOrJar != NULL) { pDexOrJar-&gt;fileName = sourceName; //把pDexOr这个结构体中的内容加到gDvm中的userDexFile结构的hash表中，便于Dalvik以后的查找 addToDexFileTable(pDexOrJar); } else { free(sourceName); } free(outputName); RETURN_PTR(pDexOrJar); } 再看对.dex文件的处理函数dvmRawDexFileOpen（\\dalvik\\vm\\RawDexFile.cpp）的处理 /* See documentation comment in header. */ int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName, RawDexFile** ppRawDexFile, bool isBootstrap) { DvmDex* pDvmDex = NULL; char* cachedName = NULL; int result = -1; int dexFd = -1; int optFd = -1; u4 modTime = 0; u4 adler32 = 0; size_t fileSize = 0; bool newFile = false; bool locked = false; dexFd = open(fileName, O_RDONLY); //打开dex文件 if (dexFd &lt; 0) goto bail; /* If we fork/exec into dexopt, don&#39;t let it inherit the open fd. */ dvmSetCloseOnExec(dexFd);//dexfd不继承 //校验dex文件的标志，将第8字节开始的4个字节赋值给adler32。 if (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0) { ALOGE(&quot;Error with header for %s&quot;, fileName); goto bail; } //得到dex文件的大小和修改时间，保存在modTime和filesize中 if (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; 0) { ALOGE(&quot;Error with stat for %s&quot;, fileName); goto bail; } //odexOutputName就是odex文件名，如果odexOutputName为空，则自动生成一个。 if (odexOutputName == NULL) { cachedName = dexOptGenerateCacheFileName(fileName, NULL); if (cachedName == NULL) goto bail; } else { cachedName = strdup(odexOutputName); } //主要是验证缓存文件名的正确性，之后将dexOptHeader结构写入fd中 optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime, adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true); locked = true; if (newFile) { u8 startWhen, copyWhen, endWhen; bool result; off_t dexOffset; dexOffset = lseek(optFd, 0, SEEK_CUR); //文件指针的位置 result = (dexOffset &gt; 0); if (result) { startWhen = dvmGetRelativeTimeUsec(); //将dex文件中的内容拷贝到当前odex文件，也就是dexOffset开始 result = copyFileToFile(optFd, dexFd, fileSize) == 0; copyWhen = dvmGetRelativeTimeUsec(); } if (result) { //优化odex文件 result = dvmOptimizeDexFile(optFd, dexOffset, fileSize, fileName, modTime, adler32, isBootstrap); } } /* * Map the cached version. This immediately rewinds the fd, so it * doesn&#39;t have to be seeked anywhere in particular. */ //将odex文件映射到内存空间(mmap)，并用mprotect将属性置为只读属性，并将映射的dex结构放在pDvmDex数据结构中，具体代码在下面。 if (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != 0) { ALOGI(&quot;Unable to map cached %s&quot;, fileName); goto bail; } …… } //Dalvik/vm/RewDexFile.cpp static int verifyMagicAndGetAdler32(int fd, u4 *adler32) { u1 headerStart[12]; ssize_t amt = read(fd, headerStart, sizeof(headerStart)); if (amt &lt; 0) { ALOGE(&quot;Unable to read header: %s&quot;, strerror(errno)); return -1; } if (amt != sizeof(headerStart)) { ALOGE(&quot;Unable to read full header (only got %d bytes)&quot;, (int) amt); return -1; } if (!dexHasValidMagic((DexHeader*) (void*) headerStart)) { return -1; } *adler32 = (u4) headerStart[8] | (((u4) headerStart[9]) &lt;&lt; 8) | (((u4) headerStart[10]) &lt;&lt; 16) | (((u4) headerStart[11]) &lt;&lt; 24); return 0; } //dalvik\\vm\\DvmDex.cpp /* * Given an open optimized DEX file, map it into read-only shared memory and * parse the contents. * * Returns nonzero on error. */ int dvmDexFileOpenFromFd(int fd, DvmDex** ppDvmDex) { DvmDex* pDvmDex; DexFile* pDexFile; MemMapping memMap; int parseFlags = kDexParseDefault; int result = -1; if (gDvm.verifyDexChecksum) parseFlags |= kDexParseVerifyChecksum; if (lseek(fd, 0, SEEK_SET) &lt; 0) { ALOGE(&quot;lseek rewind failed&quot;); goto bail; } //mmap映射fd文件,就是我们之前的odex文件 if (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != 0) { ALOGE(&quot;Unable to map file&quot;); goto bail; } pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags); if (pDexFile == NULL) { ALOGE(&quot;DEX parse failed&quot;); sysReleaseShmem(&amp;memMap); goto bail; } pDvmDex = allocateAuxStructures(pDexFile); if (pDvmDex == NULL) { dexFileFree(pDexFile); sysReleaseShmem(&amp;memMap); goto bail; } /* tuck this into the DexFile so it gets released later */ //将映射odex文件的内存拷贝到DvmDex的结构中 sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap); pDvmDex-&gt;isMappedReadOnly = true; *ppDvmDex = pDvmDex; result = 0; bail: return result; } /*dalvik\\libdex\\SysUtil.cpp */ int sysMapFileInShmemWritableReadOnly(int fd, MemMapping* pMap) { off_t start; size_t length; void* memPtr; assert(pMap != NULL); //获得文件长度和文件开始地址 if (getFileStartAndLength(fd, &amp;start, &amp;length) &lt; 0) return -1; //映射文件 memPtr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_FILE | MAP_PRIVATE, fd, start); //…… //将保护属性置为只读属性 if (mprotect(memPtr, length, PROT_READ) &lt; 0) { //……. } pMap-&gt;baseAddr = pMap-&gt;addr = memPtr; pMap-&gt;baseLength = pMap-&gt;length = length; return 0; //…… } 这些就是对dex的文件处理，对压缩包zip,jar,apk的有兴趣的可以直接分析下源码。 总结首先是对文件名的修正，后缀名置为”.dex”作为输出文件，然后生个一个DexPathList对象函数直接返回一个DexPathList对象， 在DexPathList的构造函数中调用makeDexElements()函数，在makeDexElement()函数中调用loadDexFile()开始对.dex或者是.jar .zip .apk文件进行处理， 跟入loadDexFile()函数中，会发现里面做的工作很简单，调用optimizedPathFor()函数对optimizedDiretcory路径进行修正。 之后才真正通过DexFile.loadDex()开始加载文件中的数据，其中的加载也只是返回一个DexFile对象。 在DexFile类的构造函数中，重点便放在了其调用的openDexFile()函数，在openDexFile()中调用了openDexFileNative()真正进入native层， 在openDexFileNative()的真正实现中，对于后缀名为.dex的文件或者其他文件(.jar .apk .zip)分开进行处理： .dex文件调用dvmRawDexFileOpen()；其他文件调用dvmJarFileOpen()。 在dvmRawDexFileOpen()函数中，检验dex文件的标志，检验odex文件的缓存名称，之后将dex文件拷贝到odex文件中，并对odex进行优化 调用dvmDexFileOpenFromFd()对优化后的odex文件进行映射，通过mprotect置为”只读”属性并将映射的内存结构保存在DvmDex*结构中。 dvmJarFileOpen()先对文件进行映射，结构保存在ZipArchive中，然后再尝试以文件名作为dex文件名来“打开”文件，如果失败，则调用dexZipFindEntry在ZipArchive的名称hash表中找名为”class.dex”的文件,然后创建odex文件，下面就和dvmRawDexFileOpen()一样了，就是对dex文件进行优化和映射。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Dex类加载","slug":"Dex类加载","permalink":"http://yoursite.com/tags/Dex类加载/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Hexo+GitHub搭建个人博客","slug":"Hexo-GitHub搭建个人博客","date":"2017-12-27T07:19:06.000Z","updated":"2017-12-27T07:33:42.940Z","comments":true,"path":"2017/12/27/Hexo-GitHub搭建个人博客/","link":"","permalink":"http://yoursite.com/2017/12/27/Hexo-GitHub搭建个人博客/","excerpt":"","text":"什么是HexoHexo是一个轻量级的博客，使用Markdown解析文章。上传到后台的是静态的网页，因而加载速度快。 Hexo和jekyll两者对比Hexo的主题更多，更好看。 安装使用Hexo 申请github账号免费申请，直接到GitHub官网上面申请。具体步骤参考：GitHub的注册与使用（详细图解） 安装Git，Node.js工具 Node.js安装好后执行以下命令 $ npm install hexo-cli -g npm是Node.js安装时自带的类库,是目前全球最大的类库之一,比Maven仓库还大,类似CentOS的yum源,Mac OX中brew的软件库 通过npm install可以直接安装基于Node.js的所有插件 创建站点 新建文件夹 mkdir blog 初始化站点 hexo init blog 安装npm插件支持 npm install 启动站点 hexo server通过上面就可以在http://localhost:4000/ 上查看生成的站点了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo搭建","slug":"Hexo搭建","permalink":"http://yoursite.com/tags/Hexo搭建/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2017-12-27T04:11:02.000Z","updated":"2017-12-27T10:54:24.857Z","comments":true,"path":"2017/12/27/hexo常用命令/","link":"","permalink":"http://yoursite.com/2017/12/27/hexo常用命令/","excerpt":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title:使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要以上是文章摘要","text":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title:使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要以上是文章摘要 以下是余下全文 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git解决方法 npm install hexo-deployer-git –save 2.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 DeploymentDocs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@.github.com:/*.github.io.git branch: master xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt RSS不显示安装RSS插件 npm install hexo-generator-feed –save 开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 开启评论 我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\\landscape\\layout_partial\\article.ejs把&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 改为&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&#39;&lt;%= config.disqus_shortname %&gt;&#39;}; (function() { var ds = document.createElement(&#39;script&#39;); ds.type = &#39;text/javascript&#39;;ds.async = true; ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;; ds.charset = &#39;UTF-8&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo学习","slug":"Hexo学习","permalink":"http://yoursite.com/tags/Hexo学习/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]}]}