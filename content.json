{"meta":{"title":"天宇","subtitle":null,"description":null,"author":"黄天宇","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-01-03T15:57:53.000Z","updated":"2018-01-03T16:23:53.000Z","comments":true,"path":"关于/index.html","permalink":"http://yoursite.com/关于/index.html","excerpt":"","text":"有志者事竟成，破釜沉舟，百二秦关终属楚； 苦心人天不负，卧薪尝胆，三千越甲可吞吴。 关于博主我是有远大志向，但又懒惰的Android系统开发工程师，当前博客是刚搭建的，还很不完善，以后想在本博客中多写些关于Android系统层面的知识，目前我也还在学习中，别学习边记录。再好的记忆，也不如用笔记下保存的长久。技术目标：Android全栈工程师，熟练编写JavaWeb服务端。微信号：MingTian–Hello微博号：tianyu240 博客历史2017.12.27, 搭建个人博客；2018.1.4, 编写关于"}],"posts":[{"title":"自定义控件View之onMeasure调用时机源码分析","slug":"自定义控件View之onMeasure调用时机源码分析","date":"2018-01-03T15:52:03.000Z","updated":"2018-01-03T15:53:14.000Z","comments":true,"path":"2018/01/03/自定义控件View之onMeasure调用时机源码分析/","link":"","permalink":"http://yoursite.com/2018/01/03/自定义控件View之onMeasure调用时机源码分析/","excerpt":"","text":"先上测试代码： MainActivity.java import android.app.Activity; import android.os.Bundle; import android.util.Log; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.e(&quot;hty&quot;, &quot;before setContextView&quot;); setContentView(R.layout.activity_main); Log.e(&quot;hty&quot;, &quot;after setContextView&quot;); } @Override protected void onResume() { super.onResume(); Log.e(&quot;hty&quot;, &quot;onResume&quot;); } @Override protected void onDestroy() { super.onDestroy(); Log.e(&quot;hty&quot;, &quot;onDestroy&quot;); } } MyView.java import android.content.Context; import android.graphics.Canvas; import android.graphics.Color; import android.graphics.Paint; import android.util.AttributeSet; import android.util.Log; import android.view.View; public class MyView extends View { Paint paint; public MyView(Context context) { this(context, null); } public MyView(Context context, AttributeSet attrs) { super(context, attrs); Log.e(&quot;hty&quot;,&quot;view constructor&quot;); paint = new Paint(); paint.setColor(Color.RED); paint.setTextSize(20); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); Log.e(&quot;hty&quot;,&quot;view onMeasure&quot;); } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); Log.e(&quot;hty&quot;,&quot;view onLayout&quot;); } String str = &quot;这里是测试&quot;; @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); Log.e(&quot;hty&quot;,&quot;view onDraw&quot;); canvas.drawText(str, getWidth()/2-paint.measureText(str)/2,getHeight()/2, paint); } } activity_main.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/activity_main&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; tools:context=&quot;com.zqc.mytest.MainActivity&quot;&gt; &lt;com.zqc.mytest.MyView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Hello World!&quot; /&gt; &lt;/RelativeLayout&gt; 正常运行后，查看对应的Log：从Log输出可以看出在一个View的绘制过程中，onMeasure是被多次调用了的。下面通过源码来一步步分析 onMeasure(int widthMeasureSpec, int heightMeasureSpec)函数，尤其是传过来的两个参数到底是从哪里来的。 首先看下MainActivity里面的setContentView，进入该函数后，其对应的代码如下： Activity.java public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 即调用了getWindow()的setContentView方法，查看getWindow方法，其返还的是类Window的一个实例mWindow，该类是一个抽象类，其具体实现类是PhoneWindow，即调用的是PhoneWindow的setContentView方法，查看相应的代码如下：PhoneWindow.java @Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 该方法首先判断mContentParent是否为空，不为空则调用installDecor()方法来初始化mContentParent，查看具体的代码：PhoneWindow.java private void installDecor() { if (mDecor == null) { mDecor = generateDecor();//这里生成了mDecor,它是所有应用窗口的根View 。 mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } if (mContentParent == null) { mContentParent = generateLayout(mDecor);//这里就生成了mContentParent，这个generateLayout会根据设定的style来布局显示的界面 // Set up decor part of UI to ignore fitsSystemWindows if appropriate. mDecor.makeOptionalFitsSystemWindows(); .... } } 其中generateDecor方法就直接返回一个DecorView，代码如下：PhoneWindow.java protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 而generateLayout(mDecor)方法会根据程序Activity设定的style来布局显示的界面，其代码如下：PhoneWindow.java protected ViewGroup generateLayout(DecorView decor) { // Apply data from current theme. TypedArray a = getWindowStyle();//获取窗口的style 。。。。 if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) { requestFeature(FEATURE_NO_TITLE);//看到没，你在xml里面设置的FEATURE_NO_TITLE，在这里生效了 } else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) { // Don&#39;t allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); } 。。。。 final Context context = getContext(); 。。。。 WindowManager.LayoutParams params = getAttributes(); if (!hasSoftInputMode()) { params.softInputMode = a.getInt( R.styleable.Window_windowSoftInputMode, params.softInputMode); } if (a.getBoolean(R.styleable.Window_backgroundDimEnabled, mIsFloating)) { /* All dialogs should have the window dimmed */ if ((getForcedWindowFlags()&amp;WindowManager.LayoutParams.FLAG_DIM_BEHIND) == 0) { params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND; } if (!haveDimAmount()) { params.dimAmount = a.getFloat( android.R.styleable.Window_backgroundDimAmount, 0.5f); } } 。。。。 int layoutResource; int features = getLocalFeatures(); 。。。。 View in = mLayoutInflater.inflate(layoutResource, null);//这里把给定的布局加载出来，然后加到decor中 decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//看到没这个ID_ANDROID_CONTENT，也就是一个窗口的根布局 if (contentParent == null) { throw new RuntimeException(&quot;Window couldn&#39;t find content container view&quot;); } 。。。。 mDecor.finishChanging(); return contentParent; } 通过一张图来分析下一个窗口的布局具体是怎样的。图上标的很详细，在最外层是一个FramLayout，其实也就是DecorView，是所有窗口的根布局，在该根布局下有一个(0)LinearLayout和一个(1)View，这个(1)View就是状态栏，(0)LinearLayout里面有个FrameLayout，在里面的多个View有固定的id，在图中已经标明，所有在一个Activity通过findViewById获取的ID_ANDROID_CONTENT就是(0)FrameLayout-&gt;(0)LinearLayout-&gt;(0)FrameLayout-&gt;(1)FrameLayout对应的View。要知道onMeasure两个参数到底是从哪里来的，还得再找下View是如何绘制的，上一篇文章有分析。View的绘制从ViewRootImpl的performTraversals()函数开始，下面进入该方法中具体分析下。 ViewRootImpl.java private void performTraversals() { // cache mView since it is used so much below... final View host = mView; 。。。。 mIsInTraversal = true; mWillDrawSoon = true; boolean windowSizeMayChange = false; boolean newSurface = false; boolean surfaceChanged = false; WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; final int viewVisibility = getHostVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility || mNewSurfaceNeeded; WindowManager.LayoutParams params = null; if (mWindowAttributesChanged) { mWindowAttributesChanged = false; surfaceChanged = true; params = lp; } 。。。。 Rect frame = mWinFrame; if (mFirst) { mFullRedrawNeeded = true; mLayoutRequested = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) { // NOTE -- system code, won&#39;t try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; } else { DisplayMetrics packageMetrics = mView.getContext().getResources().getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; } 。。。。 } else { desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) { if (DEBUG_ORIENTATION) Log.v(TAG, &quot;View &quot; + host + &quot; resized to: &quot; + frame); mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; } } if (viewVisibilityChanged) { mAttachInfo.mWindowVisibility = viewVisibility; host.dispatchWindowVisibilityChanged(viewVisibility); if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) { destroyHardwareResources(); } if (viewVisibility == View.GONE) { // After making a window gone, we will count it as being // shown for the first time the next time it gets focus. mHasHadWindowFocus = false; } } 。。。。 boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw); if (layoutRequested) { final Resources res = mView.getContext().getResources(); if (mFirst) { // make sure touch mode code executes by setting cached value // to opposite of the added touch mode. mAttachInfo.mInTouchMode = !mAddedTouchMode; ensureTouchModeLocally(mAddedTouchMode); } else { 。。。。 if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) { windowSizeMayChange = true; if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) { // NOTE -- system code, won&#39;t try to do compat mode. Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; } else { DisplayMetrics packageMetrics = res.getDisplayMetrics(); desiredWindowWidth = packageMetrics.widthPixels; desiredWindowHeight = packageMetrics.heightPixels; } } } // Ask host how big it wants to be windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); } 。。。。 if (!mStopped || mReportNextDraw) { boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) { int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);//获取 int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//看这里，看这里 // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight &gt; 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(TAG, &quot;And hey let&#39;s measure once more: width=&quot; + width + &quot; height=&quot; + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//看这里，看这里 } layoutRequested = true; } } } 。。。。 mIsInTraversal = false; } private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 看performTraversals方法中调用的performMeasure的地方，performMeasure即调用了View的measure方法，而measure方法会去调用onMeasure方法。看下如下两行代码 int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);//获取 int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); 在这两行代码中获取了child的宽高，使用的方法是getRootMeasureSpec，其中参数lp.width是传入的MATCH_PARENT或者WRAP_CONTENT，mWidth是窗口期望的大小，getRootMeasureSpec代码如下：ViewRootImpl.java private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&#39;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec; } 这里应该很好理解了，其中调用了MeasureSpec类中的方法，关于MeasureSpec类网上资料很多，该类中用一个int值的两部分分别表示Mode和具体的尺寸。其中最高两位表示 Mode，而最低的30位表示具体的尺寸值，这里计算完之后就进入了View的measure函数中，代码如下： View.java public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT || widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec) { // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension } 该方法是final的，因而不能被继承，但是里面提供了onMeasure回调，这样子类就可以直接继承onMeasure函数来实现相应的操作。这个View类型的，但是还有一种是ViewGroup类型，也就是容器类型的控件，在具体容器类型的控件里面可以通过重写onMeasure来实现，比如FrameLayout中的onMeasure函数如下：FrameLayout.java protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground&#39;s minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } } 大概也就是回调本容器里面的子View的measure函数实现尺寸计算。这里通过方法ViewGroup类中的getChildMeasureSpec()来获取子类期望自己获取的宽高大小。其代码是ViewGroup.java public static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&#39;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&#39;t be // bigger than us. resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } return MeasureSpec.makeMeasureSpec(resultSize, resultMode); } 在重写onMeasure方法时一定要调用setMeasuredDimension，该方法会将mPrivateFlags经过或使得View知道已经经过了measure这个步骤了。代码如下：View.java protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 至此分析结束，所以说一个View的大小是由自己和父类两者共同决定的。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"View onMeasure","slug":"View-onMeasure","permalink":"http://yoursite.com/tags/View-onMeasure/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"应用内存优化之OnLowMemory&OnTrimMemory","slug":"应用内存优化之OnLowMemory-OnTrimMemory","date":"2018-01-03T15:39:09.000Z","updated":"2018-01-03T15:41:49.000Z","comments":true,"path":"2018/01/03/应用内存优化之OnLowMemory-OnTrimMemory/","link":"","permalink":"http://yoursite.com/2018/01/03/应用内存优化之OnLowMemory-OnTrimMemory/","excerpt":"","text":"1.应用内存onLowMemory&amp; onTrimMemory优化onLowMemory&amp; onTrimMemory简介：OnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。OnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。根据不同的内存状态，来响应不同的内存释放策略。 1.1 onLowMemory&amp; onTrimMemory优化，需要释放什么资源？在内存紧张的时候，会回调OnLowMemory/OnTrimMemory，需要在回调方法中编写释放资源的代码。可以在资源紧张的时候，释放UI 使用的资源资：Bitmap、数组、控件资源。 1.2 OnLowMemoryOnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。系统提供的回调有：Application.onLowMemory()Activity.OnLowMemory()Fragement.OnLowMemory()Service.OnLowMemory()ContentProvider.OnLowMemory() 除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如： public static class MyCallback implements ComponentCallbacks { @Override public void onConfigurationChanged(Configuration arg) { } @Override public void onLowMemory() { //do release operation } 然后，通过Context.registerComponentCallbacks ()在合适的时候注册回调就可以了。通过这种自定义的方法，可以在很多地方注册回调，而不需要局限于系统提供的组件。onLowMemory 当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。 1.3 OnTrimMemoryOnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。系统提供的回调有：Application.onTrimMemory()Activity.onTrimMemory()Fragement.OnTrimMemory()Service.onTrimMemory()ContentProvider.OnTrimMemory()OnTrimMemory的参数是一个int数值，代表不同的内存状态：TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。以上4个是4.0增加TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存以上3个是4.1增加系统也提供了一个ComponentCallbacks2，通过Context.registerComponentCallbacks()注册后，就会被系统回调到。 1.4 OnLowMemory和OnTrimMemory的比较1，OnLowMemory被回调时，已经没有后台进程；而onTrimMemory被回调时，还有后台进程。2，OnLowMemory是在最后一个后台进程被杀时调用，一般情况是low memory killer 杀进程后触发；而OnTrimMemory的触发更频繁，每次计算进程优先级时，只要满足条件，都会触发。3，通过一键清理后，OnLowMemory不会被触发，而OnTrimMemory会被触发一次。 使用举例： @Override public void onTrimMemory(int level) { Log.e(TAG, &quot; onTrimMemory ... level:&quot; + level); } @Override public void onLowMemory() { Log.e(TAG, &quot; onLowMemory ... &quot;); } 2.系统回调优化2.1 回调原理：在Application、 Activity、Fragement、Service、ContentProvider中都可以重写回调方法，对OnLowMemory/OnTrimMemory进行回调，在回调方法中实现资源释放的实现。以Activity为例，在Activity源码中能够看到对于onTrimMemory的定义，因此在回调的时候重写方法即可。 public void onTrimMemory(int level) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onTrimMemory &quot; + this + &quot;: &quot; + level); mCalled = true; mFragments.dispatchTrimMemory(level); } 2.2 释放资源：在onTrimMemory释放资源，释放图片、数组、缓存等资源。 @Override public void onTrimMemory(int level) { // TODO Auto-generated method stub DLog.d(&quot; onTrimMemory ... level:&quot; + level); switch(level) { case TRIM_MEMORY_UI_HIDDEN: //释放资源 /*编写释放资源代码*/ } break; } super.onTrimMemory(level); } 下面是释放Bitmap的示例代码片段： 1 // 先判断是否已经回收 2 if(bitmap != null &amp;&amp; !bitmap.isRecycled()){ 3 // 回收并且置为null 4 bitmap.recycle(); 5 bitmap = null; 6 } 7 System.gc(); 复制代码 list占用方法： list.clear();然后在置空。 3.实现ComponentCallbacksOnLowMemory除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如： public static class ViewComponentCallbacks implements ComponentCallbacks { @Override public void onConfigurationChanged(Configuration arg) { } @Override public void onLowMemory() { //do release operation } } 注册自定义的回调类： ViewComponentCallbacks callBacks =new ViewComponentCallbacks(); this.registerComponentCallbacks( callBacks );回调之后，即可进行重写： @Override public void onLowMemory() { // TODO Auto-generated method stub //释放资源的方法 super.onLowMemory(); } Android onTrimMemory方法的一些疑惑？当你的app进程正在被cached时，你可能会接受到从onTrimMemory()中返回的下面的值之一: TRIM_MEMORY_BACKGROUND: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的app进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的app的时候才能够迅速恢复。TRIM_MEMORY_MODERATE: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。TRIM_MEMORY_COMPLETE: 系统正运行与低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的app恢复状态的资源。这个地方讲的进程正在被cache 是什么意思呢？是指我的进程 还没有结束 正在内存中 但是因为没有执行任何操作 不占有cpu的意思吗？此外当我们监听onTrimMemory回调方法的时候，假设我的缓存里最大的部分就是bitmap，请问就直接把bitmap从内存里抹去就可以了么？ 那如果这么做，在进程重新被加载到前台来的时候，我怎么迅速恢复这些bitmap资源？ 答疑答疑1：android进程回收主要涉及两个组件：ActivityManagerService（Ams）和lowmemorykiller。当手机内存不足时，lowmemorykiller就要开始杀进程了。但是lowmemorykiller呢只知道进程占用的内存大小，不知道进程对用户的重要性。Ams则负责管理android四大组件，当然知道进程的重要性了，所以呢还需要与Ams充分交换意见。 当app状态发生改变时，比如退到后台时，ams会对app的进程计算出一个值，即Oomadj（ams#computeOomAdjLocked），然后把这个值传给linux内核，lowmemorykiller呢就可以拿到这个值了，lowmemorykiller则就有了所有app进程的Oomadj值，即进程对用户的重要程度。当手机内存不足时，lowmemorykiller就有了足够的信息决定干掉哪个进程了。那，lowmemorykiller决定干掉哪个进程呢？这个要根据手机还有多少空闲内存，比如还有16MB空闲内存，如下lowmemorykiller.c static short lowmem_adj[6] = { 0, 1, 6, 12, }; static int lowmem_adj_size = 4; static int lowmem_minfree[6] = { 3 * 512, /* 6MB */ 2 * 1024, /* 8MB */ 4 * 1024, /* 16MB */ 16 * 1024, /* 64MB */ }; 16MB在lowmem_minfree第三个位置，取lowmem_adj第三个位置即6，ok所有Oomadj大于6的进程就被选中了。而lowmemorykiller不是把这些选中的进程都干掉，而是先干掉oomAdj最大而且占用内存最大的进程。如下lowmemorykiller.c#lowmem_scan： for_each_process(tsk) { ... oom_score_adj = p-&gt;signal-&gt;oom_score_adj; if (oom_score_adj &lt; min_score_adj) { task_unlock(p); continue; } tasksize = get_mm_rss(p-&gt;mm); task_unlock(p); if (tasksize &lt;= 0) continue; if (selected) { if (oom_score_adj &lt; selected_oom_score_adj) continue; if (oom_score_adj == selected_oom_score_adj &amp;&amp; tasksize &lt;= selected_tasksize) continue; } selected = p; selected_tasksize = tasksize; selected_oom_score_adj = oom_score_adj; } 总之一句话：进程对用户越不重要（Oomadj值就越大），占用内存越大，进程就越容易被干掉。 应对策略： 1 ams计算出一个危险的Oomadj值会调用onTrimMemory通知app，此时app应该把不重要的内存释放掉，只要比友商app占用的内存小被lowmemorykiller干掉的概率就小。 2 当然我们也可以先把忧伤的app干掉。。。帮用户释放内存（开玩笑啦） 3 如果我们的app能预置到手机中，并且manifest设置为persistence（Oomadj=0），或者coreserver则不必担心被lowmemorykiller干掉了。不过还有可能被linux层的oomkiller干掉的。当然这也是某些手机预置一堆app导致越用越慢的一个原因，所以我们尽量把这些预置app卸载掉。 答疑2：理解进程和组件之间的关系 一般来说，你的App在启动的时候，系统都会为你的APP创建一个进程。 比如我有一个App，其包名为com.performance.liferecord 当这个App启动的时候，我们可以通过ps命令来看其对应的进程 信息： 结果如下： USER PID PPID VSIZE RSS WCHAN PC NAME 可以看到系统为这个进程分配的PD是32452，那么 PPID是什么呐？ 使用PS命令来看：adb shell ps | grep 379 可以看到PPID的NAME是zygote64，也就是说32452这个进程是从Android的zygote64这个进程fork过来的。 那么 组件又是怎么回事呐？我们常说四大组件，Activity、Service、Broadcast、ContentProvider。这些个组件都是依附于一个进程来运行的，一个进程可以有多个Activity、Service等，也可以一个组件都没有。 Cache状态 当你的应用程序到了后台之后，会进入Cached状态，这时候进程还存在，但是组件是否存在就不一定了。 不过一般我们认为，当你按Back键回到桌面之后，如果Activity没有被释放，那么我们认为了内容泄漏，这个有兴趣可以自己看看。 以上面我提到的com.performance.liferecord这个应用为例子，当我启动这个应用之后，我们可以使用命令adb shell dumpsys meminfo来查看整个系统的状态，此时com.performance.liferecord这个进程状态为Foreground: Foreground意味着此时你的进程处于前台进程，你的程序的界面可以被用户看到。此时我们使用adb shell dumpsys meminfo com.preformance.liferecord来看这个进程的状态： 可以看到Activity的数量为1（因为我只起了一个Activity） 当我们点击Back键的时候，我们可以使用命令adb shell dumpsys meminfo来查看 整个系统的状态，此时com.performance.liferecord这个进程状态为Cached: Cached状态标识你的应用进程变成了后台进程，位于LRU list里面。 此时我们使用adb shell dumpsys meminfo com.performance.liferecord来看这个进程的状态： Activity的数量妥妥变成0了，说明没有内存泄漏。此时你的进程里面，是没有任何组件的。当然也不占用cpu的资源，但是会点内存（例子中我们可以看到占用了20706kb）的内存。 将后台进程放到Cached列表里而不是直接杀掉，其好处就是下一次这个进程的某个组件（最常见的就是Activity）启动的时候，不需要再创建新的进程 ，速度杠杠的（比如就应用的热启动）。 onTrimMemory 此外当我们监听onTrimMemory回调方法的时候，假设我的缓存里最大的部分就是bitmap，请问就直接把bitmap从内存里抹去就可以了么？ 那如果这么做，在进程重新被加载到前台来的时候，我怎么迅速恢复这些bitmap资源？ 如答疑1所述： 对于 图片，一般采用三层缓存机制，即内存、文件、网络、释放内存后从文件中读取就好 一般的图片加载库都会提供内存/文件的缓存，即使内存中的Bitmap清除掉了，下一次从文件中读取也会很快的。 至少onTrimMemory的优点，比如你的应用Cache了20MB的Bitmap没有清除，当手机内存不足的时候，如果你没有及时释放 这些内存，那么 很可能你的进程 就被系统给杀掉了，这会你的Bitmap当然也就没了。用户下次启动你的应用的时候，我曹这货又被杀了，这手机系统有毛病吧？ 是吧。。。做系统的还得背这个锅！ 关于onTrimMemory的使用，可以参考博客http://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory.html","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"内存优化","slug":"内存优化","permalink":"http://yoursite.com/tags/内存优化/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"RoboBinding(MVVM)架构介绍","slug":"RoboBinding-MVVM-架构介绍","date":"2018-01-03T15:08:14.000Z","updated":"2018-01-03T15:09:15.000Z","comments":true,"path":"2018/01/03/RoboBinding-MVVM-架构介绍/","link":"","permalink":"http://yoursite.com/2018/01/03/RoboBinding-MVVM-架构介绍/","excerpt":"","text":"[TOC] 1. 什么是RoboBinding?同步差异 - RoboBinding 是一个数据绑定器。 Presentation Model framework（著名的MVVM框架）是安卓上的一个框架. RoboBinding帮助你在写UI代码时能方便的阅读、测试和维护。 2.AndroidMVVM(Presentation Model)框架通过RoboBinding建立的一个activity由三个部分组成：layout布局，activity类，还有一个演示模型类。这里有个简单的事例AndroidMVVM。 2.1. Layout布局在布局文件总，我们声明一下RoboBinding的命名空间，属性和一些事件的attribute绑定。例如activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:bind=&quot;http://robobinding.org/android&quot;&gt; &lt;TextView bind:text=&quot;{hello}&quot; /&gt; ... &lt;Button android:text=&quot;Say Hello&quot; bind:onClick=&quot;sayHello&quot;/&gt; &lt;/LinearLayout&gt; 2.2. Presentation Model(简单的Java对象)在演示层中，我们声明一个对应的属性和方法。代码如下org.robobinding.androidmvvm.PresentationModel.java org.robobinding.annotation.PresentationModel public class PresentationModel implements HasPresentationModelChangeSupport { private String name; public String getHello() { return name + &quot;: hello Android MVVM(Presentation Model)!&quot;; } ... public void sayHello() { firePropertyChange(&quot;hello&quot;); } } 2.3. Activity类通过RoboBinding框架将布局和演示层的model绑定在activity界面上。org.robobinding.androidmvvm.MainActivity.java public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { ... PresentationModel presentationModel = new PresentationModel(); View rootView = Binders.inflateAndBindWithoutPreInitializingViews(this, R.layout.activity_main, presentationModel); setContentView(rootView); } } 这样一个简单的AndroidMVVM事例就写完了。我们使用工具类Binders将UI空间和数据Model很简单的进行绑定。在真正使用时我们推荐使用org.robobinding.binder.BinderFactoryBuilder类。我们可以将BinderFactoryBuilder以单例模式保存在整个工程中，也可以使用第三方法库，例如 RoboGuice ，来帮忙管理BinderFactory对象实例，这样可以在全局共享和重复使用该实例。 2.4. 介绍视频2012年2月 Robert Taylor 录了一个介绍RoboBinding的视频，下载地址.2014年7月Cheng Wei录了一个中文的介绍视频，下载地址. 3. 环境设置3.1. Eclipse下安装使用安装Eclipse. 3.1.1. 没有AspectJ时将robobinding-[version]-with-dependencies.jar 或者robobinding-[version].jar + [google guava]-[11.0.1+].jar 放到工程的libs目录下，然后把他们添加到classpath上。点击顺序： project→Properties→Java Build Path→Libraries→Add JARs.在展开的列表上点击对应的jar包。 3.1.2. 在有AspectJ时RoboBinding能帮我们减少一些自动绑定的代码。首先安装Android Development Tools 插件。然后右击项目→Configure→Convert to AspectJ Project. 这样就可以将AspectJ特性加入到项目当中。按同样的方法将 robobinding-[version]-with-aop-and-dependencies.jar 或者 the robobinding-[version]-with-aop.jar + [google guava]-[11.0.1+].jar加入的libs目录下，然后添加的项目的classpath中。最后确保RoboBinding的jar是加入到Aspect路径中，具体方法如下： 3.1.3. Annotaton Processing 设置下载RoboBindingcodegen-[version]-with-dependencies.jar的jar包。按如下方式添加到工程，注意项目不要依赖这个jar。 3.2. Android Studio安装方法3.2.1. 没有AspectJ时将robobinding依赖添加到gradle.build中。 dependencies { ... compile&quot;org.robobinding:robobinding:${robobindingVersion}&quot; //alternatively we can use with-dependencies jar(RoboBinding provide a minimal Proguarded with-dependencies jar.). compile(&quot;org.robobinding:robobinding:${robobindingVersion}:with-dependencies&quot;) { exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39; } } RoboBinding是完全免费的，可以随意引用,例如：AndroidMVVM, RoboBinding-album-sample 和 RoboBinding-gallery. 3.2.2. 有AspectJ时在gradle.build中应用RoboBinding的Android aspcetj插件。 buildscript { repositories { ... maven() { name &#39;RoboBinding AspectJPlugin Maven Repository&#39; url &quot;https://github.com/RoboBinding/RoboBinding-aspectj-plugin/raw/master/mavenRepo&quot; } } dependencies { ... classpath &#39;org.robobinding:aspectj-plugin:0.8.+&#39; } } ... apply plugin: &#39;org.robobinding.android-aspectj&#39; 添加RoboBinding 依赖到 gradle.build中 dependencies { ... compile &quot;org.robobinding:robobinding:$robobindingVersion&quot; aspectPath &quot;org.robobinding:robobinding:$robobindingVersion&quot; //alternatively we can use with-aop-and-dependencies jar(RoboBinding provides a minimal Proguarded with-aop-and-dependencies jar.). compile (&quot;org.robobinding:robobinding:$robobindingVersion:with-aop-and-dependencies&quot;) { exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39; } aspectPath (&quot;org.robobinding:robobinding:$robobindingVersion:with-aop-and-dependencies&quot;) { exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39; } } RoboBinding是完全免费的，可以随意引用,例如：AndroidMVVM, RoboBinding-album-sample 和 RoboBinding-gallery. 3.2.3. Annotation Processing 设置在gradle.build中添加apt插件。 buildscript { repositories { ... } dependencies { ... classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.+&#39; } } ... apply plugin: &#39;com.neenbedankt.android-apt&#39; 3.3. ProGuard设置在proguard中需要保存PresentationModel和生成的构造方法，我们也需要保存所以的注解。在proguard配置中进行如下设置： -keepattributes *Annotation*,Signature -keep,allowobfuscation @interface org.robobinding.annotation.PresentationModel -keep @org.robobinding.annotation.PresentationModel class * { public *** *(...); } -keep class * implements org.robobinding.itempresentationmodel.ItemPresentationModel{ public *** *(...); } -keep class * extends org.robobinding.presentationmodel.AbstractPresentationModelObject{ public &lt;init&gt;(...); } -keep class * extends org.robobinding.presentationmodel.AbstractItemPresentationModelObject{ public &lt;init&gt;(...); } 添加如下几行以便保持view监听的构造函数。 -keepclassmembers class * implements org.robobinding.viewattribute.ViewListeners { public &lt;init&gt;(...); } 添加如下几行来抑制Google的javax.annotation.XX 引用警告。 -dontwarn javax.annotation.** 在如下链接中有相关样例 RoboBinding organization. 4. 概念和特性一个安卓应用中包含若干个activity界面和其他一些元素。在以RoboBinding架构编写的安卓应用中，一个activity包含一个activity类，一个layout布局和一个PresentationModel的普通类（而在普通安卓应用中，一个activity仅仅包含activity类和layout布局文件）。原先都在Activity类中编写展示逻辑的现在都提取到一个独立PresentationModel的简单类中。布局中视图控件的展示数据都绑定在PresentationModel的属性上，视图控件的各个事件都绑定在PresentationModel的方法上。RoboBinding可以帮助我们减少或者删除在Activity类中的UI相关代码，通过简单的在layout布局进行绑定。理想的PresentationModel仅仅包含UI展示逻辑，不包含UI代码或者UI连接代码，并且能够被单独的、简单的测试。这部分样例代码可以通过如下链接查看Robobinding Gallery. 4.1. 单向属性绑定当我们将一根属性绑定到一个presentation模型时，任何对该属性的更改都会直接传给相应的View。activity_view.xml &lt;TextView bind:visibility=&quot;{integerVisibility}&quot;/&gt; ViewPresentationModel.java public int getIntegerVisibility() { return integerVisibilityRotation.value(); } robobinding遵循JavaBeans规范也提供getters和setters方法。在单方向绑定中，仅仅需要提供getters方法，即view的任何改变不需要更新给对应的presentation模型。更多关于属性绑定的内容可以参考API和属性绑定文档 4.2. 双向属性绑定双方向属性绑定顾名思义就是对presentation model的任何改变会反映到对应的view上，同时对view的任何改变也会更改对应的presentation Model。EditText控件中的text属性是支持双向绑定的。考虑这种情况，无论何时用户更改了EditText的text内容，对应的presentation Model都会相应的进行更改。双向属性绑定仅仅需要在大括号外加一个美元$符，例如：activity_edittext.xml &lt;EditText bind:text=&quot;${text}&quot;/&gt; 为了支持双向绑定，需要在对应的presentation model中添加setter方法：org.robobinding.gallery.presentationmodel.EditTextPresentationModel.java PresentationModel public class EditTextPresentationModel { private String text; public String getText() { return text; } public void setText(String text) { this.text = text; } } 4.3. 事件绑定将view的事件绑定到presentation model的方法上，可以通过bind:onClick=”showDemo”来实现。activity_gallery.xml &lt;Button bind:onClick=&quot;showDemo&quot;/&gt; org.robobinding.gallery.presentationmodel.GalleryPresentationModel.java PresentationModel public class GalleryPresentationModel { ... public void showDemo() { ... } } 当点击事件被触发时，presentation Model绑定的方法将被执行。我们能选择性的支持一个事件的参数，在上面例子中对应的参数是org.robobinding.widget.view.ClickEvent更多关于UI事件绑定可以参考API和属性绑定文档 4.4. AdapterViews的绑定当我们绑定一个AdapterViews时，RoboBinding首先要求我们指出对于presentation model基础的数据。可以是以下几个类型：an Array, List or org.robobinding.itempresentationmodel.TypedCursor.在有基础数据后，RoboBinding需要知道presentation模型和子view对应的绑定关系。我们可以通过 @ItemPresentationModel注解实现。例如：activity_adapter_view.xml &lt;ListView bind:itemLayout=&quot;@android:layout/simple_list_item_1&quot; bind:itemMapping=&quot;[text1.text:{value}]&quot; bind:source=&quot;{dynamicStrings}&quot;/&gt; org.robobinding.gallery.presentationmodel.AdapterViewPresentationModel.java PresentationModel public class AdapterViewPresentationModel { ... @ItemPresentationModel(value=StringItemPresentationModel.class) public List&lt;String&gt; getDynamicStrings() { return getSelectedSource().getSample(); } ··· 提供的基础数据需要继承自ItemPresentationModel 接口。org.robobinding.gallery.presentationmodel.StringItemPresentationModel.java public class StringItemPresentationModel implements ItemPresentationModel&lt;String&gt; { private String value; @Override public void updateData(int index, String bean) { value = bean; } public String getValue() { return value; } } 然后我们给每一个条目行定义一个布局。在该例中我们使用Android库给的simple_list_item_1.xml布局。通过bind:itemMapping=”[text1.text:{value}]”进行绑定我们将simple_list_item_1.xml中的text1.text绑定到StringItemPresentationModel.value中。在@ItemPresentationModel中有一个工厂方法属性(factoryMethod)。当ItemPresentationModels有一些扩展的依赖时，我们能增加一个工厂方法(factoryMethod)到PresentationModel里面以便ItemPresentationModels能通过该方法进行创建。通过这种方式，我们能将任何依赖让到ItemPresentationModel中，通过完全自由的方式。下面是一个简单的例子。 @PresentationModel public class PresentationModelSample { ... @ItemPresentationModel(value=ItemPresentationModelSample.class, factoryMethod=&quot;createItemPresentationModelSample&quot;) public List&lt;String&gt; getDynamicStrings() { return getSelectedSource().getSample(); } public ItemPresentationModelSample createItemPresentationModelSample() { return ItemPresentationModelSample(dependency1, dependency2, ...); } 4.5. 轻量级关系cursor游标映射对应的对象cursor游标在AdapterViews绑定中提到数据类型org.robobinding.itempresentationmod el.TypedCursor。由于我们经常操作对象甚过操作对象数据，因而我们希望能将操作关系数据库的代码进行分离。RoboBinding增加了一个轻量级的对象cursor游标-TypedCursor。通过org.robobinding.itempresentationmodel.RowMapper类，我们能将一条数据转换为一个对象。示例如下：org.robobinding.gallery.presentationmodel.TypedCursorPresentationModel.java @PresentationModel public class TypedCursorPresentationModel { ... @ItemPresentationModel(value=ProductItemPresentationModel.class) public TypedCursor&lt;Product&gt; getProducts() { return allProductsQuery.execute(db); } } org.robobinding.gallery.model.typedcursor.GetAllQuery.java public class GetAllQuery&lt;T&gt; { private String tableName; private final RowMapper&lt;T&gt; rowMapper; public GetAllQuery(String tableName, RowMapper&lt;T&gt; rowMapper) { ... this.tableName = tableName; this.rowMapper = rowMapper; } public TypedCursor&lt;T&gt; execute(SQLiteDatabase db) { Cursor cursor = db.query( tableName, null, null, null, null, null, BaseColumns._ID+&quot; ASC&quot;); return new TypedCursorAdapter&lt;T&gt;(cursor, rowMapper); } } org.robobinding.gallery.model.typedcursor.ProductRowMapper.java public class ProductRowMapper implements RowMapper&lt;Product&gt; { @Override public Product mapRow(Cursor cursor) { String name = cursor.getString(cursor.getColumnIndex(ProductTable.NAME)); String description = cursor.getString(cursor.getColumnIndex(ProductTable.DESCRIPTION)); return new Product(name, description); } } 4.6. 菜单绑定将一个res/menu中的菜单资源绑定到一个Presentation Models中。看如下例子：res/menu/context_menu.xml &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://robobinding.org/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:title=&quot;Delete Product&quot; bind:onMenuItemClick=&quot;deleteProduct&quot; android:id=&quot;@+id/deleteProduct&quot; app:showAsAction=&quot;always&quot;/&gt; &lt;/menu&gt; org.robobinding.gallery.presentationmodel.ContextMenuPresentationModel.java @PresentationModel public class ContextMenuPresentationModel { ... public void deleteProduct(MenuItem menuItem) { ... } } 4.7. Presentation Models（演示models）我们将任何一个presentationModel添加@org.robobinding.annotation.PresentationModel注解。当一个presentationmodel需要org.robobinding.presentationmodel.PresentationModelChangeSupport支持时，presentationmodel必须继承自org.robobinding.presentationmodel.HasPresentationModelChangeSupport 接口，以便于框架层能在内部使用PresentationModelChangeSupport对象。 有两种方式可以实现一个Presentationmodel，一个是有AspectJ时，一个是没有AspectJ时， 4.7.1.没有 AspectJ 使用robobinding-[version].jar或者robobinding-[version]-with-dependencies.jar库 这种方式的好处是没有额外的依赖，可以使最终的apk尽可能的小 不好的地方在我们需要手动设置每一个firePropertyChange(“propertyName”).以下有具体的样例AndroidMVVM 和 Android-CleanArchitecture 4.7.2. 有 AspectJ 使用robobinding-[version]-with-aop.jar 或者robobinding-[version]-with-aop-and-dependencies.jar库 好处是许多firePropertyChange(“propertyName”) 可以自动生成 不好的地方是在AspectJ运行库里面包含依赖，这轻微的增加了最终apk的大小。以下是具体样例Album Sample 和 Gallery 5. 创造我们自己的view绑定这一节的样例代码是： Robobinding Gallery. 5.1. 单向绑定在如下的例子中我们增加了View的enable属性绑定- source code. @ViewBinding(simpleOneWayProperties = {&quot;enabled&quot;}) public class ViewBindingForView extends CustomViewBinding&lt;View&gt; { } 然后添加到 BinderFactoryBuilder - source code. new BinderFactoryBuilder() .add(new ViewBindingForView().extend(View.class)) .build(); RoboBinding能够生成如下代码： public class ViewBindingForView$$VB implements ViewBinding&lt;View&gt;{ final ViewBindingForView customViewBinding; public ViewBindingForView$$VB(ViewBindingForView customViewBinding) { this.customViewBinding = customViewBinding; } @Override public void mapBindingAttributes(BindingAttributeMappings&lt;View&gt; mappings) { mappings.mapOneWayProperty(ViewBindingForView$$VB.EnabledAttribute.class, &quot;enabled&quot;); customViewBinding.mapBindingAttributes(mappings); } public static class EnabledAttribute implements OneWayPropertyViewAttribute&lt;View, Boolean&gt; { @Override public void updateView(View view, Boolean newValue) { view.setEnabled(newValue); } } } 所以的绑定都是静态static的，这意味着每一性能的影响。 5.2. 其他类型的绑定除了单向属性绑定外，这里还有事件event绑定，多类型属性绑定和其他组属性类型的绑定。为了能实现这些绑定，我们需要扩展CustomViewBinding和手动实现对应的继承。具体例子如下： @ViewBinding public class MyCustomViewBinding extends CustomViewBinding&lt;CustomView&gt; { @Override public void mapBindingAttributes(BindingAttributeMappings&lt;CustomView&gt; mappings) { mappings.mapEvent(OnCustomEventAttribute.class, &quot;onCustomEvent&quot;); } public class OnCustomEventAttribute implements EventViewAttributeForView { ... } } 对于这些绑定，我们能在如下链接找到例子：- source code under widget package. 5.3. 自定义控件或者第三方控件我们能对于任何自定义控件、第三方控件、Android widgets创建view绑定，以便更容易的使用它们。在RoboBinding中，这些绑定是一样的。 下面是一个简单的自定义控件的例子，该View有一个白色的边框。这个控件有一个标题和一个描述组成。当我们输入新的标题和描述后，然后点击应用（Apply），控件自己讲对于的更新。 这个需求可以用以下简单的代码实现：activity_custom_component.xml &lt;org.robobinding.gallery.model.customcomponent.TitleDescriptionBar bind:title=&quot;{title}&quot; bind:description=&quot;{description}&quot;/&gt; 这个TitleDescriptionBar控件的代码如下：(对于如何实现一个自定义控件，参考如下：Android Reference): public class TitleDescriptionBar extends LinearLayout { private TextView title; private TextView description; public TitleDescriptionBar(Context context, AttributeSet attrs) { this(context, attrs, R.layout.title_description_bar); } protected TitleDescriptionBar(Context context, AttributeSet attrs, int layoutId) { super(context, attrs); LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); inflater.inflate(layoutId, this); title = (TextView) findViewById(R.id.title); description = (TextView) findViewById(R.id.description); ... } public void setTitle(CharSequence titleText) { title.setText(titleText); } public void setDescription(CharSequence descriptionText) { description.setText(descriptionText); } } 对于的布局是： title_description_bar.xml: &lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://robobinding.org/android&quot;&gt; &lt;TextView android:id=&quot;@+id/title&quot;/&gt; &lt;TextView android:text=&quot;: &quot;/&gt; &lt;TextView android:id=&quot;@+id/description&quot;/&gt; 5.3.1. 实现属性绑定这个控件有两个简单的单向属性绑定- source code. @ViewBinding(simpleOneWayProperties = {&quot;title&quot;, &quot;description&quot;}) public class TitleDescriptionBarBinding extends CustomViewBinding&lt;TitleDescriptionBar&gt; { } 5.3.2. 注册ViewBindingsViewBindings能够通过org.robobinding.binder.BinderFactoryBuilder 进行绑定- source code. BinderFactory binderFactory = new BinderFactoryBuilder() .add(new TitleDescriptionBarBinding().forView(TitleDescriptionBar.class)) .build(); 这样就行了。我们能用同样的方法绑定第三方控件或者Android Widgets。 5.4. 替换已有的view绑定当一个已经存在的view绑定不能满足我们需求时，我们通过注册去替代默认的继承implementations. BinderFactory binderFactory = new BinderFactoryBuilder() .add(new MyViewBindingForView().forView(View.class)) .build(); @ViewBinding static class MyViewBindingForView extends CustomViewBinding&lt;View&gt; { ... } 5.4.1. 扩展一个已经存在的view绑定扩展一个已经存在的TextViewBinding，并且增加一个属性绑定。 BinderFactory binderFactory = new BinderFactoryBuilder() .add(new MyTextViewBinding().extend(TextView.class)) .build(); @ViewBinding(simpleOneWayProperties={&quot;typeface&quot;}) static class MyTextViewBinding extends CustomViewBinding&lt;TextView&gt; { ... } 6. Album例子的具体步骤Album工程是一个Martin Fowler的翻译版本original one. 源代码如下： 这里.在接下来的几节，包名是已org.robobinding.albumsample开头的 上面是这个项目的原型。这个项目遵循RoboBinding工程的架构。一个Activity由一个Activity类，布局.xml和一个原型Model组成。在项目中你能看到如下几个包：org.robobinding.albumsample.activity,该包包含所有的Activity界面类；org.robobinding.albumsample.presentationmodel,该包包含所有的原型类；org.robobinding.albumsample.model,该包包含所有的Album实现类；org.robobinding.albumsample.store,该包包含所有的AlbumStore实现类。在原型中有5个表格，分别代表如下：[Home Activity]表格由.activity.HomeActivity,home_activity.xml和.presentationmodel.HomePresentationModel组成。[View Albums Activity]由.activity.ViewAlbumsActivity, view_albums_activity.xml和.presentationmodel.ViewAlbumsPresentationModel组成; 每一个album条目由.presentationmodel.AlbumItemPresentationModel 和album_row.xml来构成; 当album列表是空时，用albums_empty_view.xml布局来代替。[Create Album Activity]和[Edit Album Activity]两者都使用.activity.CreateEditAlbumActivity, create_edit_album_activity.xml 和.presentationmodel.CreateEditAlbumPresentationModel来构成。[View Album Activity].activity.ViewAlbumActivity, view_album_activity.xml 和.presentationmodel.ViewAlbumPresentationModel组成; 它的album 删除对话框.activity.DeleteAlbumDialog, delete_album_dialog.xml和 .presentationmodel.DeleteAlbumDialogPresentationModel构成。把[View Albums Activity]作为一个简单的例子来阐述如何使用RoboBinding。ViewAlbumsActivity是关联到view_albums_activity.xml和ViewAlbumsPresentationModel上面的。view_albums_activity.xml包含3个子View，一个TextView，一个ListView和一个Button。这个TextView不包含任何绑定信息。在ListView中bind:source=”{albums}”绑定到 ViewAlbumsPresentationModel.albums dataset property. bind:onItemClick=”viewAlbum” 绑定到ViewAlbumsPresentationModel.viewAlbum(ItemClickEvent) 方法上. 当album的一个条目被点击时，这个方法将被调用。当数据为空时会使用albums_empte_view.xml布局bind:emptyViewLayout=”@layout/albums_empty_view” 。bind:itemLayout=”@layout/album_row”对应每一行布局，在该布局中有两个TextView，绑定信息如下：bind:text=”{title}” and bind:text=”{artist}” 绑定到AlbumItemPresentationModel.title/artist respectively.在view_albums_activity.xml布局中的子布局是一个 Button. 它的点击事件bind:onClick=”createAlbum” 绑定到ViewAlbumsPresentationModel.createAlbum()方法上。 7. Gallery Demos的组成The entry classes mentioned below are from the package org.robobinding.gallery.activity of Robobinding Gallery project. Binding attributes demo for View. The entry class is ViewActivity. Binding attributes demo for EditText. The entry class is EditTextActivity. Binding attributes demo for AdapterView. The entry class is AdapterViewActivity. Binding attributes demo for ListView. The entry class is ListViewActivity. Binding attributes demo for RecyclerView. The entry class is RecyclerViewActivity. Binding attributes demo for Custom Components. The entry class is CustomComponentActivity. Demo for Object Cursor. The entry class is TypedCursorActivity. Demo for Fragment &amp; ViewPager Binding. The entry class is ListFragmentDemoActivity. Demo for Options Menu Binding. The entry class is OptionsMenuActivity. Demo for Context Menu Binding. The entry class is ContextMenuDemoActivity. Demo for Contextual Action Mode Binding. The entry class is ContextualActionModeActivity. 8. 项目结构和项目实践Involved from MVC pattern, the major motive of Presentation Model(MVVM) pattern is to further decouple UI state and logic into a pure POJO Presentation Model, which can be easily Unit tested. Meanwhile, the dependency of View→Presentation Model→Model becomes unidirectional. When applying the pattern, these are the basic rules we will follow. Album Sample is an example that follows the best practices. Recommend to read Martin Fowler’s original article on Presentation Model. 8.1. 整个项目框架In Android app, the view layer consists of activities(fragments) and their layouts and the model layer(or business model layer) consists of various services, persistence layer, networking services, business services and so on. The diagram indicates the dependency between different layers. The view layer for example never directly accesses the business model. 8.2. 常见问题解决方案 When we are not using a third-party dependency injection lib, we may instantiate business model objects in Activities and then pass them into presentation models, but the view layer(or any activities) will not directly access any business model objects. Sometimes presentation models may need to call some functionalities in the view layer. We can add view interfaces in between to decouple the relationship. Presentation models depends on view interfaces instead of the view layer, which keeps the testability of presentation models. If you prefer, you can shift these view interfaces into presentation model layer or presentation model package, so that the dependency remains unidirectional. Let us have a look a simple example below:``` javainterface MainView {void doSomeViewLogic();} class MainActivity extends Activity implements MainView {…@Overrideprotected void onCreate(Bundle savedInstanceState) {…PresentationModel presentationModel = new PresentationModel(this);…} public void doSomeViewLogic() {…}} class PresentationModel {private MainView mainView; public PresentationModel(MainView mainView) {this.mainView = mainView;} public void someEvent() {mainView.doSomeViewLogic();}}``` 9. 其他资源Jan 2012 Robert Taylor has written a couple of introductory articles here and here. Feb 2012 A video of a talk on RoboBinding at SkillsMatter, London can be found here. Jul 2014 A video of a talk on RoboBinding in Chinese by Cheng Wei can be found here. Sep 2014 A talk at YOW 2014 Android MVVM by Adil Mughal on Write cleaner, maintainable and testable code in Android using MVVM. AndroidMVVM A minimal android app with MVVM. RoboBinding album sample is an Android translation of Martin Fowler’s original sample code on Presentation Model pattern. RoboBinding Gallery demonstrates RoboBinding features. Version 0.8.10Last updated 2015-10-24 16:50:07","categories":[],"tags":[],"keywords":[]},{"title":"AsyncTask研究","slug":"AsyncTask研究","date":"2018-01-03T14:32:22.000Z","updated":"2018-01-03T14:36:10.000Z","comments":true,"path":"2018/01/03/AsyncTask研究/","link":"","permalink":"http://yoursite.com/2018/01/03/AsyncTask研究/","excerpt":"","text":"1. AsyncTask概述在Android平台上，要执行异步工作时，我们常常会用到AsyncTask。这个类可以算是历史悠久，早在Android 1.5版时，它就存在了。 AsyncTask的使用方法比较简单，无非是创建一个AsyncTask派生类对象，重写其doInBackground()函数，然后在合适世纪调用这个对象的execute()或executeOnExecutor()函数即可。 private static class MyTask extends AsyncTask&lt;Void, Void, Void&gt; ｛ // . . . . . . @Override public Void doInBackground(Void... param) { //. . . . . . return null; } ｝ private class TestClickListener implements View.OnClickListener { public void onClick(View v) { switch (v.getId()) { case R.id.scan_btn: testTask(); break; . . . . . . } private void testTask() { for (int i = 0; i &lt; 5; i++) { MyTask t = new MyTask(i+100); t.execute(); // 调用execute()即可 } } 一般情况下，我们会像上面代码中这样调用AsyncTask的execute()函数，这样，投入执行的task会串行执行。不过，有时候我们也希望task们可以并行执行，此时只需把execute()换成executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)即可。 2. AsyncTask的内部机制AsyncTask本身是个抽象的泛型基类，正如前面所说，在实际使用时，我们必须定义它的派生类，并在实现AsyncTask派生类时，重写其doInBackground()成员函数。 AysncTask的声明如下：【frameworks/base/core/java/android/os/AsyncTask.java】 public abstract class AsyncTask作为一种异步执行的任务，AsyncTask是依靠内部的线程池来完成任务调度的。大体上说，AsyncTask内部搞了两个静态的执行器，分别表示成AsyncTask.THREAD_POOL_EXECUTOR 和 AsyncTask.SERIAL_EXECUTOR，前者是可并行执行的执行器（线程池），后者是串行执行的执行器（线程池）。 AsyncTask的构造函数如下： /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 构造函数的注释中说的很明确，必须在UI线程里构造AsyncTask对象。而且构造函数里为两个重要的成员：mWorker和mFuture赋了值，这个我们后文再细说。 2.1 AsyncTask的execute()我们先回过头看前文曾经提到的AsyncTask的execute()函数，其代码如下：【frameworks/base/core/java/android/os/AsyncTask.java】 MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 因为params参数是可变长参数，所以execute()可以接受0到n个参数。注意，execute()和executeOnExecutor()都必须在UI线程里调用。 execute()只是简单地调用executeOnExecutor()而已，它传递的静态变量sDefaultExecutor引用的就是串行执行器AsyncTask.SERIAL_EXECUTOR：private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;executeOnExecutor()的代码截选如下： MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { . . . . . . . . . . . . mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); // 注意，mFuture本身实现了Runnable接口 return this; } 也就是说，最终还是在调用执行器的execute()函数，只不过会把一个mFuture委托给执行器去回调。 默认情况下使用的串行执行器类是SerialExecutor，它的代码如下： private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { // 参数r一般就是mFuture引用的对象 mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 从代码里可以看到，所谓的串行执行器内部，其实也是在复用THREAD_POOL_EXECUTOR，只不过利用对mActive的判断，把调用的流程改成串行的了。 SerialExecutor内部使用的是java.util.ArrayDeque队列，它的poll()函数可以检索并移除此队列的头部，如果返回null，则表示此队列已经取空了。每次摘取一个列头，并记录在mActive变量里，然后交给THREAD_POOL_EXECUTOR来处理。 ThreadPoolExecutor是java提供的线程池实现。总之，线程池会在后续的某个时刻，回调上面插入的Runnable对象的run()。在executeOnExecutor()函数里，我们已经看到向执行器添加了AsynctTask的mFuture成员，而mFuture本身实现了Runnable接口，以后回调就是回调mFuture的run()函数。 2.2 AsyncTask和线程池的协作2.2.1 AsyncTask里的mFutureAsyncTask的mFuture非常重要，它的定义如下： private final FutureTask mFuture;类型为FutureTask，其实现可以参考JDK里的代码：【java/util/concurrent/FutureTask.java】public class FutureTask implements RunnableFuture【java/util/concurrent/FunnableFuture.java】public interface RunnableFuture extends Runnable, Future在前文列出AsyncTask构造函数时，我们已经看到mFuture的创建代码了，注意，在创建FutureTask对象时，传入了mWorker，它会被记入mFuture内部（如果分析JDK的代码，可以看到大体上就是记入mFuture.sync.callable了）。后续在被线程池执行时，这个mWorker才是最核心的对象。 欲了解详情，我们先得看看AsyncTask机制运用的线程池。在AsyncTask类里这样定义线程池成员的： private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128); public static final Executor THREAD_POOL_EXECUTOR; static { ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor; } public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 注意，线程池都是记在静态变量里的，它的生命期和进程的生命期基本一致。 细心的同学还记得，前文在定义AsyncTask派生类时，我们写的是private static class，大家不要忘记加static，否则就是写了一个普通内嵌类，而普通内嵌类对象内部会隐式地引用其外部类，这样当我们的task对象记入线程池后，就有可能导致task的外部类（很有可能是个Activity或Service）对象在较长时间内都不能被垃圾回收机制回收，从而导致内存泄漏。 本文的重点并不想太深入线程池的内部机理，我们只做必要的探讨即可。我们大体上只需知道线程池里的线程会执行FutureTask的run()函数即可。而FutureTask的run()代码如下：【java/util/concurrent/FutureTask.java】 public void run() { sync.innerRun(); } 而FutureTask.Sync的innerRun()代码如下： void innerRun() { if (!compareAndSetState(READY, RUNNING)) return; runner = Thread.currentThread(); if (getState() == RUNNING) { // recheck after setting thread V result; try { result = callable.call(); // 这一步间接调用到AsyncTask的doInBackground()。 } catch (Throwable ex) { setException(ex); return; } set(result); // 如果不出异常的话，会对call返回的结果执行set()操作。 } else { releaseShared(0); // cancel } } 其中会调用callable.call()，这一步就会间接调用到AsyncTask的doInBackground()。再接下来，如果不出异常的话，会对call()返回的结果执行set()操作。大家还记得前文WorkerRunnable实现的call()函数吗？它最后返回语句为：return postResult(result);现在设置的就是这个postResult对象。 FutureTask的set()函数的代码如下：【java/util/concurrent/FutureTask.java】 protected void set(V v) { sync.innerSet(v); } void innerSet(V v) { for (;;) { int s = getState(); if (s == RAN) return; if (s == CANCELLED) { releaseShared(0); return; } if (compareAndSetState(s, RAN)) { result = v; releaseShared(0); done(); return; } } } 结果记录进Sync类的result成员，然后回调FutureTask的done()函数，这也就回调到前文我们看到的AysncTask的mFuture的done()函数了。我们再列一下mFuture的代码：【frameworks/base/core/java/android/os/AsyncTask.java】 mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; done()里面做的无法一些善后处理。 private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } 2.2.2 AsyncTask里的mWorkerAsyncTask的另一个重要成员是mWorker， private final WorkerRunnable mWorker;除了在executeOnExecutor()里会为mWorker的mParams成员赋值外，AsyncTask一般不会直接操作mWorker。mWorker会间接记录进mFuture。当mFuture被回调时，系统会间接回调mWorker的call()成员函数，而这个call()函数是整个AsyncTask的核心行为。 现在我们可以画一张AsyncTask的示意图： 其实，当一个AsyncTask被安插进线程池时，线程池主要关心的是其mFuture成员引用的FutureTask。所以我们可以画出如下示意图： 当回调发生时，最终间接执行到mWorker成员的call()函数，在介绍AsyncTask的构造函数时，我们已经见过该函数的代码，现在再列一遍： mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 设为后台线程 //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); // ??? return postResult(result); } }; 看到了吗，当线程池里的某个线程回调到上面的call()函数时，会先把线程优先级设置为“后台线程”，然后会调用doInBackground()函数。大家还记得吧，前文说过我们在实现一个AsyncTask派生类时，主要重写的就是这个doInBackground()函数，现在终于派上用场了。 上面代码中还调用了一个不常见的函数：Binder.flushPendingCommands()。这个函数对应的注释是这样说的：（本函数）会将所有在当前线程里挂起的“Binder命令”扔回内核驱动。一般可以在执行那些有可能阻塞较长时间的操作之前调用一下该函数，这样可以确保挂起的对象引用被及时释放，避免“持有执行对象的进程”占据比“实际需要持有的时间”更长的时间。所以，我判断此处的调用多少有点儿问题，也许更合理的调用地方是在doInBackground()一句之前。 2.2.3 UI线程和AsyncTask工作线程之间的协作回调的call()函数最终还会通过postResult()，发回一条MESSAGE_POST_RESULT消息。postResult()的代码如下： private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 此处的getHandler()得到的实际是一个可向UI线程发送消息的handler（即AsyncTask的静态成员sHandler）。getHandler()的代码如下： private static Handler getHandler() { synchronized (AsyncTask.class) { if (sHandler == null) { sHandler = new InternalHandler(); } return sHandler; } } 这里搞了个类似单例的sHandler，类型为InternalHandler： private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); // 用于向UI线程发送消息！ } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 从InternalHandler的构造函数可以看到，postResult()最终就是向UI线程发回MESSAGE_POST_RESULT消息的。 当UI线程最终处理MESSAGE_POST_RESUTL消息时，会调用AsyncTask的finish()。 private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 另一方面，用户在编写doInBackground()时，还可以在合适时机调用publishProgress()，向UI线程发出MESSAGE_POST_PROGRESS消息。publishProgress()的代码如下： @WorkerThread protected final void publishProgress(Progress... values) { if (!isCancelled()) { getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget(); } } 这个消息同样被刚刚说到的InternalHandler处理，处理时会回调AsyncTask的onProgressUpdate()。 关于UI线程和执行AsyncTask的线程之间的交互，我们可以画一张示意图如下： 这张图反映了一个AsyncTask对象在运作时，大体上是如何被UI线程和工作线程调用执行的。 2.2.4 AsyncTask的内部状态细心的读者还会发现，AsyncTask在finish()时会把自己的状态置为Status.FINISHED。简单说来，AsyncTask可以处于3种状态，分别是PENDING、RUNNING、FINISHED。这3种状态的切换很简单，示意图如下： 2.2.5 cancel动作当然，用户还可以随时中途放弃执行当前任务。不管是在主线程处理MESSAGE_POST_PROGRESS时，还是在工作线程处理doInBackground()时，用户都可以调用cancel()函数。该函数的代码如下：【frameworks/base/core/java/android/os/AsyncTask.java】 public final boolean cancel(boolean mayInterruptIfRunning) { mCancelled.set(true); return mFuture.cancel(mayInterruptIfRunning); } 【java/util/concurrent/FutureTask.java】 public boolean cancel(boolean mayInterruptIfRunning) { return sync.innerCancel(mayInterruptIfRunning); } 【java/util/concurrent/FutureTask.java】 boolean innerCancel(boolean mayInterruptIfRunning) { for (;;) { int s = getState(); if (ranOrCancelled(s)) return false; if (compareAndSetState(s, CANCELLED)) break; } if (mayInterruptIfRunning) { Thread r = runner; if (r != null) r.interrupt(); } releaseShared(0); done(); return true; } 简单地说，cancel()动作会将mCancelled设为true，这样以后再调用isCancelled()时，就会返回true。前文我们已经看过AsyncTask的finish()的代码，现在再列一下： private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 可以看到，如果该任务是被用户cancel的，那么finish时执行的会是onCancelled()，而不是onPostExecute()。另外，为了确保在用户cancel任务之后，该任务能真的快速退出，我们应该在doInBackground()里周期性地检查一下isCancelled()的返回值，一旦发现，就立即退出。 3 小结关于AsyncTask的知识，我们就先说这么多。现在大体总结一下：1）使用AsyncTask时，主要是重写其派生类的doInBackground()，而且该函数会在线程池的某个工作线程里被回调的；2）必须在UI线程调用AsyncTask的execute()或executeOnExecutor()；3）可以在doInBackground()里的合适时机调用publishProgress()，向UI线程通知工作进展；4）可以随时调用cancel()，放弃执行任务。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Android学习","slug":"Android学习","permalink":"http://yoursite.com/tags/Android学习/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"DexClassLoader加载过程分析","slug":"DexClassLoader加载过程分析","date":"2017-12-27T10:02:07.000Z","updated":"2018-01-03T13:20:32.000Z","comments":true,"path":"2017/12/27/DexClassLoader加载过程分析/","link":"","permalink":"http://yoursite.com/2017/12/27/DexClassLoader加载过程分析/","excerpt":"","text":"在动态加载dex时，均采用的是DexClassLoader类进行加载，网上也有很多对如何加载进行分析的，现结合Android5.1源码进行分析。 实例先来看一个实例，实例完成动态加载SD卡上的一个jar包，在jar包中Toast一段话。 public class ToastTest { private Context context; public ToastTest(Context context){ this.context = context; } public void call() { Toast.makeText(context, &quot;call method&quot;, 0).show(); } public String getData() { return &quot;ToastTest&quot;; } } 将这个Java类打包生成test.jar包，然后放到SD目录下，然后利用DexClassLoader动态加载该jar包。 public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); File file = new File(Environment.getExternalStorageDirectory() .toString() + File.separator + &quot;test.jar&quot;); final File optimizedDexOutputPath = getDir(&quot;temp&quot;, Context.MODE_PRIVATE); /* * Parameters * dexPath 需要装载的APK或者Jar文件的路径。包含多个路径用File.pathSeparator间隔开,在Android上默认是 &quot;:&quot; * optimizedDirectory 优化后的dex文件存放目录，不能为null * libraryPath 目标类中使用的C/C++库的列表,每个目录用File.pathSeparator间隔开; 可以为 null * parent 该类装载器的父装载器，一般用当前执行类的装载器 */ new DexClassLoader(file.getAbsolutePath(), optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader()); //利用反射原理去调用 try { Class&lt;?&gt; testClass = classLoader.loadClass(&quot;com.demo.ToastTest&quot;); Constructor&lt;?&gt; istructor = testClass.getConstructor(Context.class); Method method = iclass.getMethod(&quot;call&quot;, null); String data = (String) method.invoke(istructor.newInstance(this), null); //System.out.println(data); Log.d(&quot;ToastTest&quot;,data); } catch (Exception e) { e.printStackTrace(); } } } 上面代码new DexClassLoader(file.getAbsolutePath(),optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader());完成了jar包的加载，下面从该步骤开始分析DexClassLoader是如何加载一个jar包或者dex的。 代码分析DexClassLoader类文件在\\libcore\\dalvik\\src\\main\\java\\dalvik\\system\\ DexClassLoader.java文件下 public class DexClassLoader extends BaseDexClassLoader { /** * Creates a {@code DexClassLoader} that finds interpreted and native * code. Interpreted classes are found in a set of DEX files contained * in Jar or APK files. * * &lt;p&gt;The path lists are separated using the character specified by the * {@code path.separator} system property, which defaults to {@code :}. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; must not be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) { super(dexPath, new File(optimizedDirectory), libraryPath, parent); } } 代码很简单，直接调用了父类的构造方法。 public class BaseDexClassLoader extends ClassLoader { private final DexPathList pathList; /** * Constructs an instance. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by {@code File.pathSeparator}, which * defaults to {@code &quot;:&quot;} on Android * @param optimizedDirectory directory where optimized dex files * should be written; may be {@code null} * @param libraryPath the list of directories containing native * libraries, delimited by {@code File.pathSeparator}; may be * {@code null} * @param parent the parent class loader */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); } ... } 父类构造函数也很简单，首先调用了它自己的父类构造函数，然后new DaxPathList。下面先分析下DexPathList的构造函数。 /** * Constructs an instance. * * @param definingContext the context in which any as-yet unresolved * classes should be defined * @param dexPath list of dex/resource path elements, separated by * {@code File.pathSeparator} * @param libraryPath list of native library directory path elements, * separated by {@code File.pathSeparator} * @param optimizedDirectory directory where optimized {@code .dex} files * should be found and written to, or {@code null} to use the default * system directory for same */ public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) { if (definingContext == null) { throw new NullPointerException(&quot;definingContext == null&quot;); } if (dexPath == null) { throw new NullPointerException(&quot;dexPath == null&quot;); } if (optimizedDirectory != null) { if (!optimizedDirectory.exists()) { throw new IllegalArgumentException( &quot;optimizedDirectory doesn&#39;t exist: &quot; + optimizedDirectory); } if (!(optimizedDirectory.canRead() &amp;&amp; optimizedDirectory.canWrite())) { throw new IllegalArgumentException( &quot;optimizedDirectory not readable/writable: &quot; + optimizedDirectory); } } //前面做了一些检查和异常处理 this.definingContext = definingContext; ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;(); this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions); if (suppressedExceptions.size() &gt; 0) { this.dexElementsSuppressedExceptions = suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]); } else { dexElementsSuppressedExceptions = null; } this.nativeLibraryDirectories = splitLibraryPath(libraryPath); } 其中关键代码是makeDexElements /** * Makes an array of dex/resource path elements, one per element of * the given array. */ private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory, ArrayList&lt;IOException&gt; suppressedExceptions) { ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); /* * Open all files and load the (direct or contained) dex files * up front. */ for (File file : files) { File zip = null; DexFile dex = null; String name = file.getName(); //对每个文件进行处理 if (file.isDirectory()) { //如果是文件直接加入到elements中 // We support directories for looking up resources. // This is only useful for running libcore tests. elements.add(new Element(file, true, null, null)); } else if (file.isFile()){ if (name.endsWith(DEX_SUFFIX)) {//是dex // Raw dex file (not inside a zip/jar). try { dex = loadDexFile(file, optimizedDirectory); } catch (IOException ex) { System.logE(&quot;Unable to load dex file: &quot; + file, ex); } } else {//不是dex。即是压缩文件：jar zip apk zip = file; try { dex = loadDexFile(file, optimizedDirectory); } catch (IOException suppressed) { /* * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if * the zip file turns out to be resource-only (that is, no classes.dex file * in it). * Let dex == null and hang on to the exception to add to the tea-leaves for * when findClass returns null. */ suppressedExceptions.add(suppressed); } } } else { System.logW(&quot;ClassLoader referenced unknown path: &quot; + file); } if ((zip != null) || (dex != null)) { elements.add(new Element(file, false, zip, dex)); } } return elements.toArray(new Element[elements.size()]); } 先看DexPathList内部是如何解析dex文件的，即分析loadDexFile代码 /** * Constructs a {@code DexFile} instance, as appropriate depending * on whether {@code optimizedDirectory} is {@code null}. */ private static DexFile loadDexFile(File file, File optimizedDirectory) throws IOException { if (optimizedDirectory == null) { return new DexFile(file); } else { String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0); } } 如果被优化后的路径是空，那么直接返回new DexFile(file)。optimizedPathFor是判断优化路径，代码如下： /** * Converts a dex/jar file path and an output directory to an * output file path for an associated optimized dex file. */ private static String optimizedPathFor(File path, File optimizedDirectory) { /* * Get the filename component of the path, and replace the * suffix with &quot;.dex&quot; if that&#39;s not already the suffix. * * We don&#39;t want to use &quot;.odex&quot;, because the build system uses * that for files that are paired with resource-only jar * files. If the VM can assume that there&#39;s no classes.dex in * the matching jar, it doesn&#39;t need to open the jar to check * for updated dependencies, providing a slight performance * boost at startup. The use of &quot;.dex&quot; here matches the use on * files in /data/dalvik-cache. */ String fileName = path.getName(); if (!fileName.endsWith(DEX_SUFFIX)) { int lastDot = fileName.lastIndexOf(&quot;.&quot;); if (lastDot &lt; 0) { fileName += DEX_SUFFIX; } else { StringBuilder sb = new StringBuilder(lastDot + 4); sb.append(fileName, 0, lastDot); sb.append(DEX_SUFFIX); fileName = sb.toString(); } } File result = new File(optimizedDirectory, fileName); return result.getPath(); } 真正执行代码优化的是DexFile.loadDex，代码如下： /** * Open a DEX file, specifying the file in which the optimized DEX * data should be written. If the optimized form exists and appears * to be current, it will be used; if not, the VM will attempt to * regenerate it. * * This is intended for use by applications that wish to download * and execute DEX files outside the usual application installation * mechanism. This function should not be called directly by an * application; instead, use a class loader such as * dalvik.system.DexClassLoader. * * @param sourcePathName * Jar or APK file with &quot;classes.dex&quot;. (May expand this to include * &quot;raw DEX&quot; in the future.) * @param outputPathName * File that will hold the optimized form of the DEX data. * @param flags * Enable optional features. (Currently none defined.) * @return * A new or previously-opened DexFile. * @throws IOException * If unable to open the source or output file. */ static public DexFile loadDex(String sourcePathName, String outputPathName, int flags) throws IOException { /* * TODO: we may want to cache previously-opened DexFile objects. * The cache would be synchronized with close(). This would help * us avoid mapping the same DEX more than once when an app * decided to open it multiple times. In practice this may not * be a real issue. */ return new DexFile(sourcePathName, outputPathName, flags); } 也就是直接返回了DexFile，下面看看DexFile构造函数做了哪些事情： /** * Opens a DEX file from a given filename, using a specified file * to hold the optimized data. * * @param sourceName * Jar or APK file with &quot;classes.dex&quot;. * @param outputName * File that will hold the optimized form of the DEX data. * @param flags * Enable optional features. */ private DexFile(String sourceName, String outputName, int flags) throws IOException { if (outputName != null) { try { String parent = new File(outputName).getParent(); if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) { throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent + &quot; is not owned by the current user. Shared storage cannot protect&quot; + &quot; your application from code injection attacks.&quot;); } } catch (ErrnoException ignored) { // assume we&#39;ll fail with a more contextual error later } } //前面是异常判断 mCookie = openDexFile(sourceName, outputName, flags); mFileName = sourceName; guard.open(&quot;close&quot;); //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName); } 关键代码:openDexFile /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ private static long openDexFile(String sourceName, String outputName, int flags) throws IOException { // Use absolute paths to enable the use of relative paths when testing on host. return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags); } /* * Open a DEX file. The value returned is a magic VM cookie. On * failure, an IOException is thrown. */ private static native long openDexFileNative(String sourceName, String outputName, int flags); 这里也就直接调用了native方法进行优化。继续跟进代码在\\dalvik\\vm\\native\\dalvik_system_DexFile.cpp文件中的openDexFileNative() 函数，接下重点就在这个函数： static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args, JValue* pResult) { //args[0]: sourceName java层传入的 //args[1]: outputName StringObject* sourceNameObj = (StringObject*) args[0]; StringObject* outputNameObj = (StringObject*) args[1]; DexOrJar* pDexOrJar = NULL; JarFile* pJarFile; RawDexFile* pRawDexFile; //DexOrJar* JarFile* RawDexFile* 目录 char* sourceName; char* outputName; //…… sourceName = dvmCreateCstrFromString(sourceNameObj); if (outputNameObj != NULL) outputName = dvmCreateCstrFromString(outputNameObj); else outputName = NULL; /*判断要加载的dex是否为系统中的dex文件 * gDvm ？？？ */ if (dvmClassPathContains(gDvm.bootClassPath, sourceName)) { ALOGW(&quot;Refusing to reopen boot DEX &#39;%s&#39;&quot;, sourceName); dvmThrowIOException( &quot;Re-opening BOOTCLASSPATH DEX files is not allowed&quot;); free(sourceName); free(outputName); RETURN_VOID(); } /* * Try to open it directly as a DEX if the name ends with &quot;.dex&quot;. * If that fails (or isn&#39;t tried in the first place), try it as a * Zip with a &quot;classes.dex&quot; inside. */ //判断sourcename扩展名是否是.dex if (hasDexExtension(sourceName) &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) == 0) { ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName); pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex = true; pDexOrJar-&gt;pRawDexFile = pRawDexFile; pDexOrJar-&gt;pDexMemory = NULL; //.jar文件 } else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) == 0) { ALOGV(&quot;Opening DEX file &#39;%s&#39; (Jar)&quot;, sourceName); pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar)); pDexOrJar-&gt;isDex = false; pDexOrJar-&gt;pJarFile = pJarFile; pDexOrJar-&gt;pDexMemory = NULL; } else { //都不满足，抛出异常 ALOGV(&quot;Unable to open DEX file &#39;%s&#39;&quot;, sourceName); dvmThrowIOException(&quot;unable to open DEX file&quot;); } if (pDexOrJar != NULL) { pDexOrJar-&gt;fileName = sourceName; //把pDexOr这个结构体中的内容加到gDvm中的userDexFile结构的hash表中，便于Dalvik以后的查找 addToDexFileTable(pDexOrJar); } else { free(sourceName); } free(outputName); RETURN_PTR(pDexOrJar); } 再看对.dex文件的处理函数dvmRawDexFileOpen（\\dalvik\\vm\\RawDexFile.cpp）的处理 /* See documentation comment in header. */ int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName, RawDexFile** ppRawDexFile, bool isBootstrap) { DvmDex* pDvmDex = NULL; char* cachedName = NULL; int result = -1; int dexFd = -1; int optFd = -1; u4 modTime = 0; u4 adler32 = 0; size_t fileSize = 0; bool newFile = false; bool locked = false; dexFd = open(fileName, O_RDONLY); //打开dex文件 if (dexFd &lt; 0) goto bail; /* If we fork/exec into dexopt, don&#39;t let it inherit the open fd. */ dvmSetCloseOnExec(dexFd);//dexfd不继承 //校验dex文件的标志，将第8字节开始的4个字节赋值给adler32。 if (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0) { ALOGE(&quot;Error with header for %s&quot;, fileName); goto bail; } //得到dex文件的大小和修改时间，保存在modTime和filesize中 if (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; 0) { ALOGE(&quot;Error with stat for %s&quot;, fileName); goto bail; } //odexOutputName就是odex文件名，如果odexOutputName为空，则自动生成一个。 if (odexOutputName == NULL) { cachedName = dexOptGenerateCacheFileName(fileName, NULL); if (cachedName == NULL) goto bail; } else { cachedName = strdup(odexOutputName); } //主要是验证缓存文件名的正确性，之后将dexOptHeader结构写入fd中 optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime, adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true); locked = true; if (newFile) { u8 startWhen, copyWhen, endWhen; bool result; off_t dexOffset; dexOffset = lseek(optFd, 0, SEEK_CUR); //文件指针的位置 result = (dexOffset &gt; 0); if (result) { startWhen = dvmGetRelativeTimeUsec(); //将dex文件中的内容拷贝到当前odex文件，也就是dexOffset开始 result = copyFileToFile(optFd, dexFd, fileSize) == 0; copyWhen = dvmGetRelativeTimeUsec(); } if (result) { //优化odex文件 result = dvmOptimizeDexFile(optFd, dexOffset, fileSize, fileName, modTime, adler32, isBootstrap); } } /* * Map the cached version. This immediately rewinds the fd, so it * doesn&#39;t have to be seeked anywhere in particular. */ //将odex文件映射到内存空间(mmap)，并用mprotect将属性置为只读属性，并将映射的dex结构放在pDvmDex数据结构中，具体代码在下面。 if (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != 0) { ALOGI(&quot;Unable to map cached %s&quot;, fileName); goto bail; } …… } //Dalvik/vm/RewDexFile.cpp static int verifyMagicAndGetAdler32(int fd, u4 *adler32) { u1 headerStart[12]; ssize_t amt = read(fd, headerStart, sizeof(headerStart)); if (amt &lt; 0) { ALOGE(&quot;Unable to read header: %s&quot;, strerror(errno)); return -1; } if (amt != sizeof(headerStart)) { ALOGE(&quot;Unable to read full header (only got %d bytes)&quot;, (int) amt); return -1; } if (!dexHasValidMagic((DexHeader*) (void*) headerStart)) { return -1; } *adler32 = (u4) headerStart[8] | (((u4) headerStart[9]) &lt;&lt; 8) | (((u4) headerStart[10]) &lt;&lt; 16) | (((u4) headerStart[11]) &lt;&lt; 24); return 0; } //dalvik\\vm\\DvmDex.cpp /* * Given an open optimized DEX file, map it into read-only shared memory and * parse the contents. * * Returns nonzero on error. */ int dvmDexFileOpenFromFd(int fd, DvmDex** ppDvmDex) { DvmDex* pDvmDex; DexFile* pDexFile; MemMapping memMap; int parseFlags = kDexParseDefault; int result = -1; if (gDvm.verifyDexChecksum) parseFlags |= kDexParseVerifyChecksum; if (lseek(fd, 0, SEEK_SET) &lt; 0) { ALOGE(&quot;lseek rewind failed&quot;); goto bail; } //mmap映射fd文件,就是我们之前的odex文件 if (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != 0) { ALOGE(&quot;Unable to map file&quot;); goto bail; } pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags); if (pDexFile == NULL) { ALOGE(&quot;DEX parse failed&quot;); sysReleaseShmem(&amp;memMap); goto bail; } pDvmDex = allocateAuxStructures(pDexFile); if (pDvmDex == NULL) { dexFileFree(pDexFile); sysReleaseShmem(&amp;memMap); goto bail; } /* tuck this into the DexFile so it gets released later */ //将映射odex文件的内存拷贝到DvmDex的结构中 sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap); pDvmDex-&gt;isMappedReadOnly = true; *ppDvmDex = pDvmDex; result = 0; bail: return result; } /*dalvik\\libdex\\SysUtil.cpp */ int sysMapFileInShmemWritableReadOnly(int fd, MemMapping* pMap) { off_t start; size_t length; void* memPtr; assert(pMap != NULL); //获得文件长度和文件开始地址 if (getFileStartAndLength(fd, &amp;start, &amp;length) &lt; 0) return -1; //映射文件 memPtr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_FILE | MAP_PRIVATE, fd, start); //…… //将保护属性置为只读属性 if (mprotect(memPtr, length, PROT_READ) &lt; 0) { //……. } pMap-&gt;baseAddr = pMap-&gt;addr = memPtr; pMap-&gt;baseLength = pMap-&gt;length = length; return 0; //…… } 这些就是对dex的文件处理，对压缩包zip,jar,apk的有兴趣的可以直接分析下源码。 总结首先是对文件名的修正，后缀名置为”.dex”作为输出文件，然后生个一个DexPathList对象函数直接返回一个DexPathList对象， 在DexPathList的构造函数中调用makeDexElements()函数，在makeDexElement()函数中调用loadDexFile()开始对.dex或者是.jar .zip .apk文件进行处理， 跟入loadDexFile()函数中，会发现里面做的工作很简单，调用optimizedPathFor()函数对optimizedDiretcory路径进行修正。 之后才真正通过DexFile.loadDex()开始加载文件中的数据，其中的加载也只是返回一个DexFile对象。 在DexFile类的构造函数中，重点便放在了其调用的openDexFile()函数，在openDexFile()中调用了openDexFileNative()真正进入native层， 在openDexFileNative()的真正实现中，对于后缀名为.dex的文件或者其他文件(.jar .apk .zip)分开进行处理： .dex文件调用dvmRawDexFileOpen()；其他文件调用dvmJarFileOpen()。 在dvmRawDexFileOpen()函数中，检验dex文件的标志，检验odex文件的缓存名称，之后将dex文件拷贝到odex文件中，并对odex进行优化 调用dvmDexFileOpenFromFd()对优化后的odex文件进行映射，通过mprotect置为”只读”属性并将映射的内存结构保存在DvmDex*结构中。 dvmJarFileOpen()先对文件进行映射，结构保存在ZipArchive中，然后再尝试以文件名作为dex文件名来“打开”文件，如果失败，则调用dexZipFindEntry在ZipArchive的名称hash表中找名为”class.dex”的文件,然后创建odex文件，下面就和dvmRawDexFileOpen()一样了，就是对dex文件进行优化和映射。","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"Dex类加载","slug":"Dex类加载","permalink":"http://yoursite.com/tags/Dex类加载/"}],"keywords":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}]},{"title":"Hexo+GitHub搭建个人博客","slug":"Hexo-GitHub搭建个人博客","date":"2017-12-27T07:19:06.000Z","updated":"2018-01-03T13:20:32.000Z","comments":true,"path":"2017/12/27/Hexo-GitHub搭建个人博客/","link":"","permalink":"http://yoursite.com/2017/12/27/Hexo-GitHub搭建个人博客/","excerpt":"","text":"什么是HexoHexo是一个轻量级的博客，使用Markdown解析文章。上传到后台的是静态的网页，因而加载速度快。 Hexo和jekyll两者对比Hexo的主题更多，更好看。 安装使用Hexo 申请github账号免费申请，直接到GitHub官网上面申请。具体步骤参考：GitHub的注册与使用（详细图解） 安装Git，Node.js工具 Node.js安装好后执行以下命令 $ npm install hexo-cli -g npm是Node.js安装时自带的类库,是目前全球最大的类库之一,比Maven仓库还大,类似CentOS的yum源,Mac OX中brew的软件库 通过npm install可以直接安装基于Node.js的所有插件 创建站点 新建文件夹 mkdir blog 初始化站点 hexo init blog 安装npm插件支持 npm install 启动站点 hexo server通过上面就可以在http://localhost:4000/ 上查看生成的站点了","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo搭建","slug":"Hexo搭建","permalink":"http://yoursite.com/tags/Hexo搭建/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2017-12-27T04:11:02.000Z","updated":"2018-01-03T13:20:32.000Z","comments":true,"path":"2017/12/27/hexo常用命令/","link":"","permalink":"http://yoursite.com/2017/12/27/hexo常用命令/","excerpt":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title:使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要以上是文章摘要","text":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title:使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 模版（Scaffold）hexo new photo &quot;My Gallery&quot; 变量 描述 layout 布局 title 标题 date 文件建立日期 设置文章摘要以上是文章摘要 以下是余下全文 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上hexo n #写文章 hexo g #生成 hexo d #部署 #可与hexo g合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git解决方法 npm install hexo-deployer-git –save 2.部署类型设置githexo 3.0 部署类型不再是github，_config.yml 中修改 DeploymentDocs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@.github.com:/*.github.io.git branch: master xcodebuildxcode-select: error: tool ‘xcodebuild’ requires Xcode, but active developer directory ‘/Library/Developer/CommandLineTools’ is a command line tools instance npm install bcrypt RSS不显示安装RSS插件 npm install hexo-generator-feed –save 开启RSS功能编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 开启评论 我使用多说代替自带的评论，在多说 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt; 工具 === 复制通用代码 里面有 short_name 在根目录 _config.yml 添加一行 disqus_shortname: jslite 是在多说注册时产生的 复制到 themes\\landscape\\layout_partial\\article.ejs把&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt; &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 改为&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&#39;&lt;%= config.disqus_shortname %&gt;&#39;}; (function() { var ds = document.createElement(&#39;script&#39;); ds.type = &#39;text/javascript&#39;;ds.async = true; ds.src = (document.location.protocol == &#39;https:&#39; ? &#39;https:&#39; : &#39;http:&#39;) + &#39;//static.duoshuo.com/embed.js&#39;; ds.charset = &#39;UTF-8&#39;; (document.getElementsByTagName(&#39;head&#39;)[0] || document.getElementsByTagName(&#39;body&#39;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt;","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo学习","slug":"Hexo学习","permalink":"http://yoursite.com/tags/Hexo学习/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}]}]}