<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天宇</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-07T14:39:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>黄天宇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android NDK开发系列教程4：对类变量进行操作</title>
    <link href="http://yoursite.com/2018/02/04/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B4%EF%BC%9A%E5%AF%B9%E7%B1%BB%E5%8F%98%E9%87%8F%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/02/04/Android-NDK开发系列教程4：对类变量进行操作/</id>
    <published>2018-02-04T02:54:57.000Z</published>
    <updated>2018-02-07T14:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们也可以直接利用jni来访问和处理类的变量，不一定非要通过Java方法来操作Java类变量。对类变量操作时，类的静态变量和类的实例变量的操作稍微有些不同，下面进行讲解。</p><h3 id="对类的静态变量进行操作"><a href="#对类的静态变量进行操作" class="headerlink" title="对类的静态变量进行操作"></a>对类的静态变量进行操作</h3><p>类的静态变量属于类，是所有该类实例共享的。操作该变量时，不需要指定具体的实例是哪个。</p><pre><code>jclass clazz;  jfieldID fid;  jint num;  //1.获取类的Class引用  clazz = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);  if (clazz == NULL) {    // 错误处理  return;  }  //2.获取类静态变量num的属性ID  fid = env-&gt;GetStaticFieldID( clazz, &quot;num&quot;, &quot;I&quot;);  if (fid == NULL) {  return;  }  // 3.获取静态变量num的值  num = env-&gt;GetStaticIntField(clazz,fid);  printf(&quot;In C---&gt;ClassField.num = %d\n&quot;, num);  // 4.修改静态变量num的值  env-&gt;SetStaticIntField(clazz, fid, 80);</code></pre><p>主要步骤就是代码里面注释的。</p><h3 id="对类的实例变量进行操作"><a href="#对类的实例变量进行操作" class="headerlink" title="对类的实例变量进行操作"></a>对类的实例变量进行操作</h3><p>代码如下：</p><pre><code>jclass clazz;  jfieldID fid;  jstring j_str;  jstring j_newStr;  const char *c_str = NULL;  // 1.获取类的Class引用,obj是该类的某个实例jobject obj;clazz = env-&gt;GetObjectClass(obj);  if (clazz == NULL) {  return;  }  // 2. 获取类实例变量str的属性ID  fid = env-&gt;GetFieldID(clazz,&quot;str&quot;, &quot;Ljava/lang/String;&quot;);  if (clazz == NULL) {  return;  }  // 3. 获取实例变量str的值  j_str = (jstring)env-&gt;GetObjectField(obj,fid);  // 4. 将unicode编码的java字符串转换成C风格字符串  c_str = env-&gt;GetStringUTFChars(j_str,NULL);  if (c_str == NULL) {  return;  }  printf(&quot;In C---&gt;ClassField.str = %s\n&quot;, c_str);  env-&gt;ReleaseStringUTFChars(j_str, c_str);  // 5. 修改实例变量str的值  j_newStr = env-&gt;NewStringUTF(&quot;This is C String&quot;);  if (j_newStr == NULL) {  return;  }  env-&gt;SetObjectField(obj, fid, j_newStr);  // 6.删除局部引用  env-&gt;DeleteLocalRef(clazz);  env-&gt;DeleteLocalRef(j_str);  env-&gt;DeleteLocalRef(j_newStr);</code></pre><p>JNI开发也有JNI开发的套路，按照上面套路来，即可修改类的实例变量。操作过程也很好理解，我们在native操作的时候都需要借助JNI提供的函数获取相应的引用。利用引用去进行操作。由于JNI函数是直接操作JVM中的数据结构，所以即使是private的变量，我们也可以进行修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>由于JNI函数是直接操作JVM中的数据结构，不受Java访问修饰符的限制。即，在本地代码中可以调用JNI函数可以访问Java对象中的非public属性和方法</li><li><p>访问和修改静态变量操作步聚：</p><ol><li><p>调用FindClass函数获取类的Class引用</p></li><li><p>调用GetStaticFieldID函数获取Class引用中某个静态变量ID</p></li><li><p>调用GetStaticXXXField函数获取静态变量的值，需要传入变量所属Class的引用和变量ID</p></li><li><p>调用SetStaticXXXField函数设置静态变量的值，需要传入变量所属Class的引用、变量ID和变量的值</p></li></ol></li><li><p>访问和修改实例变量操作步聚：</p><ol><li><p>调用GetObjectClass函数获取实例对象的Class引用</p></li><li><p>调用GetFieldID函数获取Class引用中某个实例变量的ID</p></li><li><p>调用GetXXXField函数获取变量的值，需要传入实例变量所属对象和变量ID</p></li><li><p>调用SetXXXField函数修改变量的值，需要传入实例变量所属对象、变量ID和变量的值</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们也可以直接利用jni来访问和处理类的变量，不一定非要通过Java方法来操作Java类变量。对类变量操作时，类的静态变量和类的实例变量的操作稍微有些不同，下面进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;对类的静态变量进行操作&quot;&gt;&lt;a href=&quot;#对类的静态变量进行操作&quot; c
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android JNI开发" scheme="http://yoursite.com/tags/Android-JNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发系列教程3：基本方法调用及传参（续）</title>
    <link href="http://yoursite.com/2018/02/02/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B3%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8F%8A%E4%BC%A0%E5%8F%82%EF%BC%88%E7%BB%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2018/02/02/Android-NDK开发系列教程3：基本方法调用及传参（续）/</id>
    <published>2018-02-02T14:25:43.000Z</published>
    <updated>2018-02-07T14:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一节主要讲解Java向native传参，下面主要讲解从<em>native传相应的数据到java层</em>。<br>接着上一节，下面主要讲解内容如下：</p><ol><li>native向java返回字符串类型</li><li>native向java返回java对象</li><li>native向java返回数组类型</li><li>native向Java返回List对象<br>对于上面的每个都给出对应的例子。<br>本节所有案例代码均已放到GitHub上，欢迎下载：<br><a href="https://github.com/huangtianyu/JNILearnCourse" target="_blank" rel="noopener">https://github.com/huangtianyu/JNILearnCourse</a></li></ol><h4 id="1-native向java返回字符串类型"><a href="#1-native向java返回字符串类型" class="headerlink" title="1. native向java返回字符串类型"></a>1. native向java返回字符串类型</h4><p>传基本数据类型很简单，是什么就传什么就行。传字符串类型也很简单，具体jni代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod1(JNIEnv *env, jobject instance) {    //jstring NewStringUTF(const char* bytes),jstring NewString(const jchar* unicodeChars, jsize len)    char *returnValue = &quot;你在native做你的操作后，生成char*后，通过env-&gt;NewStringUTF即可返回Java的String类型&quot;;    return env-&gt;NewStringUTF(returnValue);}</code></pre><p>其中最主要用的是以下几个方法：</p><pre><code>    //创建Unicode格式的jstring串    jstring NewString(const jchar* unicodeChars, jsize len)    { return functions-&gt;NewString(this, unicodeChars, len); }    //获取jstring长度    jsize GetStringLength(jstring string)    { return functions-&gt;GetStringLength(this, string); }    //获取jstring对应的字符串，isCopy表示是否拷贝生成副本。    //这个函数返回一个指向特定jstring中字符顺序的指针，该指针保持有效直到ReleaseStringChars函数被调用：    const jchar* GetStringChars(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringChars(this, string, isCopy); }    //释放指针    void ReleaseStringChars(jstring string, const jchar* chars)    { functions-&gt;ReleaseStringChars(this, string, chars); }    ////创建UTF-8格式的jstring串    jstring NewStringUTF(const char* bytes)    { return functions-&gt;NewStringUTF(this, bytes); }    //获取utf字符串的长度    jsize GetStringUTFLength(jstring string)    { return functions-&gt;GetStringUTFLength(this, string); }    //同GetStringChars    const char* GetStringUTFChars(jstring string, jboolean* isCopy)    { return functions-&gt;GetStringUTFChars(this, string, isCopy); }    //同ReleaseStringChars    void ReleaseStringUTFChars(jstring string, const char* utf)    { functions-&gt;ReleaseStringUTFChars(this, string, utf); }</code></pre><p>以上是处理字符串常用的一些方法。</p><h4 id="2-native向java返回java对象"><a href="#2-native向java返回java对象" class="headerlink" title="2 native向java返回java对象"></a>2 native向java返回java对象</h4><p>具体看native的代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jobject JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod2(JNIEnv *env, jobject instance) {    jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    jmethodID constructor = env-&gt;GetMethodID(pcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jmethodID setIdMid = env-&gt;GetMethodID(pcls, &quot;setId&quot;, &quot;(J)V&quot;);    jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    jmethodID setAgeMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(I)V&quot;);    jobject person = env-&gt;NewObject(pcls, constructor);    env-&gt;CallVoidMethod(person, setIdMid, 100L);    env-&gt;CallVoidMethod(person, setNameMid, env-&gt;NewStringUTF(&quot;天宇&quot;));    env-&gt;CallVoidMethod(person, setAgeMid, 18);    return person;}</code></pre><p>常用新建Object的方法由以下几个：</p><pre><code>    //将传递给构造函数的所有参数紧跟着放在 methodID 参数的后面。NewObject() 收到这些参数后，将把它们传给所要调用的Java 方法。    jobject NewObject(jclass clazz, jmethodID methodID, ...)    {        va_list args;        va_start(args, methodID);        jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args);        va_end(args);        return result;    }    //将传递给构造函数的所有参数放在 va_list 类型的参数 args 中，该参数紧跟着放在 methodID 参数的后面。NewObject() 收到这些参数后，将把它们传给所要调用的 Java 方法。    jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)    { return functions-&gt;NewObjectV(this, clazz, methodID, args); }    //将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject() 收到数组中的这些参数后，将把它们传给所要调用的 Java 方法。    jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args)    { return functions-&gt;NewObjectA(this, clazz, methodID, args); }    //测试对象是否为某个类的实例。    jboolean IsInstanceOf(jobject obj, jclass clazz)    { return functions-&gt;IsInstanceOf(this, obj, clazz); }    //测试两个引用是否引用同一 Java 对象。    jboolean IsSameObject(jobject ref1, jobject ref2)    { return functions-&gt;IsSameObject(this, ref1, ref2); }    //分配新 Java 对象而不调用该对象的任何构造函数。返回该对象的引用。    //该方法会抛出：InstantiationException：如果该类为一个接口或抽象类。OutOfMemoryError：如果系统内存不足。    jobject AllocObject(jclass clazz)    { return functions-&gt;AllocObject(this, clazz); }</code></pre><h4 id="3-native向java返回数组类型"><a href="#3-native向java返回数组类型" class="headerlink" title="3 native向java返回数组类型"></a>3 native向java返回数组类型</h4><h5 id="3-1-基本类型数组"><a href="#3-1-基本类型数组" class="headerlink" title="3.1 基本类型数组"></a>3.1 基本类型数组</h5><p>这里直接看native层代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jintArray JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod3(JNIEnv *env, jobject instance) {    int nat[] = {2, 1, 4, 3, 5};    jintArray jnat = env-&gt;NewIntArray(5);    env-&gt;SetIntArrayRegion(jnat, 0, 5, nat);    return jnat;}</code></pre><p>基本数据类型数组都有相应的env-&gt;NewXXXArray(jsize length);通过该方法可以生成对应的数组。</p><pre><code>jbooleanArray NewBooleanArray(jsize length)    { return functions-&gt;NewBooleanArray(this, length); }    jbyteArray NewByteArray(jsize length)    { return functions-&gt;NewByteArray(this, length); }    jcharArray NewCharArray(jsize length)    { return functions-&gt;NewCharArray(this, length); }    jshortArray NewShortArray(jsize length)    { return functions-&gt;NewShortArray(this, length); }    jintArray NewIntArray(jsize length)    { return functions-&gt;NewIntArray(this, length); }    jlongArray NewLongArray(jsize length)    { return functions-&gt;NewLongArray(this, length); }    jfloatArray NewFloatArray(jsize length)    { return functions-&gt;NewFloatArray(this, length); }    jdoubleArray NewDoubleArray(jsize length)    { return functions-&gt;NewDoubleArray(this, length); }</code></pre><p>在生成了对应的数组后，可以通过setXXXArrayRegion(jxxxArray array, jsize start, jsize len,  const jchar* buf)来填充数组</p><pre><code>    void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len,        const jboolean* buf)    { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); }    void SetByteArrayRegion(jbyteArray array, jsize start, jsize len,        const jbyte* buf)    { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); }    void SetCharArrayRegion(jcharArray array, jsize start, jsize len,        const jchar* buf)    { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); }    void SetShortArrayRegion(jshortArray array, jsize start, jsize len,        const jshort* buf)    { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); }    void SetIntArrayRegion(jintArray array, jsize start, jsize len,        const jint* buf)    { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); }    void SetLongArrayRegion(jlongArray array, jsize start, jsize len,        const jlong* buf)    { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); }    void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len,        const jfloat* buf)    { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); }    void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len,        const jdouble* buf)    { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); }</code></pre><h5 id="3-2-对象类型数组"><a href="#3-2-对象类型数组" class="headerlink" title="3.2 对象类型数组"></a>3.2 对象类型数组</h5><p>直接看native代码：</p><pre><code>extern &quot;C&quot;JNIEXPORT jobjectArray JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod4(JNIEnv *env, jobject instance) {    jclass cls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    jmethodID cMid = env-&gt;GetMethodID(cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    jmethodID cmid = env-&gt;GetMethodID(pcls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);    jmethodID setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    jmethodID setAgeMid = env-&gt;GetMethodID(pcls, &quot;setAge&quot;, &quot;(I)V&quot;);    jobject obj = env-&gt;NewObject(pcls, cmid);    env-&gt;CallVoidMethod(obj, setNameMid, env-&gt;NewStringUTF(&quot;天宇&quot;));    int len = 3;    jobjectArray joa = env-&gt;NewObjectArray(len, cls, obj);    for (int i = 0; i &lt; len; ++i) {        jobject tmp = env-&gt;GetObjectArrayElement(joa,i);        env-&gt;CallVoidMethod(tmp, setAgeMid, i + 10);    }    return joa;}</code></pre><p>其在native生成的方法是<code>   jobjectArray joa = env-&gt;NewObjectArray(len, cls, obj);</code></p><pre><code>//第一个参数表示生成的长度，第二参数表示里面元素的对象类，第三个表示原始初始化时的值。在生成后每个元素都是该值。jobjectArray NewObjectArray(jsize length, jclass elementClass,        jobject initialElement)    { return functions-&gt;NewObjectArray(this, length, elementClass,        initialElement); }</code></pre><h4 id="4-native向Java返回List对象"><a href="#4-native向Java返回List对象" class="headerlink" title="4 native向Java返回List对象"></a>4 native向Java返回List对象</h4><p>直接看native代码如下：</p><pre><code>extern &quot;C&quot;JNIEXPORT jobject JNICALLJava_zqc_com_example_NativeTest_jni2javaMethod5(JNIEnv *env, jobject instance) {    jclass listCls = env-&gt;FindClass(&quot;java/util/ArrayList&quot;);//获得ArrayList类引用    jmethodID  listCon = env-&gt;GetMethodID(listCls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);//获取构造函数的methodID    jmethodID addMid = env-&gt;GetMethodID(listCls,&quot;add&quot;,&quot;(Ljava/lang/Object;)Z&quot;);//获取add函数的methodID    jobject listObj = env-&gt;NewObject(listCls, listCon);//利用NewObject创建一个ArrayList对象    jobject jperon = Java_zqc_com_example_NativeTest_jni2javaMethod2(env, instance);//利用上面方法新建一个Person对象    env-&gt;CallBooleanMethod(listObj, addMid, jperon);//在listObj中add一个Person对象    //返回ArrayList的对象    return listObj;}</code></pre><p>对应jni而言，List，ArrayList以及Map，HashMap，Set，HashSet都只是一个Object，对应于jni而言也就都是jobject，操作jobject都可以用最开始介绍的方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>jni里面的方法很多，多用用就熟悉了。常用的上面都有，自己之前还总结了很多常用的类型转换函数。以后有时间再写篇博客分享下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一节主要讲解Java向native传参，下面主要讲解从&lt;em&gt;native传相应的数据到java层&lt;/em&gt;。&lt;br&gt;接着上一节，下面主要讲解内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;native向java返回字符串类型&lt;/li&gt;
&lt;li&gt;native向java返回java对
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android NDK开发，JNI开发" scheme="http://yoursite.com/tags/Android-NDK%E5%BC%80%E5%8F%91%EF%BC%8CJNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title> Android NDK开发系列教程2：基本方法调用及传参</title>
    <link href="http://yoursite.com/2018/02/02/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8F%8A%E4%BC%A0%E5%8F%82/"/>
    <id>http://yoursite.com/2018/02/02/Android-NDK开发系列教程2：基本方法调用及传参/</id>
    <published>2018-02-02T13:56:11.000Z</published>
    <updated>2018-02-07T14:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>有时候我写了个Java层的方法，希望native层也能够调用（尤其是一个实体类的get，set方法在native一般都会用到）。这在jni开发中也很常见，jni.h中也提供了很多方法。下面利用具体实例进行说明。这里直接使用AS3.0里面的CMake进行编译了，之后会讲解下Android.mk和Application.mk的用法和含义。这里我主要介绍一下几个：</p><ol><li>java向native传递常用基本数据类型和字符串类型</li><li>java向native传递数组类型</li><li>java向native传递自定义java对象</li><li>java向native传递List对象</li></ol><h4 id="1-1-java和jni类型对照表"><a href="#1-1-java和jni类型对照表" class="headerlink" title="1.1 java和jni类型对照表"></a>1.1 java和jni类型对照表</h4><p>在我们调用方法时会用到方法的签名，使用类变量时需要用该变量对应的jni类型。下面给出对应的类型对照表。</p><ol><li>基本数据类型对照表：<br><img src="http://img.blog.csdn.net/20180201185144006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>对象类型对照表：<br><img src="http://img.blog.csdn.net/20180201185721731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>简写对应表<br><img src="http://img.blog.csdn.net/20180202143637829?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="2-具体例子"><a href="#2-具体例子" class="headerlink" title="2. 具体例子"></a>2. 具体例子</h3><h4 id="2-1-java向native传递常用基本数据类型和字符串类型"><a href="#2-1-java向native传递常用基本数据类型和字符串类型" class="headerlink" title="2.1 java向native传递常用基本数据类型和字符串类型"></a>2.1 java向native传递常用基本数据类型和字符串类型</h4>强大的AS在你写了java的native方法后，直接快捷键按Alt+Enter后即可生成对应的方法。<br>java层的方法：<pre><code>package zqc.com.example;public class NativeTest { // Used to load the &#39;native-lib&#39; library on application startup. static {     System.loadLibrary(&quot;native-lib&quot;); } //定义一个native方法，然后传入基本数据类型和String型 public native void java2jniMethod1(boolean b, int i, float f, String s);}</code></pre>生成后的native方法：<pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod1(JNIEnv *env, jobject instance, jboolean b, jint i,                                             jfloat f, jstring s_) { //在native层会把string转换成c/c++都特别熟悉的char*，由char*可以转string,wstring等等。 //在Java层String是对象，这里讲char*指针指向了该对象，在方法结束的时候记得要是否该指针引用 if (b == JNI_TRUE) {     LOGE(&quot;b is true&quot;); } else {     LOGE(&quot;b is false&quot;); } float nativi = i + f; LOGE(&quot;native i: %f&quot;, nativi); const char *s = env-&gt;GetStringUTFChars(s_, 0); LOGE(&quot;native string: %s&quot;, s); env-&gt;ReleaseStringUTFChars(s_, s);}</code></pre>在上面可以看到，Java层的基本类型方法都会经过jni进行转换，转换成相应的jni类型。其操作也很方便。Java的String类型需要注意下，一般是将jstring先转换为char<em>然后对char </em>进行操作。由于这获取了一个局部引用，一般在调用结束后需要释放该局部引用。</li></ol><h4 id="2-2-java向native传递数组类型"><a href="#2-2-java向native传递数组类型" class="headerlink" title="2.2 java向native传递数组类型"></a>2.2 java向native传递数组类型</h4><pre><code>    //向native传递数组类型    public native void java2jniMethod2(int[] as, String[] strs);</code></pre><p>对应的jni方法是：</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod2(JNIEnv *env, jobject instance, jintArray as_,                                                jobjectArray strs) {    //获取数组里面内容    jint *as = env-&gt;GetIntArrayElements(as_, NULL);    int result = 0, len = env-&gt;GetArrayLength(as_);    for (int i = 0; i &lt; len; ++i) {        result += as[i];    }    LOGE(&quot;intarray sum is %d&quot;, result);    env-&gt;ReleaseIntArrayElements(as_, as, 0);    //这里可以看出String[]对应的是jobjectArray    len = env-&gt;GetArrayLength(strs);    for (int i = 0; i &lt; len; ++i) {        jstring temp = (jstring) env-&gt;GetObjectArrayElement(strs, i);        const char *ctemp = env-&gt;GetStringUTFChars(temp, JNI_FALSE);        LOGE(&quot;第%d个：%s&quot;, i, ctemp);    }}</code></pre><p>其中函数： jsize GetArrayLength(jxxxarray array);用于获取数组的长度<br>在Java端调用代码如下：</p><pre><code>    NativeTest test = new NativeTest();    int a[] = new int[3];    for (int i=0;i&lt;a.length;i++) {        a[i] = i + 10;    }    String[] strs = new String[4];    for (int i=0;i&lt;strs.length;i++) {        strs[i] = &quot;我的值：&quot;+i;    }    test.java2jniMethod2(a,strs);</code></pre><h5 id="2-2-1-处理基本数据类型有以下几个相关函数："><a href="#2-2-1-处理基本数据类型有以下几个相关函数：" class="headerlink" title="2.2.1 处理基本数据类型有以下几个相关函数："></a>2.2.1 处理基本数据类型有以下几个相关函数：</h5><p>(1) GetXXXArrayElements(Array arr , jboolean* isCopide);<br>这类函数可以把Java基本类型的数组转换到C/C++中的数组，有两种处理方式，一种JNI_TRUE是拷贝一份传回本地代码，另一个是JNI_FALSE把指向Java数组的指针直接传回到本地代码中，处理完本地化的数组后，通过ReleaseXXXArrayElements来释放数组</p><p>(2) ReleaseXXXArrayElements(Array arr , * array , jint mode)<br>用这个函数可以选择将如何处理Java跟C++的数组，是提交，还是撤销等，内存释放还是不释放等mode可以取下面的值:<br>0 ：对Java的数组进行更新并释放C/C++的数组<br>JNI_COMMIT ：对Java的数组进行更新但是不释放C/C++的数组<br>JNI_ABORT：对Java的数组不进行更新,释放C/C++的数组</p><p>(3) GetPrimitiveArrayCritical(jarray arr , jboolean* isCopied);<br>在获得数组上的锁后将返回一个句柄给数组。如果没有建立任何锁，则isCopy被置为JNI_TRUE，否则置为NULL或JNI_FALSE：</p><p>(4) ReleasePrimitiveArrayCritical(jarray arr , void* array , jint mode);<br>释放从GetPrimitiveArrayCritical调用中返回的数组。也是JDK1.2出来的，为了增加直接传回指向Java数组的指针而加入的函数，同样的也会有同GetStringCritical的死锁的问题。mode取值如下：<br>0：从carray中复制值到数组中，并释放分配给carray的存储器<br>JNI_COMMIT：从carray中复制值到数组中，但是不释放分配给carray的存储器<br>JNI_ABORT：不从carray中复制值到数组中</p><p>(5) GetXXXArrayRegion(Array arr , jsize start , jsize len , * buffer);<br>在C/C++预先开辟一段内存，然后把Java基本类型的数组拷贝到这段内存中。用于一个数组子集的复制操作。参数start指定了从何处复制的起始索引，参数len则指定了从数组中复制到本机数组的多个位置数量。</p><p>(6) SetXXXArrayRegion(Array arr , jsize start , jsize len , const * buffer);<br>用来复制本机数组的一段内容回Java数组中。元素一般从本机数组起始处（索引为0）开始复制，但是只是从位置start开始将len个元素复制到Java数组中。</p><p>(7) Array NewXXXArray(jsize sz)<br>创建一个包含length个元素的Java数组。</p><h5 id="2-2-2-处理对象数组类型有以下几个相关函数："><a href="#2-2-2-处理对象数组类型有以下几个相关函数：" class="headerlink" title="2.2.2 处理对象数组类型有以下几个相关函数："></a>2.2.2 处理对象数组类型有以下几个相关函数：</h5><p>(1)  jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement );<br>创建对象数组，创建一个长度为length，并且持有类型为elementClass的对象的对象数组，数组中的所有元素都被置为initialElement</p><p>(2)  jobject GetObjectArrayElement(jobjectArray array, jsize Index);<br>获取数组元素，通过Index指定的索引在array中获取一个对象，如果索引超出边界，会抛出一个IndexOutOfBoundsException</p><p>(3) void SetObjectArrayElement(jobjectArray array, jsize index,jobject value);<br>设置元素值。在array中通过index指定的索引处设置元素值为value，如果index超出边界，会抛出一个IndexOutOfBoundException。</p><h4 id="2-3-java向native传递自定义java对象"><a href="#2-3-java向native传递自定义java对象" class="headerlink" title="2.3  java向native传递自定义java对象"></a>2.3  java向native传递自定义java对象</h4><p>定义一个Java层方法：</p><pre><code class="java">package zqc.com.example;/** * Created by zhangqianchu on 2018/2/1. */class Person {    long id;    String name;    int age;    public long getId() {        return id;    }    public void setId(long id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Person{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><p>定义一个Java的native方法：</p><pre><code>    //Java向native传自定义类对象    public native void java2jniMethod3(Person person);</code></pre><p>在native层实现</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod3(JNIEnv *env, jobject instance, jobject person) {    jclass cls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    if (cls == 0) {        LOGE(&quot;find class fail&quot;);        return;    }    jmethodID mid_ID = env-&gt;GetMethodID(cls, &quot;setId&quot;, &quot;(J)V&quot;);    jmethodID mid_Name = env-&gt;GetMethodID(cls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    jmethodID mid_Age = env-&gt;GetMethodID(cls, &quot;setAge&quot;, &quot;(I)V&quot;);    if (mid_ID &amp;&amp; mid_Name &amp;&amp; mid_Age) {        env-&gt;CallVoidMethod(person, mid_ID, 100L);        jstring name = env-&gt;NewStringUTF(&quot;Tianyu&quot;);        env-&gt;CallVoidMethod(person, mid_Name, name);        env-&gt;CallVoidMethod(person, mid_Age, 18);        return;    }}</code></pre><p>在Java端调用</p><pre><code>Person person = new Person();test.java2jniMethod3(person);Toast.makeText(this, person.toString(),Toast.LENGTH_SHORT).show();</code></pre><p>从Java端传对象实例给native时，到native端任何对象都变为jobject类型，如果要做对该对象实例的任何操作需先获取该对象的jfieldID ,jmethodID,然后通过env-&gt;CallXXXMethod来操作该对象的方法其中第一个参数是该对象的具体实例，其中env-&gt;CallStaticXXXMethod方法用来调用该类的静态方法，调用静态方法的时候就不用传具体的对象过去了。</p><h4 id="2-4-java向native传递List对象"><a href="#2-4-java向native传递List对象" class="headerlink" title="2.4 java向native传递List对象"></a>2.4 java向native传递List对象</h4><p>定义Java的native方法</p><pre><code>//Java向native传List对象public native void java2jniMethod4(List&lt;Person&gt;people);</code></pre><p>在native中实现具体方法：</p><pre><code>extern &quot;C&quot;JNIEXPORT void JNICALLJava_zqc_com_example_NativeTest_java2jniMethod4(JNIEnv *env, jobject instance, jobject people) {    //下面所有操作都得先判断是否为空。。。    jclass cls = env-&gt;GetObjectClass(people);    jclass pcls = env-&gt;FindClass(&quot;zqc/com/example/Person&quot;);    //jmethodID getNameMid = env-&gt;GetMethodID(pcls, &quot;getName&quot;, &quot;()Ljava/lang/String;&quot;);    jmethodID  setNameMid = env-&gt;GetMethodID(pcls, &quot;setName&quot;, &quot;(Ljava/lang/String;)V&quot;);    //获取List的get方法id    jmethodID getMid = env-&gt;GetMethodID(cls, &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;);    //获取List的长度    jmethodID sizeMid = env-&gt;GetMethodID(cls, &quot;size&quot;, &quot;()I&quot;);    int len = env-&gt;CallIntMethod(people, sizeMid);    for (int i = 0; i &lt; len; ++i) {        //获取第i个元素        jobject  data = env-&gt;CallObjectMethod(people, getMid, i);        env-&gt;CallVoidMethod(data, setNameMid, env-&gt;NewStringUTF(&quot;全部随我native&quot;));    }}</code></pre><p><code> jclass cls = env-&gt;GetObjectClass(people);</code>这是获取一个对象实例相应的类的最好的办法。从上面可以看出List在传到native时也是变成了jobject，然后具体操作都得通过env-&gt;GetObjectClass先获取到该类，然后获取到该类的具体jmethodID，jfieldID来完成相应的操作。调用的方法也是env-&gt;CallXXXMethod()。<br>然后在Java端调用该native方法：</p><pre><code>    NativeTest test = new NativeTest();    List&lt;Person&gt; people = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 3; i++) {        Person person1 = new Person();        person1.setName(&quot;我是Java层&quot;);        people.add(person1);    }    test.java2jniMethod4(people);    Iterator&lt;Person&gt; iterator = people.iterator();    while (iterator.hasNext()) {        Person person1 = iterator.next();        Log.e(&quot;myndk&quot;, person1.getName() + &quot;\n&quot;);    }</code></pre><p>在上面即可通过native将Person的name全部进行了更改。</p><p><b>上面</b>都是Java向native传参，基本用法都类似。基本数据类型有相应的对照表，对象类型的都转为jobject，对对象的操作都是先获取该对象jclass,jmethodID,jfielID后再对对象实例进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;有时候我写了个Java层的方法，希望native层也能够调用（尤其是一个实体类的get，set方法在native一般都会
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android NDK开发，JNI开发" scheme="http://yoursite.com/tags/Android-NDK%E5%BC%80%E5%8F%91%EF%BC%8CJNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Android NDK开发系列教程1：环境搭建及基本代码结构</title>
    <link href="http://yoursite.com/2018/02/01/Android-NDK%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/02/01/Android-NDK开发系列教程1：环境搭建及基本代码结构/</id>
    <published>2018-02-01T13:50:54.000Z</published>
    <updated>2018-02-07T14:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Eclipse-NDK开发环境搭建"><a href="#1-Eclipse-NDK开发环境搭建" class="headerlink" title="1. Eclipse NDK开发环境搭建"></a>1. Eclipse NDK开发环境搭建</h3><p>在开发NDK之前，Java的SDK，Android的NDK，以及Eclipse的ADT工具都需要大家先安装好，在SDK早期版本中没有ndk相关文件，当最近的AndroidSDK中包含了ndk相关文件，所以下载NDK工具的麻烦事这里就没有了。唯一要注意的是需要配置下NDK的环境变量。这样可以方便进行编译。AndroidSDK主要文件夹参考如下：<br><img src="http://img.blog.csdn.net/20180201161034954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="AndroidSDK目录结构"><br>这里讲Eclipse的配置就将下如何添加External Tool来快速生成.h文件以及快速进行ndk_build编译。</p><h4 id="1-1-配置快速生成-h头文件的命令"><a href="#1-1-配置快速生成-h头文件的命令" class="headerlink" title="1.1 配置快速生成.h头文件的命令"></a>1.1 配置快速生成.h头文件的命令</h4><ol><li>点击Eclipse上面的图标，打开External Tool Configurations。<br><img src="http://img.blog.csdn.net/20180201162000196?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></li><li>然后打开如下界面，在如下界面中双击Program，在底下会生成一个New_configuration。<br><img src="http://img.blog.csdn.net/20180201162930719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>然后按照图片上面的格式填写相应的参数。<br>Location填写javah.exe的位置：C:\Program Files\Java\jdk1.8.0_91\bin\javah.exe<br>Working Directory填写当前的工作目录：${workspace_loc:/MyTest/src}<br>Arguments填写相应的参数：<pre><code>-classpath ${workspace_loc:/MyTest/src/bin/classes} -d ${workspace_loc:/MyTest/jni} -jni com.scu.MyNDK</code></pre>之后在External Tool的地方就会生成一个JavaH的命令工具，点击即可生成对应的.h头文件了。这里要注意的是生成都文件前要先编译出.class文件。<br>其实这个和用javah.exe命令是一样的，具体命令如下：<br><img src="http://img.blog.csdn.net/20180201163500478?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><h3 id="2-Android-Studio的配置"><a href="#2-Android-Studio的配置" class="headerlink" title="2. Android Studio的配置"></a>2. Android Studio的配置</h3>AS太强大了，所有你想要的只需要简单的添加一个依赖，AS就会自动帮你下载，完全不用你去下载。最新的Android Studio在新建工程的时候，选中Include C++ Support后，即可进行NDK开发，这里注意下在AS中的编译换成了CMake工具，这个工具配置上稍微和Android.mk有些许不同。其配置文件在新建工程的CMakeLists.txt里面配置。</li></ol><p>在build.gradle里面也会自动配置cmake工具，配置如下：</p><pre><code class="xml">    externalNativeBuild {        cmake {            path &quot;CMakeLists.txt&quot;        }    }</code></pre><h3 id="3-基本代码结构"><a href="#3-基本代码结构" class="headerlink" title="3. 基本代码结构"></a>3. 基本代码结构</h3><p>利用AS创建工程后，工程会自动生成如下代码：</p><pre><code class="java">package zqc.com.example;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);    }    // Used to load the &#39;native-lib&#39; library on application startup.    static {        System.loadLibrary(&quot;native-lib&quot;);    }    /**     * A native method that is implemented by the &#39;native-lib&#39; native library,     * which is packaged with this application.     */    public native String stringFromJNI();}</code></pre><p>其中在static静态代码块中会加载动态链接库。在一个方法前加上native关键字即表明该方法是一个jni方法，因而只有声明，没有实现，其具体实现在c/c++代码中。<br>找到cpp文件，打开后内容如下：</p><pre><code class="cpp">#include &lt;jni.h&gt;#include &lt;string&gt;extern &quot;C&quot;JNIEXPORT jstringJNICALLJava_zqc_com_example_MainActivity_stringFromJNI(        JNIEnv *env, jobject /* this */) {    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());}</code></pre><p>其中extern “C”表示在编译的时候导出为c语言的格式，JNIEXPORT表示该函数是可以导出的，可以由外部方法进行调用，这和dll类似，jstring表示返回值，JNICALL关键字表示这是一个jni方法，Java_zqc_com_example_MainActivity_stringFromJNI其中Java是固定格式，zqc_com_example_MainActivity是全类名，stringFromJNI是具体的方法名，具体参数：JNIEnv <em>env为env指针，调用jni的很多方法都需要该指针，jobject /</em> this */这个表示当前类的this指针，这里因为没用到就没有命名。<br>在以往开发中可能是把.h和.cpp分开了，这个是AS自动生成的，这里并没有单独生成.h文件。c/c++开发也有自己的结构，这里除了需要对外暴露接口的需要按照上面格式编写外，其他的都可以用古老的c/c++进行编写并遵循古老的结构。你可以先定义.h文件，然后在.cpp里面具体实现。<br>点击Build-&gt;Make Project（快捷键Ctrl+F9）即可生成动态链接库文件.so，其路径在：<br><img src="http://img.blog.csdn.net/20180201172808764?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>AS自动生成了Debug版和Release版，并且在各个版本中又生成了不同平台的.so文件。只能说这个AS太牛叉了~<br>之后运行工程，安装到手机上时就把对应的so也拷贝到了手机中了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前应该是绝大多数人都采用AndroidStudio进行开发，谷歌官方已经不再对Eclipse的ADT进行维护了。而AS是绝对强大的工具，当你选择Include C++ Support的时候，AS会将NDK开发的一切都下载下来。所以如果采用AS开发，那么你学NDK开发的话，只需要把Android开发需要安装的JDK，SDK，AS等工具安装好后，即可进行开发。这个系列教程我也采用AS进行讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Eclipse-NDK开发环境搭建&quot;&gt;&lt;a href=&quot;#1-Eclipse-NDK开发环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. Eclipse NDK开发环境搭建&quot;&gt;&lt;/a&gt;1. Eclipse NDK开发环境搭建&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android NDK开发，JNI开发" scheme="http://yoursite.com/tags/Android-NDK%E5%BC%80%E5%8F%91%EF%BC%8CJNI%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习课程资源</title>
    <link href="http://yoursite.com/2018/01/23/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%B5%84%E6%BA%90/"/>
    <id>http://yoursite.com/2018/01/23/深度学习课程资源/</id>
    <published>2018-01-23T14:40:46.000Z</published>
    <updated>2018-02-07T14:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前，深度学习和深度强化学习已经在实践中得到了广泛的运用。资源型博客sky2learn整理了15个深度学习和深入强化学习相关的在线课程，其中包括它们在自然语言处理（NLP），计算机视觉和控制系统中的应用教程。</p><p>这些课程涵盖了神经网络，卷积神经网络，循环网络和其变体，训练深度网络的困难，无监督表示学习，深度信念网络，深玻尔兹曼机器，深度Q学习，价值函数估计和优化以及蒙特卡洛树搜索等多种算法的基础知识。</p><p>吴恩达：深度学习专项</p><p>这系列课程侧重于讲解深度学习的基础和在不同领域的运用方式，如医疗健康，自动驾驶，手语阅读，音乐生成和自然语言处理等。课程共包含五个子课程，有视频讲座。同时，课程用户将获得使用TensorFlow解决实际问题的实践经验。</p><p>链接：<a href="https://www.coursera.org/specializations/deep-learning" target="_blank" rel="noopener">https://www.coursera.org/specializations/deep-learning</a></p><p>CMU: 深度学习</p><p>该课程由苹果人工智能研究所主任Ruslan Salakhutdinov主导。课程首先讲解了一些例如前馈神经网络、反向传播、卷积模型等的基本知识。然后介绍深度学习中的要点，包括有向图和无向图模型，独立成分分析（ICA），稀疏编码，自动编码器，限制玻尔兹曼机（RBM），蒙特卡罗方法，深度信念网络，深度玻尔兹曼机和亥姆霍兹机。其他内容包括深度网络中的正则化和优化、序列建模和深度强化学习。</p><p>链接：<a href="http://www.cs.cmu.edu/~rsalakhu/10707/" target="_blank" rel="noopener">http://www.cs.cmu.edu/~rsalakhu/10707/</a></p><p>斯坦福大学：深度学习理论（Stat385）</p><p>本课程讨论深度学习理论方面的知识。有8次特邀嘉宾讲座，这些嘉宾是深度学习、计算神经科学和统计学方面的领军人物。您将有机会在深度学习中，针对当前的研究趋势，探索他们观点的多样性和跨学科性。这门课有视频讲座。</p><p>链接：<a href="https://stats385.github.io/" target="_blank" rel="noopener">https://stats385.github.io/</a></p><p>Yoshua Bengio: 深度学习</p><p>该课程由蒙特利尔大学主导。课程首先回顾了神经网络的基本知识，包括感知器，反向传播算法和梯度优化。然后介绍了神经网络、概率图形模型、深度网络和表示学习等前沿知识。</p><p>链接：<a href="https://ift6266h16.wordpress.com/" target="_blank" rel="noopener">https://ift6266h16.wordpress.com/</a></p><p>UC Berkeley: 深度强化学习</p><p>该课程包括强化学习的基本知识：Q-学习和策略梯度，同时还包含了高级模型学习和预测、提取、奖励学习以及高级深度强化学习，例如信赖域策略梯度方法、actor-critic方法、探索方法。本门课有视频讲座。</p><p>链接：<a href="http://rll.berkeley.edu/deeprlcourse/" target="_blank" rel="noopener">http://rll.berkeley.edu/deeprlcourse/</a></p><p>Yoshua Bengio: 深度学习与强化学习暑期学校</p><p>暑期学校是由Yoshua Bengio和他的同事们组织。课程包括了深度学习和强化学习两个方向，内容有两个领域的基本知识，研究趋势和最新发现。课程特别邀请这两个领域的主要学者和研究人员进行讲解。暑期学校有视频讲座。</p><p>链接：<a href="https://mila.quebec/en/cours/deep-learning-summer-school-2017/" target="_blank" rel="noopener">https://mila.quebec/en/cours/deep-learning-summer-school-2017/</a></p><p>Google &amp; Udacity: 深度学习</p><p>该课程由谷歌首席科学家Vincent Vanhoucke和Udacity的Arpan Chakraborty共同创立。课程内容包括深度学习、深层神经网络、卷积神经网络和针对文本和序列的深层模型。课程作业要求使用tensorflow。这门课有视频讲座。</p><p>链接：<a href="https://cn.udacity.com/course/deep-learning--ud730" target="_blank" rel="noopener">https://cn.udacity.com/course/deep-learning--ud730</a></p><p>斯坦福大学：基于深度学习的自然语言处理（CS224n）</p><p>该课程是2017年冬斯坦福大学 “cs224n：深度学习中的自然语言处理”课程的压缩版，也是斯坦福大学2018课程的延续版。课程讨论了如何将深度学习应用在自然语言处理中，自然语言处理中的问题以及在自然语言处理中使用深度学习的限制。讲师有Christopher Manning和Richard Socher。</p><p>链接：<br><a href="https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PL3FW7Lu3i5Jsnh1rnUwq_TcylNr7EkRe6</a></p><p>牛津大学：自然语言处理中的深度学习</p><p>本课程涵盖深度学习的基本原理以及如何将其应用在自然语言处理中。用户将学习如何定义这个领域中的数学问题，以及获得使用CPU和GPU的实际编程的经验。讲师分别来自牛津大学、CMU、DeepMind和英伟达公司。 这门课程包括视频讲座。</p><p>链接：<a href="https://github.com/oxford-cs-deepnlp-2017/lectures" target="_blank" rel="noopener">https://github.com/oxford-cs-deepnlp-2017/lectures</a></p><p>李飞飞：视觉识别中的卷积神经网络（cs231n）</p><p>本课程将涵盖深度学习的基础知识，以及如何将深度学习技术应用于计算机视觉。学生将通过作业和最终项目获得如何训练和微调神经网络的实践经验。该课程主要使用Python语言。本课程包括视频讲座。</p><p>链接：<a href="http://cs231n.stanford.edu/" target="_blank" rel="noopener">http://cs231n.stanford.edu/</a></p><p>CMU: 深度强化学习与控制</p><p>本课程由苹果人工智能研究所主任Ruslan salakhutdinovat和CMU的Katerina Fragkiadaki主导。内容包括深度学习，强化学习，马尔可夫链决策过程（MDP），部分可观马尔可夫链决策过程（POMDPs），时序差分学习，Q学习，深度学习，深刻Q学习的基础知识。前沿话题包括最优化控制、轨道优化、层次强化学习和迁移学习。</p><p>链接：<a href="https://katefvision.github.io/" target="_blank" rel="noopener">https://katefvision.github.io/</a></p><p>CMU: 深度学习入门</p><p>本课程由苹果公司人工智能研究所主任Ruslan Salakhutdinov主导，对深度学习做了一个快速而深入的介绍。课程共分为四个一小时时长的视频讲座，涵盖了监督学习，无监督学习，以及深度学习中的模型评估和开放式的研究问题等内容。</p><p>链接：<a href="https://simons.berkeley.edu/talks/tutorial-deep-learning" target="_blank" rel="noopener">https://simons.berkeley.edu/talks/tutorial-deep-learning</a></p><p>RLDM: 深度强化学习入门</p><p>课程由DeepMind的David Silver主导，发表于第二届强化学习与决策多学科会议（RLDM）上。在这一个半小时的视频教程中，用户将了解深度学习，强化学习的基本原理，以及如何将深度学习和强化学习以各种方式结合：即深度价值函数，深度策略，和深度模型。此外，用户还能向顶级专家学习如何处理这些方法中的发散问题。</p><p>链接：<a href="http://videolectures.net/rldm2015_silver_reinforcement_learning/" target="_blank" rel="noopener">http://videolectures.net/rldm2015_silver_reinforcement_learning/</a></p><p>UC Berkeley: 深度强化学习入门</p><p>这是一个关于强化学习长达一小时的教程，配有视频讲座。用户将看到强化学习能有多厉害。</p><p>链接：<a href="https://simons.berkeley.edu/talks/pieter-abbeel-2017-3-28" target="_blank" rel="noopener">https://simons.berkeley.edu/talks/pieter-abbeel-2017-3-28</a></p><p>MLSS: 深度强化学习入门</p><p>课程由OpenAI公司的研究科学家John Schulman主导，包括4个1小时长的视频讲座，并带有针对实验室问题的练习。</p><p>链接：<br><a href="https://www.youtube.com/playlist?list=PLjKEIQlKCTZYN3CYBlj8r58SbNorobqcp" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLjKEIQlKCTZYN3CYBlj8r58SbNorobqcp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目前，深度学习和深度强化学习已经在实践中得到了广泛的运用。资源型博客sky2learn整理了15个深度学习和深入强化学习相关的在线课程，其中包括它们在自然语言处理（NLP），计算机视觉和控制系统中的应用教程。&lt;/p&gt;
&lt;p&gt;这些课程涵盖了神经网络，卷积神经网络，循环网络和其
      
    
    </summary>
    
      <category term="人工智能" scheme="http://yoursite.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="深度学习 吴恩达" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>国内配置gradle</title>
    <link href="http://yoursite.com/2018/01/22/%E5%9B%BD%E5%86%85%E9%85%8D%E7%BD%AEgradle/"/>
    <id>http://yoursite.com/2018/01/22/国内配置gradle/</id>
    <published>2018-01-22T14:14:45.000Z</published>
    <updated>2018-02-07T14:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知zf是怎么想的，为何要把Google developer给q了，导致Android开发很痛苦，如果不fq，那么gradle里面库就没法下载，不过感谢阿里云，在国内搭建了一个国内的gradle仓库。下面就配置一下国内的gradle仓库</p><h3 id="1-单个项目配置"><a href="#1-单个项目配置" class="headerlink" title="1. 单个项目配置"></a>1. 单个项目配置</h3><p>用这种方式仅对单个项目生效，不会影响其他的项目</p><pre><code class="xml">buildscript {    repositories {        maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }                maven{ url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}    }    dependencies {        classpath &#39;com.android.tools.build:gradle:2.2.3&#39;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }        }allprojects {    repositories {        maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }        maven{ url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;}    }}</code></pre><h3 id="2-配置对所有项目生效"><a href="#2-配置对所有项目生效" class="headerlink" title="2. 配置对所有项目生效"></a>2. 配置对所有项目生效</h3><p>在USER_HOME/.gradle/下创建init.gradle文件，填入以下内容：</p><pre><code class="xml">allprojects{    repositories {        def ALIYUN_REPOSITORY_URL = &#39;http://maven.aliyun.com/nexus/content/groups/public&#39;        def ALIYUN_JCENTER_URL = &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;        all { ArtifactRepository repo -&gt;            if(repo instanceof MavenArtifactRepository){                def url = repo.url.toString()                if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;)) {                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_REPOSITORY_URL.&quot;                    remove repo                }                if (url.startsWith(&#39;https://jcenter.bintray.com/&#39;)) {                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $ALIYUN_JCENTER_URL.&quot;                    remove repo                }            }        }        maven {                url ALIYUN_REPOSITORY_URL            url ALIYUN_JCENTER_URL        }    }}</code></pre><p>这样新建项目时用的gradle仓库也是阿里云的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知zf是怎么想的，为何要把Google developer给q了，导致Android开发很痛苦，如果不fq，那么gradle里面库就没法下载，不过感谢阿里云，在国内搭建了一个国内的gradle仓库。下面就配置一下国内的gradle仓库&lt;/p&gt;
&lt;h3 id=&quot;1-单个项目
      
    
    </summary>
    
      <category term="gradle" scheme="http://yoursite.com/categories/gradle/"/>
    
    
      <category term="gradle配置" scheme="http://yoursite.com/tags/gradle%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Android中onSaveInstanceState和onRestoreInstanceState讲解</title>
    <link href="http://yoursite.com/2018/01/19/Android%E4%B8%ADonSaveInstanceState%E5%92%8ConRestoreInstanceState%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/19/Android中onSaveInstanceState和onRestoreInstanceState讲解/</id>
    <published>2018-01-19T10:21:47.000Z</published>
    <updated>2018-01-19T16:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Android系统中，有时系统可能因为系统资源不够而杀死(kill)某些Activity，在kill Activity之前会调用 onSaveInstanceState来保存一些状态信息(当然也可以保存其他信息)，当再次回到该Activity时，系统会调用onRestoreInstanceState来恢复数据。<br>     下面先讲一下onSaveInstance的调用时机，也就是会在什么情况下被调用。onSaveInstance不是Activity正常生命周期里面的函数。在Google API文档上是这样介绍的： Android calls onSaveInstanceState() before the activity becomesvulnerable to being destroyed by the system, but does not bother calling itwhen the instance is actually being destroyed by a user action (such aspressing the BACK key)。也就是当某个activity变得“容易”被系统销毁时，该activity的onSaveInstanceState就会被执行，除非该activity是被用户主动销毁的该方法不会调用，例如当用户按BACK键的时候。“容易”包含以下几种情况：<br>1、当用户按下HOME键时。当按下HOME键后，由于系统不知道用户会新开多少程序，因而这个Activity可能会由于系统资源不足而被系统kill，因为在onPause之后会调用onSaveInstance来保存数据。<br>2、长按HOME键，选择运行其他的程序时。分析同上。<br>3、按下电源按键（关闭屏幕显示）时。分析同上。<br>4、从activity A中启动一个新的activity时。分析同上。<br>5、屏幕方向切换时，例如从竖屏切换到横屏时。在屏幕切换之前，系统会销毁activity A，在屏幕切换之后系统又会自动地创建activity A，所以onSaveInstanceState一定会被执行。</p><p>一般调用方式如下：</p><pre><code class="java">@Override      protected void onSaveInstanceState(Bundle outState) {          // TODO Auto-generated method stub          //这里保存需要保存的数据          String string = edit.getText().toString();          outState.putString(&quot;test&quot;, string);          super.onSaveInstanceState(outState);      }</code></pre><p>系统kill进程是有个先后顺序的：在Google上是这样介绍的<a href="https://developer.android.com/reference/android/app/Activity.html#ProcessLifecycle" target="_blank" rel="noopener">ProcessLifecycle</a>,其解释如下：<br>一般系统杀死进程的顺序是：</p><p>　　Android系统会尽力保持应用的进程，但是有时为了给新的进程和更重要的进程回收一些内存空间，它会移除一些旧的进程。</p><p>　　为了决定哪些进程留下，哪些进程被杀死，系统根据在进程中在运行的组件及组件的状态，为每一个进程分配了一个优先级等级。</p><p>　　优先级最低的进程首先被杀死。</p><p>　　这个进程重要性的层次结构有<strong>五个等级</strong>，下面就列出这五种进程，按照重要性来排列，最重要的放在最前。 </p><ol><li>前台进程 Foreground process<br><strong>前台进程</strong>是用户当前做的事所必须的进程，如果满足下面各种情况中的一种，一个进程被认为是在前台：<br>1.1 进程持有一个正在与用户交互的Activity（Activity正处于onResume()的状态）。<br>1.2 进程持有一个Service，这个Service和用户正在交互的Activity绑定。<br>1.3 进程持有一个Service，这个Service是在前台运行的，即它调用了<code>**[startForeground()](http://developer.android.com/reference/android/app/Service.html#startForeground(int, android.app.Notification))**</code>。<br>1.4 进程持有一个Service，这个Service正在执行它的生命周期回调函数（<code>[onCreate()](http://developer.android.com/reference/android/app/Service.html#onCreate())</code>, <code>[onStart()](http://developer.android.com/reference/android/app/Service.html#onStart(android.content.Intent, int))</code>, or <code>[onDestroy()](http://developer.android.com/reference/android/app/Service.html#onDestroy())</code>）。<br>1.5 进程持有一个BroadcastReceiver，这个BroadcastReceiver正在执行它的 <code>[onReceive()](http://developer.android.com/reference/android/content/BroadcastReceiver.html#onReceive(android.content.Context, android.content.Intent))</code> 方法。<br>杀死前台进程需要用户交互，因为前台进程的优先级是最高的。</li></ol><p>2.可见进程 Visible process<br>　　如果一个进程不含有任何前台的组件，但是仍然影响着用户在屏幕上可以看到的内容，就是<strong>可见进程</strong>。<br>　　可见进程满足下列情况之一：<br>　　1.进程持有一个Activity，这个Activity不在前台，但是仍然被用户可见（处于<strong>onPause()</strong>调用后又没有调用<strong>onStop()</strong>的状态）。<br>　　这种情况发生在，比如，前台的activity打开了一个对话框，这样activity就会在其后可见。<br>　　2.进程持有一个Service，这个Service和一个可见的（或者前台的）Activity绑定。<br>　　可见的进程也被认为是很重要的，一般不会被销毁，除非是为了保证所有前台进程的运行而不得不杀死可见进程的时候。 </p><ol><li><p>服务进程 Service process<br>　　如果一个进程中运行着一个service，这个service是通过 <code>[startService()](http://developer.android.com/reference/android/content/Context.html#startService(android.content.Intent))</code> 开启的，并且不属于上面两种较高优先级的情况，这个进程就是一个<strong>服务进程</strong>。<br>　　尽管服务进程没有和用户可以看到的东西绑定，但是它们一般在做的事情是用户关心的，比如后台播放音乐，后台下载数据等。 </p></li><li><p>后台进程 Background process<br>　　如果进程不属于上面三种情况，但是进程持有一个用户不可见的activity（activity的<strong>onStop()</strong>被调用，但是<strong>onDestroy()</strong>没有调用的状态），就认为进程是一个<strong>后台进程</strong>。<br>　　后台进程不直接影响用户体验，系统会为了前台进程、可见进程、服务进程而任意杀死后台进程。<br>　　通常会有很多个后台进程存在，它们会被保存在一个<strong>LRU (least recently used)</strong>列表中，这样就可以确保用户最近使用的activity最后被销毁，即最先销毁时间最远的activity。 </p></li><li><p>空进程<br>　　如果一个进程不包含任何活跃的应用组件，则认为是<strong>空进程</strong>。<br>　　保存这种进程的唯一理由是为了缓存的需要，为了加快下次要启动这个进程中的组件时的启动时间。<br>　　系统为了平衡进程缓存和底层内核缓存的资源，经常会杀死空进程。 </p></li><li><p>相关说明<br>　　1.Android会尽可能地把进程放在高的优先级。<br>　　比如，一个进程拥有一个可见状态的activity和一个service，这个进程会被认为是可见进程，而不是服务进程。<br>　　2.一个进程的等级有可能会因为其他进程的依赖而提高，一个进程服务于另一个进程，则它的优先级不会比它服务的进程优先级低。<br>　　比如，A进程中的一个content provider向B进程中的一个客户提供服务，或A进程中的一个service被绑定在B进程中的一个组件上，则A进程的优先级<strong>至少</strong>和B进程的优先级一样高。<br>　　3.因为服务进程的优先级比后台进程的优先级高，所以对于一个需要启动一个长时间操作的activity来说，开启一个service比创建一个工作线程的方法更好，尤其是对于操作将很可能超出activity的持续时间时。<br>　　比如要上传一个图片文件，应该开启一个service来进行上传工作，这样在用户离开activity时工作仍在进行。使用service将会保证操作至少有服务进程的优先级。</p></li></ol><p>总而言之，onSaveInstanceState的调用遵循一个重要原则，即当系统“未经你许可”时销毁了你的activity，则onSaveInstanceState会被系统调用，这是系统的责任，因为它必须要提供一个机会让你保存你的数据。<br>onSaveInstanceState的调用是在onPause（）之后执行的，即：onPause（）—&gt;onSaveInstanceState()–&gt;onStop( );<br>至于onRestoreInstanceState方法，需要注意的是，onSaveInstanceState方法和onRestoreInstanceState方法“不一定”是成对的被调用的，onRestoreInstanceState被调用的前提是，activity A“确实”被系统销毁了，而如果仅仅是停留在有这种可能性的情况下，则该方法不会被调用，例如，当正在显示activity A的时候，用户按下HOME键回到主界面，然后用户紧接着又返回到activity A，这种情况下activity A一般不会因为内存的原因被系统销毁，故activity A的onRestoreInstanceState方法不会被执行。onRestoreInstanceState的bundle参数会传递到onCreate方法中，你也可以选择在onCreate方法中做数据还原。<br>onRestoreInstanceState()在onStart() 和 onPostCreate(Bundle)之间调用。<br>一般调用方式如下：</p><pre><code>@Override    protected void onRestoreInstanceState(Bundle savedInstanceState) {        // TODO Auto-generated method stub        //在Activity因为系统额崩溃后，会调用该函数进行数据恢复，恢复的数据就是通过onSaveInstanceState保存的数据        super.onRestoreInstanceState(savedInstanceState);        if (savedInstanceState!=null) {            String test = savedInstanceState.getString(&quot;test&quot;);            if (test!=null) {                edit.setText(test);            }        }    }</code></pre><p>在新版的SDK中，也就是API大于21的版本中新增了如下两个函数：</p><pre><code>/**     * 系统重启后，数据恢复能力。需要api&gt;21     */    @Override    public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) {        // TODO Auto-generated method stub        //这里保存持久化数据，该函数会调用上面一个函数。因而第一个outState会通过上一个函数保存        String string = edit.getText().toString();        outPersistentState.putString(&quot;test&quot;, string);        super.onSaveInstanceState(outState, outPersistentState);    }/**      * 系统重启后，数据恢复能力。需要api&gt;21就      * 这个方法会调用onRestoreInstanceState(Bundle savedInstanceState)方法。      */      @Override      public void onRestoreInstanceState(Bundle savedInstanceState, PersistableBundle persistentState) {          // TODO Auto-generated method stub          //系统因而意外重启后会调用该方法进行数据恢复，这个需要在manifest.xml里面注册： android:persistableMode=&quot;persistAcrossReboots&quot;          super.onRestoreInstanceState(savedInstanceState, persistentState);          if (persistentState!=null) {              String test = persistentState.getString(&quot;test&quot;);              if (test!=null) {                  edit.setText(test);              }          }      }</code></pre><p>这两个函数主要是为了系统重启后的数据恢复，使用时需要在AndroidManifest.xml里面的activity中添加android:persistableMode=”persistAcrossReboots”属性。PersistableBundle和Bundle差不多，是以key-value的形式使用的。具体代码见如下工程。</p><p>工程源码：<a href="http://download.csdn.net/detail/hty1053240123/9585928" target="_blank" rel="noopener">onSaveInstance测试工程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Android系统中，有时系统可能因为系统资源不够而杀死(kill)某些Activity，在kill Activity之前会调用 onSaveInstanceState来保存一些状态信息(当然也可以保存其他信息)，当再次回到该Activity时，系统会调用onRestor
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="onSaveInstanceState" scheme="http://yoursite.com/tags/onSaveInstanceState/"/>
    
  </entry>
  
  <entry>
    <title>AppLinks使用详解</title>
    <link href="http://yoursite.com/2018/01/18/AppLinks%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/18/AppLinks使用详解/</id>
    <published>2018-01-18T08:58:44.000Z</published>
    <updated>2018-01-22T13:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>官方介绍<a href="https://developer.android.com/training/app-links/verify-site-associations.html#the-difference" target="_blank" rel="noopener">Android App Links</a>内容是：</p><pre><code>Android App Links are a special type of deep link that allow your website URLs to immediately open the corresponding content in your Android app (without requiring the user to select the app).To add Android App Links to your app, define intent filters that open your app content using HTTP URLs (as described in [Create Deep Links to App Content]), and verify that you own both your app and the website URLs (as described in this guide). If the system successfully verifies that you own the URLs, the system automatically routes those URL intents to your app.</code></pre><p>意思就是AppLinks是一个特殊的DeepLink，它可以让你的应用和你的网站URL进行绑定，这样当你在点击你网站链接的时候（非浏览器中）就能调起你的App，而不是出现选择界面，使用方法如下<br><a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">Create Deep Links to App Content</a><br>这种绑定不是在点击的时候才核对链接，下面会介绍在什么情况下核对这种绑定的。</p><h3 id="2-与DeepLink的区别"><a href="#2-与DeepLink的区别" class="headerlink" title="2. 与DeepLink的区别"></a>2. 与DeepLink的区别</h3><p>官方是这样介绍DeepLink的。</p><pre><code>A [deep link] is an intent filter that allows users to directly enter a specific activity in your Android app. Clicking one of these links might open a disambiguation dialog, which allows the user to select one of multiple apps (including yours) that can hande the given URL. For example, figure 1 shows the disambiguation dialog after the user clicks a map link, asking whether to open the link in Maps or Chrome.</code></pre><p><a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">Deeplink</a>是一个intent过滤器，他可以使用户直接进入某个Activity页面。但是有个不好的是当匹配到多个intent时就会弹一个让用户选择的框。官方给了下面一张图，而AppLinks就不会有这个弹框：<br><img src="https://upload-images.jianshu.io/upload_images/7170430-1a711d54789310a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" width="200" height="400" alt="The disambiguation dialog" align="center"><br>具体区别官方也列了以下：</p><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:center">Deep links</th><th style="text-align:left">App links</th></tr></thead><tbody><tr><td style="text-align:left">Intent URL</td><td style="text-align:center">scheme    http, https, or a custom scheme</td><td style="text-align:left">Requires http or https</td></tr><tr><td style="text-align:left">Intent action</td><td style="text-align:center">Any action</td><td style="text-align:left">Requires android.intent.action.VIEW</td></tr><tr><td style="text-align:left">Intent category</td><td style="text-align:center">Any category</td><td style="text-align:left">Requires android.intent.category.BROWSABLE and android.intent.category.DEFAULT</td></tr><tr><td style="text-align:left">Link verification</td><td style="text-align:center">None</td><td style="text-align:left">Requires a Digital Asset Links file served on you website with HTTPS</td></tr><tr><td style="text-align:left">User experience</td><td style="text-align:center">May show a disambiguation dialog for the user to select which app to open the link</td><td style="text-align:left">No dialog; your app opens to handle your website links</td></tr><tr><td style="text-align:left">Compatibility</td><td style="text-align:center">All Android versions</td><td style="text-align:left">Android 6.0 and higher</td></tr></tbody></table><h3 id="3-使用步骤"><a href="#3-使用步骤" class="headerlink" title="3.使用步骤"></a>3.使用步骤</h3><p>官方给的步骤如下<a href="https://developer.android.com/training/app-links/index.html" target="_blank" rel="noopener">Handling Android App Links</a></p><h4 id="3-1-在manifest中开启autoVerify"><a href="#3-1-在manifest中开启autoVerify" class="headerlink" title="3.1 在manifest中开启autoVerify"></a>3.1 在manifest中开启autoVerify</h4><pre><code>&lt;activity ...&gt;    &lt;intent-filter android:autoVerify=&quot;true&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;        &lt;data android:scheme=&quot;http&quot; android:host=&quot;www.example.com&quot; /&gt;        &lt;data android:scheme=&quot;https&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>这里注意下，开启autoVerify的activity中的<intent-filter..>的action必须为android.intent.action.VIEW，category必须包含android.intent.category.BROWSABLE，data的scheme必须包含http/https,否则不生效，而且AppLinks必须在Android 6.0 以上的手机才可生效。验证包含以下几方面：</intent-filter..></p><ol><li>系统会检查包含以下几方面的所有intent-filter</li></ol><ul><li>Action: android.intent.action.VIEW</li><li>Categories: android.intent.category.BROWSABLE and android.intent.category.DEFAULT</li><li>Data scheme: http or https</li></ul><ol><li>原话是：For each unique host name found in the above intent filters, Android queries the corresponding websites for the Digital Asset Links file at <a href="https://hostname/.well-known/assetlinks.json.。翻译过来就是系统会读取网站的/.well-known/assetlinks.json文件，然后验证包名和签名是否包含在assetlinks.json文件中。" target="_blank" rel="noopener">https://hostname/.well-known/assetlinks.json.。翻译过来就是系统会读取网站的/.well-known/assetlinks.json文件，然后验证包名和签名是否包含在assetlinks.json文件中。</a></li></ol><p>当且仅当上面两个条件满足时才会形成绑定。</p><h4 id="3-2-支持多hosts的绑定。"><a href="#3-2-支持多hosts的绑定。" class="headerlink" title="3.2 支持多hosts的绑定。"></a>3.2 支持多hosts的绑定。</h4><pre><code class="xml">&lt;intent-filter&gt;  ...  &lt;data android:scheme=&quot;https&quot; android:host=&quot;www.example.com&quot; /&gt;  &lt;data android:scheme=&quot;app&quot; android:host=&quot;open.my.app&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>上面在同一个<intent-filter ..="">里面写的两个<data ..="">，他们除了组合<a href="https://www.example.com和app://open.my.app外app://www.example.com和" target="_blank" rel="noopener">https://www.example.com和app://open.my.app外app://www.example.com和</a> <a href="https://open.my.app也是满足上面的" target="_blank" rel="noopener">https://open.my.app也是满足上面的</a><intent-filter ..="">的。而分开写的时候，不存在上面的问题。</intent-filter></data></intent-filter></p><h4 id="3-3-在网站上创建assetlinks-json文件"><a href="#3-3-在网站上创建assetlinks-json文件" class="headerlink" title="3.3 在网站上创建assetlinks.json文件"></a>3.3 在网站上创建assetlinks.json文件</h4><p>具体格式如下：</p><pre><code>[{  &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],  &quot;target&quot;: {    &quot;namespace&quot;: &quot;android_app&quot;,    &quot;package_name&quot;: &quot;com.example&quot;,    &quot;sha256_cert_fingerprints&quot;:    [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;]  }}]</code></pre><p>其中package_name就是应用的包名，sha256_cert_fingerprints为正式版的签名。上传时修改这两个属性值。如果一个应用对于多个网站时，可以配置多个对象，配置如下：</p><pre><code>[{  &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],  &quot;target&quot;: {    &quot;namespace&quot;: &quot;android_app&quot;,    &quot;package_name&quot;: &quot;com.example.puppies.app&quot;,    &quot;sha256_cert_fingerprints&quot;:    [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;]  }  },  {  &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],  &quot;target&quot;: {    &quot;namespace&quot;: &quot;android_app&quot;,    &quot;package_name&quot;: &quot;com.example.monkeys.app&quot;,    &quot;sha256_cert_fingerprints&quot;:    [&quot;14:6D:E9:83:C5:73:06:50:D8:EE:B9:95:2F:34:FC:64:16:A0:83:42:E6:1D:BE:A8:8A:04:96:B2:3F:CF:44:E5&quot;]  }}]</code></pre><p>然后将该文件放在网站的.well-known目录下，放了之后要试试能不能用：</p><pre><code>https://domain.name/.well-known/assetlinks.json</code></pre><p>提交完后确定以下几个是否正确：</p><pre><code>Be sure of the following:*   The `assetlinks.json` file is served with content-type `application/json`.*   The `assetlinks.json` file must be accessible over an HTTPS connection, regardless of whether your app&#39;s intent filters declare HTTPS as the data scheme.*   The `assetlinks.json` file must be accessible without any redirects (no 301 or 302 redirects) and be accessible by bots (your `robots.txt` must allow crawling `/.well-known/assetlinks.json`).*   If your app links support multiple host domains, then you must publish the `assetlinks.json` file on each domain. See [Supporting app linking for multiple hosts](https://developer.android.com/training/app-links/verify-site-associations.html#multi-host).*   Do not publish your app with dev/test URLs in the manifest file that may not be accessible to the public (such as any that are accessible accessible only with a VPN). A work-around in such cases is to [configure build variants](https://developer.android.com/studio/build/build-variants.html) to generate a different manifest file for dev builds</code></pre><p>还有AppLinks仅支持https的网站。</p><h4 id="3-4-测试AppLinks"><a href="#3-4-测试AppLinks" class="headerlink" title="3.4 测试AppLinks"></a>3.4 测试AppLinks</h4><ol><li>测试json文件是否正确，请看 <a href="https://developers.google.com/digital-asset-links/tools/generator" target="_blank" rel="noopener">Statement List Generator and Tester</a><br>也可以采用以下链接进行验证：<pre><code>https://digitalassetlinks.googleapis.com/v1/statements:list?source.web.site=https://domain.name:optional_port&amp;relation=delegate_permission/common.handle_all_urls</code></pre></li><li>测试intent是否正确<br>可以使用adb进行测试，命令如下：<pre><code>adb shell am start -a android.intent.action.VIEW \ -c android.intent.category.BROWSABLE \ -d &quot;http://domain.name:optional_port&quot;</code></pre>下面命令测试已经存在的绑定：<pre><code>adb shell dumpsys package domain-preferred-apps</code></pre>上面命令等价于：<pre><code>adb shell dumpsys package d</code></pre>如果存在绑定的会显示如下结果：<pre><code>Package: com.android.vendingDomains: play.google.com market.android.comStatus: always : 200000002</code></pre>参数含义如下：<br>```</li></ol><ul><li>Package - Identifies an app by its package name, as declared in its manifest.</li><li>Domains - Shows the full list of hosts whose web links this app handles, using blank spaces as delimiters.</li><li>Status - Shows the current link-handling setting for this app. An app that has passed verification, and<br>whose manifest contains android:autoVerify=”true”, shows a status of always. The hexadecimal number after<br>this status is related to the Android system’s record of the user’s app linkage preferences. This value does<br>not indicate whether verification succeeded.<br>```</li></ul><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>优点：</li></ol><ul><li>不会弹选择框</li><li>可以直接通过url跳到对应的activity</li></ul><ol><li>缺点：</li></ol><ul><li>网站需要支持https</li><li>有个校验过程，步骤麻烦些。</li></ul><p>使用该机制可以直接绕过intent方式，直接通过url就能打开对应的界面。不过在设置中还是能关闭这个。目前支持该功能的应用和网站还是很少。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;官方介绍&lt;a href=&quot;https://developer.android.com/training/app-link
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="AppLinks, DeepLinks" scheme="http://yoursite.com/tags/AppLinks-DeepLinks/"/>
    
  </entry>
  
  <entry>
    <title>DeepLink用法及原理解析</title>
    <link href="http://yoursite.com/2018/01/18/DeepLink%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/18/DeepLink用法及原理解析/</id>
    <published>2018-01-18T04:34:20.000Z</published>
    <updated>2018-01-18T13:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">DeepLink</a>官网上有这样的解释：</p><pre><code>When a clicked link or programmatic request invokes a web URI intent, the Android system tries each of the following actions, in sequential order, until the request succeeds:1.  Open the user&#39;s preferred app that can handle the URI, if one is designated.2.  Open the only available app that can handle the URI.3.  Allow the user to select an app from a dialog.Follow the steps below to create and test links to your content. You can also use the [App Links Assistant](https://developer.android.com/studio/write/app-link-indexing.html) in Android Studio to add Android App Links</code></pre><p>翻译后的意思就是：<br>当单击链接或编程请求调用Web URI意图时，Android系统按顺序依次尝试以下每一个操作，直到请求成功为止：</p><ol><li>打开用户首选的应用程序，它可以处理URI，如果指定的话。</li><li>打开可以处理URI的惟一可用应用程序。</li><li>允许用户从对话框中选择应用程序。</li></ol><p>意思也就是用户可以自己写一串字符串，系统会对该字符串进行解析，然后调起注册过相应scheme的应用，如果有多个注册了，那么就会弹出对话框让用户选择。</p><h3 id="2-用法"><a href="#2-用法" class="headerlink" title="2. 用法"></a>2. 用法</h3><p>Google官方给了一个样例：<a href="https://github.com/google/search-samples" target="_blank" rel="noopener">search-samples</a><br>以下根据Android官方的<a href="https://developer.android.com/training/app-links/deep-linking.html#adding-filters" target="_blank" rel="noopener">deep-linking</a>的样例来说明如何使用。</p><pre><code>&lt;activity    android:name=&quot;com.example.android.GizmosActivity&quot;    android:label=&quot;@string/title_gizmos&quot; &gt;    &lt;intent-filter android:label=&quot;@string/filter_view_http_gizmos&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;        &lt;!-- Accepts URIs that begin with &quot;http://www.example.com/gizmos” --&gt;        &lt;data android:scheme=&quot;http&quot;              android:host=&quot;www.example.com&quot;              android:pathPrefix=&quot;/gizmos&quot; /&gt;        &lt;!-- note that the leading &quot;/&quot; is required for pathPrefix--&gt;    &lt;/intent-filter&gt;    &lt;intent-filter android:label=&quot;@string/filter_view_example_gizmos&quot;&gt;        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;        &lt;!-- Accepts URIs that begin with &quot;example://gizmos” --&gt;        &lt;data android:scheme=&quot;example&quot;              android:host=&quot;gizmos&quot; /&gt;    &lt;/intent-filter&gt;&lt;/activity&gt;</code></pre><p>在上面有两个<intent-filter ..="">这两个<intent-filter ..="">只是在<data ..="">上有所区别，但是官方仍然建议我们分开写。比如：</data></intent-filter></intent-filter></p><pre><code class="xml">&lt;intent-filter&gt;  ...  &lt;data android:scheme=&quot;https&quot; android:host=&quot;www.example.com&quot; /&gt;  &lt;data android:scheme=&quot;app&quot; android:host=&quot;open.my.app&quot; /&gt;&lt;/intent-filter&gt;</code></pre><p>上面在同一个<intent-filter ..="">里面写的两个<data ..="">，他们除了组合<a href="https://www.example.com和app://open.my.app外app://www.example.com和" target="_blank" rel="noopener">https://www.example.com和app://open.my.app外app://www.example.com和</a> <a href="https://open.my.app也是满足上面的" target="_blank" rel="noopener">https://open.my.app也是满足上面的</a><intent-filter ..="">的。而分开写的时候，不存在上面的问题。<br>当你添加了上面的<intent-filter..>当你的Activity上面时，其他App，就可以通过一个intent去调起你的应用，官方这样说到：<br> Once you’ve added intent filters with URIs for activity content to your app manifest, Android is able to route any <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="noopener">Intent</a> that has matching URIs to your app at runtime.<br>当注册了<intent-filter..>后，便可以在Activity的中获取其他应用传过来的intent值，具体调用如下：</intent-filter..></intent-filter..></intent-filter></data></intent-filter></p><pre><code>@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.main);    Intent intent = getIntent();    String action = intent.getAction();    Uri data = intent.getData();}</code></pre><p>getIntent可以在Activity的生命周期的任何时段进行获取，不过一般别人应用要调你应用，肯定都是希望进入你的应用某个界面，或实现某个功能。其他应用会把该传的信息都传给你，最好的解析地方肯定是onCreate（或onStart但onStart还是会晚一些）。对于这个官方给了以下建议：</p><pre><code>*   The deep link should take users directly to the content, without any prompts, interstitial pages, or logins. Make sure that users can see the app content even if they never previously opened the application. It is okay to prompt users on subsequent interactions or when they open the app from the Launcher. This is the same principle as the [first click free](https://support.google.com/webmasters/answer/74536?hl=en) experience for web sites.*   Follow the design guidance described in [Navigation with Back and Up](https://developer.android.com/design/patterns/navigation.html) so that your app matches users&#39; expectations for backward navigation after they enter your app through a deep link</code></pre><p>意思就是：</p><ol><li>打开应用后应该直接到内容，不要有任何提示，间接的页面，或登录。确保用户可以看到应用程序的内容，即使他们以前从未打开过应用程序。可以在随后的交互中提示用户，或者在启动程序中打开应用程序。这与网站第一次点击免费体验的原理是相同的。</li><li>遵循导航与后退和向上描述的设计指南，使您的应用程序与用户通过向后链接进入您的应用程序的深度导航的期望相符。</li></ol><p>实现上面代码后就可以进行测试了。在测试时可以使用adb的shell命令进行测试，语法格式如下：</p><pre><code>$ adb shell am start        -W -a android.intent.action.VIEW        -d &lt;URI&gt; &lt;PACKAGE&gt;</code></pre><p>例如我们上面的例子就可以采用如下方式进行打开：</p><pre><code>$ adb shell am start        -W -a android.intent.action.VIEW        -d &quot;example://gizmos&quot; com.example.android</code></pre><p>上面的intent也可以通过浏览器里面的网页进行设置，现在浏览器都会解析这个intent然后调起对应的应用，即可以直接在网页中调起应用。</p><p>DeepLink使得开发网站和自己的App能很好的相互交互。而且一个intent字符串也好发送，比如你想推广你的App，你就可以把这个intent发给广告商，然后点击的时候就把这个intent给手机浏览器，通过浏览器调起你自己的应用。这个最好的应用还在搜索上，在搜索的时候，当用户搜到对应内容的时候，现在一般都是跳网站。但是如果有DeepLink，那么就可以直接通过DeepLink的intent直接跳转到你自己的App，这既方便了用户，也方便了开发者。</p><h3 id="3-DeepLink原理分析"><a href="#3-DeepLink原理分析" class="headerlink" title="3. DeepLink原理分析"></a>3. DeepLink原理分析</h3><h4 id="3-1-DeepLinkDispatch框架"><a href="#3-1-DeepLinkDispatch框架" class="headerlink" title="3.1 DeepLinkDispatch框架"></a>3.1 DeepLinkDispatch框架</h4><p><a href="https://github.com/airbnb/DeepLinkDispatch" target="_blank" rel="noopener">DeepLinkDispatch</a>是Airbnb推出的一个以注解形式来实现dispatch跳转的框架。这个它的简单介绍<a href="https://github.com/airbnb/DeepLinkDispatch/blob/master/README.md" target="_blank" rel="noopener">README.md</a>。</p><h4 id="3-2-Dispatch框架使用例子"><a href="#3-2-Dispatch框架使用例子" class="headerlink" title="3.2 Dispatch框架使用例子"></a>3.2 Dispatch框架使用例子</h4><pre><code>@DeepLink(&quot;foo://example.com/deepLink/{id}&quot;)public class MainActivity extends Activity {  @Override protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Intent intent = getIntent();    if (intent.getBooleanExtra(DeepLink.IS_DEEP_LINK, false)) {      Bundle parameters = intent.getExtras();      String idString = parameters.getString(&quot;id&quot;);      // Do something with idString    }  }}</code></pre><p>多个<intent-filter..>的注解</intent-filter..></p><pre><code>//多filter的注解@DeepLink({&quot;foo://example.com/deepLink/{id}&quot;, &quot;foo://example.com/anotherDeepLink&quot;})public class MainActivity extends Activity {  @Override protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    Intent intent = getIntent();    if (intent.getBooleanExtra(DeepLink.IS_DEEP_LINK, false)) {      Bundle parameters = intent.getExtras();      String idString = parameters.getString(&quot;id&quot;);      // Do something with idString    }  }}</code></pre><p>某个方法的注解：</p><pre><code>@DeepLink(&quot;foo://example.com/methodDeepLink/{param1}&quot;)public static Intent intentForDeepLinkMethod(Context context, Bundle extras) {  Uri.Builder uri = Uri.parse(extras.getString(DeepLink.URI)).buildUpon();  return new Intent(context, MainActivity.class)      .setData(uri.appendQueryParameter(&quot;bar&quot;, &quot;baz&quot;).build())      .setAction(ACTION_DEEP_LINK_METHOD);}</code></pre><p>上面的注解相当于DeepLink中在manifest中的Activity标签下注册的<intent-filter..>，在DeepLinkDispatch中还可以注册一个广播接收者来接收分发的DeepLink字符串。</intent-filter..></p><pre><code>public class DeepLinkReceiver extends BroadcastReceiver {  private static final String TAG = &quot;DeepLinkReceiver&quot;;  @Override public void onReceive(Context context, Intent intent) {    String deepLinkUri = intent.getStringExtra(DeepLinkHandler.EXTRA_URI);    if (intent.getBooleanExtra(DeepLinkHandler.EXTRA_SUCCESSFUL, false)) {      Log.i(TAG, &quot;Success deep linking: &quot; + deepLinkUri);    } else {      String errorMessage = intent.getStringExtra(DeepLinkHandler.EXTRA_ERROR_MESSAGE);      Log.e(TAG, &quot;Error deep linking: &quot; + deepLinkUri + &quot; with error message +&quot; + errorMessage);    }  }}public class YourApplication extends Application {  @Override public void onCreate() {    super.onCreate();    IntentFilter intentFilter = new IntentFilter(DeepLinkHandler.ACTION);//使用应用内广播注册的，不用担心其他应用收到LocalBroadcastManager.getInstance(this).registerReceiver(new DeepLinkReceiver(), intentFilter);  }}</code></pre><p>下面就来分析下它的原理。</p><h4 id="3-3-源码剖析"><a href="#3-3-源码剖析" class="headerlink" title="3.3 源码剖析"></a>3.3 源码剖析</h4><h5 id="3-3-1-根据注解生成对应class文件"><a href="#3-3-1-根据注解生成对应class文件" class="headerlink" title="3.3.1 根据注解生成对应class文件"></a>3.3.1 根据注解生成对应class文件</h5><p>在AS点击build后即可生成对应的class文件，主要的文件有以下几个：<br><img src="http://upload-images.jianshu.io/upload_images/7170430-e37d53735359d7a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="class.png"><br>在DeepLinkDispatch框架中主要是通过DeepLinkDelegate代理来处理传来的Uri，在DeepLinkDelegate中主要是dispatchFrom这个方法来处理Uri。代码如下：<br><img src="http://upload-images.jianshu.io/upload_images/7170430-529f9c694ffff441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DeepLinkResult.png"></p><ol><li>收下根据getIntent.getData()即可获取到对应的uri。</li><li><p>然后通过DeepLinkLoader.load()来加载注册的uri。代码如下<br><img src="http://upload-images.jianshu.io/upload_images/7170430-d0a721dddf62777d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="load.png"></p></li><li><p>调用loader.parseUri去解析Uri，解析完成后返回的是DeepLinkEntry来供我们使用。</p></li><li><p>解析Uri中的key-value对，代码仍然在dispatchFrom中。<br><img src="http://upload-images.jianshu.io/upload_images/7170430-bde2577d977326c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseUri.png"></p></li></ol><p>其中DeepLinkUri.getParameters代码如下：<br><img src="http://upload-images.jianshu.io/upload_images/7170430-6ce444ecbe3230d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="getParameters.png"></p><p>然后调用了该类的parseParameters获取patterns集合。<br><img src="http://upload-images.jianshu.io/upload_images/7170430-db42ed45c5c28d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="parseParameters.png"></p><p>从DeepLink的intent中获取的就是key，具体跳转的内容就是value。</p><ol><li>DeepLinkUri.queryParameterNames<br>通过queryParameterNames就把真实的Uri解析成对应的注解了，之后就会进行分发逻辑了。</li><li>具体分发逻辑<br><img src="http://upload-images.jianshu.io/upload_images/7170430-96ae9b6d76b7a703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch.png"><br><img src="http://upload-images.jianshu.io/upload_images/7170430-e312d85d0fccc231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch1.png"><br>6.1 首先生成Intent对象<br>6.2 setAction和data，通过以上将action和data放入Intent中。<br>6.3 处理Bundle。<br>6.4 调用callingActivity。<br>6.5 startActivity<br>6.6 createResultAndNotify</li></ol><p>通过以上步骤就完成了DeepLink调起应用页面的操作了，具体代码稍后再贴。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol><li>DeepLink实现了网页直接和App直接跳转。之前手机上的每个App都相当于一个个孤岛，没有办法和广泛的网站实现直接的跳转。现在比如你在浏览微博的时候看到某个App上面有精彩的内容，你就可以直接点击链接跳转到App里面（甚至可以判断如果按照了App就进入App里面，如果不安装那么就进入应用市场的该App下载界面），这样的交互很方便，很好的将App连接到了整个网络世界，以后有个浏览器就能随意的跳转。</li><li>DeepLink完全可以在搜索中使用，目前的搜索都是搜到了内容还是调网页。以后如果开发者把自己的DeepLink链接提交给搜索公司，那么在搜索到对应的结果的时候就可以直接点击搜到的结果跳转到自己的App了。这个还能应用到广告上去。推广自己的App就更容易了。</li><li>DeepLink使得大企业的众多App之间相互拉活，相互跳转。假如某公司有个超级App，那么想推广自己的其他App就可以使用DeepLink在开启自己某个子页面的时候，把这个子页面交给其他App进行处理。这样就拉活了自己的其他App了。</li><li>在DeepLink的基础上，Google又新出了一个AppLinks，AppLinks就是你自己的网站和你自己的App相互关联了。比如用户在短信中点击了你的网站，那么就可以直接跳转到你的App，而不会出现选择对话框。Google官方是这样说的：<br>```<br>Android App Links are a special type of deep link that allow your website URLs to immediately open the<br>corresponding content in your Android app (without requiring the user to select the app).</li></ol><p>To add Android App Links to your app, define intent filters that open your app content using HTTP URLs (as<br> described in [Create Deep Links to App Content]), and verify that you own both your app and the website URLs (as described in this guide). If the<br>system successfully verifies that you own the URLs, the system automatically routes those URL intents to your app.<br>```<br>创建你自己的AppLinks，可以参考如下<a href="https://developer.android.com/training/app-links/deep-linking.html" target="_blank" rel="noopener">Create Deep Links to App Content</a>。后续我会专门写篇文章介绍下AppLinks及其用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com/training/app-links/de
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android DeepLink 源码解析" scheme="http://yoursite.com/tags/Android-DeepLink-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Android应用内部广播机制详解</title>
    <link href="http://yoursite.com/2018/01/17/Android%E5%BA%94%E7%94%A8%E5%86%85%E9%83%A8%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/17/Android应用内部广播机制详解/</id>
    <published>2018-01-17T10:07:47.000Z</published>
    <updated>2018-01-17T15:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>通常我们在使用Android广播的时候都会直接将广播注册到系统的AMS当中，由于AMS任务繁忙，一般可能不会立即能处理到我们发出的广播，如果我们使用广播是在应用内的单个进程中使用，则完全可以采用LocalBroadcastManager来处理。LocalBroadcastManager采用的是Handler的消息机制来处理的广播，而注册到系统中的是通过Binder机制实现的，速度是应用内广播要快很多。不过由于Handler的消息机制是为了同一个进程的多线程间进行通信的，因而跨进程时无法使用应用内广播。</p><h4 id="1-1-使用"><a href="#1-1-使用" class="headerlink" title="1.1 使用"></a>1.1 使用</h4><p>在使用上和普通的Broadcast类似，主要分5步。具体如下：</p><pre><code class="java">//1. 自定义广播接收者public class LocalReceiver extends BroadcastReceiver {    public void onReceive(Context context, Intent intent) {        ...    }}LocalReceiver localReceiver = new LocalReceiver();//2. 注册广播LocalBroadcastManager.getInstance(context)             .registerReceiver(localReceiver, new IntentFilter(“test”));//4. 发送广播LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(&quot;test&quot;));//5. 取消注册广播LocalBroadcastManager.getInstance(context).unregisterReceiver(localReceiver);</code></pre><p>自定义广播和普通的广播一样，在注册广播的时候将该广播接受者注册到LocalBroadcatManager中。当发生时也是调用LocalBroadcastManager的sendBroadcast进行发生。同样在不使用时记得取消广播注册。</p><h3 id="2-LocalBroadcastManager"><a href="#2-LocalBroadcastManager" class="headerlink" title="2. LocalBroadcastManager"></a>2. LocalBroadcastManager</h3><h4 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h4><p>LocalBroadcastManager采用的是单例模式，其构造函数是私有的，获取该类实例的方法是getInstance，具体代码如下：</p><pre><code class="java">  private final Handler mHandler;    private static final Object mLock = new Object();    private static LocalBroadcastManager mInstance;    public static LocalBroadcastManager getInstance(Context context) {        synchronized (mLock) {            if (mInstance == null) {                mInstance = new LocalBroadcastManager(context.getApplicationContext());            }            return mInstance;        }    }    private LocalBroadcastManager(Context context) {        mAppContext = context;        //mHandler是主线程的        mHandler = new Handler(context.getMainLooper()) {            @Override            public void handleMessage(Message msg) {                switch (msg.what) {                    case MSG_EXEC_PENDING_BROADCASTS:                        executePendingBroadcasts();//这里去执行广播分发                        break;                    default:                        super.handleMessage(msg);                }            }        };    }</code></pre><p>在构造函数中创建了一个mHandler，该mHandler关联的是主线程的Looper。即消息处理时都在主线程中处理。</p><h4 id="2-2-registerReceiver"><a href="#2-2-registerReceiver" class="headerlink" title="2.2 registerReceiver"></a>2.2 registerReceiver</h4><pre><code class="java">public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {        //在注册，取消注册，发送广播的时候都需要先获取mReceivers的锁        synchronized (mReceivers) {            //新建一个ReceiverRecord实体表示该receiver及对应的filter            ReceiverRecord entry = new ReceiverRecord(filter, receiver);            //获取receiver对应的filters            ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver);            if (filters == null) {                //如果该receiver没有对应的filters则，新建一个。                filters = new ArrayList&lt;IntentFilter&gt;(1);                mReceivers.put(receiver, filters);            }            //将filter放入该receiver对应的filters中            filters.add(filter);            for (int i=0; i&lt;filter.countActions(); i++) {                String action = filter.getAction(i);                ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);                if (entries == null) {                    entries = new ArrayList&lt;ReceiverRecord&gt;(1);                    //将action放入mActions中                    mActions.put(action, entries);                }                entries.add(entry);            }        }    }</code></pre><p>注册的时候也就是将receiver自己和对应的filter及action放入到mReceivers和mActions当中。代码比较简单。</p><h4 id="2-3-发送广播sendBroadcast"><a href="#2-3-发送广播sendBroadcast" class="headerlink" title="2.3 发送广播sendBroadcast"></a>2.3 发送广播sendBroadcast</h4><pre><code class="java">public boolean sendBroadcast(Intent intent) {        synchronized (mReceivers) {            final String action = intent.getAction();            final String type = intent.resolveTypeIfNeeded(                    mAppContext.getContentResolver());            final Uri data = intent.getData();            final String scheme = intent.getScheme();            final Set&lt;String&gt; categories = intent.getCategories();            final boolean debug = DEBUG ||                    ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);            if (debug) Log.v(                    TAG, &quot;Resolving type &quot; + type + &quot; scheme &quot; + scheme                    + &quot; of intent &quot; + intent);            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());            if (entries != null) {                if (debug) Log.v(TAG, &quot;Action list: &quot; + entries);                ArrayList&lt;ReceiverRecord&gt; receivers = null;                for (int i=0; i&lt;entries.size(); i++) {                    ReceiverRecord receiver = entries.get(i);                    if (debug) Log.v(TAG, &quot;Matching against filter &quot; + receiver.filter);                    if (receiver.broadcasting) {                        if (debug) {                            Log.v(TAG, &quot;  Filter&#39;s target already added&quot;);                        }                        continue;                    }                    int match = receiver.filter.match(action, type, scheme, data,                            categories, &quot;LocalBroadcastManager&quot;);                    if (match &gt;= 0) {                        if (debug) Log.v(TAG, &quot;  Filter matched!  match=0x&quot; +                                Integer.toHexString(match));                        if (receivers == null) {                            receivers = new ArrayList&lt;ReceiverRecord&gt;();                        }                        receivers.add(receiver);                        receiver.broadcasting = true;                    } else {                        if (debug) {                            String reason;                            switch (match) {                                case IntentFilter.NO_MATCH_ACTION: reason = &quot;action&quot;; break;                                case IntentFilter.NO_MATCH_CATEGORY: reason = &quot;category&quot;; break;                                case IntentFilter.NO_MATCH_DATA: reason = &quot;data&quot;; break;                                case IntentFilter.NO_MATCH_TYPE: reason = &quot;type&quot;; break;                                default: reason = &quot;unknown reason&quot;; break;                            }                            Log.v(TAG, &quot;  Filter did not match: &quot; + reason);                        }                    }                }                if (receivers != null) {                    for (int i=0; i&lt;receivers.size(); i++) {                        receivers.get(i).broadcasting = false;                    }                    mPendingBroadcasts.add(new BroadcastRecord(intent, receivers));                    if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) {                        mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);                    }                    return true;                }            }        }        return false;    }</code></pre><p>主要步骤：1.根据Intent的action来查询相应的广播接收者列表；<br>2.创建相应广播，添加到mPendingBroadcasts队列；<br>3.发送MSG_EXEC_PENDING_BROADCASTS消息。将消息传给主线程进行处理。<br>4.主线程mHandler接受到后就由该类的handlerMessage进行处理。在该方法中调用executePendingBroadcasts()进行处理</p><pre><code class="java">    private void executePendingBroadcasts() {        while (true) {            BroadcastRecord[] brs = null;            synchronized (mReceivers) {//注意多线程下的同步                final int N = mPendingBroadcasts.size();                if (N &lt;= 0) {                    return;                }                brs = new BroadcastRecord[N];                mPendingBroadcasts.toArray(brs);//把待处理的广播转成数组形式                mPendingBroadcasts.clear();//然后就可以把mPendingBroadcasts清空            }            //for循环变量每个接受者，然后调用对应的onReceive            for (int i=0; i&lt;brs.length; i++) {                BroadcastRecord br = brs[i];                for (int j=0; j&lt;br.receivers.size(); j++) {                    br.receivers.get(j).receiver.onReceive(mAppContext, br.intent);                }            }        }    }</code></pre><p>处理也很简单，查询相应的变量，找到有多少个接受者，然后调用接受者的onReceive，该调用在主线程中，因而不要做耗时操作。在LocalBroadcastManager中还提供了同步发送广播处理的方法：</p><pre><code class="java">    //使用该方法会立即去让接受者处理广播。    public void sendBroadcastSync(Intent intent) {        if (sendBroadcast(intent)) {            executePendingBroadcasts();        }    }</code></pre><h4 id="2-4-广播的注销"><a href="#2-4-广播的注销" class="headerlink" title="2.4 广播的注销"></a>2.4 广播的注销</h4><pre><code class="java"> public void unregisterReceiver(BroadcastReceiver receiver) {        synchronized (mReceivers) {            ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver);            if (filters == null) {                return;            }            for (int i=0; i&lt;filters.size(); i++) {                IntentFilter filter = filters.get(i);                for (int j=0; j&lt;filter.countActions(); j++) {                    String action = filter.getAction(j);                    ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action);                    if (receivers != null) {                        for (int k=0; k&lt;receivers.size(); k++) {                            if (receivers.get(k).receiver == receiver) {                                receivers.remove(k);                                k--;                            }                        }                        if (receivers.size() &lt;= 0) {                            mActions.remove(action);                        }                    }                }            }        }    }</code></pre><p>注销广播也很简单，找到注册时候添加到List中的变量，然后remove掉。注意要讲mReceivers,mActions里面保存的都remove了。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>和普通广播比，应用内广播安全，速度快。缺点是只能在应用的一个进程中使用，不能跨进程使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h3&gt;&lt;p&gt;通常我们在使用Android广播的时候都会直接将广播注册到系统的AMS当中，由于AMS任务繁忙，一般可能不会立即能处理到
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="应用内部广播,LocalBroadcastManager" scheme="http://yoursite.com/tags/%E5%BA%94%E7%94%A8%E5%86%85%E9%83%A8%E5%B9%BF%E6%92%AD-LocalBroadcastManager/"/>
    
  </entry>
  
  <entry>
    <title>SharedPreferences源码详解</title>
    <link href="http://yoursite.com/2018/01/17/SharedPreferences%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/17/SharedPreferences源码详解/</id>
    <published>2018-01-17T03:59:33.000Z</published>
    <updated>2018-01-17T15:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>写这篇博客目的在于巩固自己对SharedPreferences的理解。SharePreferences是Android系统提供的轻量级数据存储方案，主要基于键值对方式保存数据，真实的数据是保存在/data/data/packageName/shared_pref/目录下面的。可以保存多种数据到该文件中，以下是一个简单的Sharepreference文件。</p><pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; standalone=&#39;yes&#39; ?&gt;&lt;map&gt;    &lt;boolean name=&quot;btest&quot; value=&quot;true&quot; /&gt;    &lt;string name=&quot;stest&quot;&gt;string&lt;/string&gt;    &lt;int name=&quot;itest&quot; value=&quot;999&quot; /&gt;    &lt;long name=&quot;ltest&quot; value=&quot;1516358782&quot; /&gt;    &lt;int name=&quot;itest_1&quot; value=&quot;2&quot; /&gt;&lt;/map&gt;</code></pre><p>从文件中可以看出就是采用简单xml方式进行保存的。</p><h4 id="1-1使用实例"><a href="#1-1使用实例" class="headerlink" title="1.1使用实例"></a>1.1使用实例</h4><pre><code>SharedPreferences preferences = context.getSharedPreferences(&quot;share&quot;, Context.MODE_PRIVATE);SharedPreferences.Editor editor = preferences.edit();editor.putBoolean(&quot;btest&quot;, true);editor.putString(&quot;stest&quot;, &quot;string test&quot;);//editor.apply();//异步保存editor.commit();//同步保存</code></pre><h4 id="1-2基本结构"><a href="#1-2基本结构" class="headerlink" title="1.2基本结构"></a>1.2基本结构</h4><p>这里借用Gityuan博客中的类继承图<br><img src="https://s1.ax1x.com/2018/01/17/pDZT58.jpg" alt="Sharepreference架构图"><br>在Sharepreference中，Sharepreference和Editor只是两个接口，在这两个接口中定义了一个普通的键值对存储的数据一些常用的操作。然后具体你想把这键值对存哪，你可以自己定义相应的文件或数据库，甚至你可以写个保存到网络中去。在Android系统中给出的是采用xml方式存在xml的文件中，具体实现类是SharepreferenceImpl和SharepreferenceImpl.EditorImpl。同时在ContextImpl中有Sharepreference的对应内存中的数据。</p><h3 id="2-Sharepreference源码分析"><a href="#2-Sharepreference源码分析" class="headerlink" title="2.Sharepreference源码分析"></a>2.Sharepreference源码分析</h3><h4 id="2-1获取Sharepreference"><a href="#2-1获取Sharepreference" class="headerlink" title="2.1获取Sharepreference"></a>2.1获取Sharepreference</h4><p>Activity.java</p><pre><code>    public SharedPreferences getPreferences(int mode) {        return getSharedPreferences(getLocalClassName(), mode);    }        @Override    public SharedPreferences getSharedPreferences(String name, int mode) {        return mBase.getSharedPreferences(name, mode);    }</code></pre><p>Context采用的是装饰模式，其中正在干活的是ContextImpl，mBase即为ContextImpl，具体代码如下：<br>ContextImpl.java</p><pre><code class="java">//ContextImpl类中的静态Map声明，全局的一个sSharedPrefsprivate static ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt; sSharedPrefs;    @Override    public SharedPreferences getSharedPreferences(String name, int mode) {        SharedPreferencesImpl sp;         synchronized (ContextImpl.class) {            if (sSharedPrefs == null) { //静态变量，全局唯一                sSharedPrefs = new ArrayMap&lt;String, ArrayMap&lt;String, SharedPreferencesImpl&gt;&gt;();            }            final String packageName = getPackageName();//通过包名找到对应的prefs集合            ArrayMap&lt;String, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefs.get(packageName);            if (packagePrefs == null) {                packagePrefs = new ArrayMap&lt;String, SharedPreferencesImpl&gt;();                sSharedPrefs.put(packageName, packagePrefs);            }            // At least one application in the world actually passes in a null            // name.  This happened to work because when we generated the file name            // we would stringify it to &quot;null.xml&quot;.  Nice.            if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;                    Build.VERSION_CODES.KITKAT) {                if (name == null) {                    name = &quot;null&quot;;                }            }            sp = packagePrefs.get(name);//这里获取sp            if (sp == null) {//如果为空，则构建一个sp，并将它放入packagePrefs里面                File prefsFile = getSharedPrefsFile(name);//正在获取文件的地方                sp = new SharedPreferencesImpl(prefsFile, mode);                packagePrefs.put(name, sp);                return sp;            }        }        //下面是为了跨进程使用Sharepreference的，跨进程使用也就是重新装载一次sharepreference        if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||            getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) {            // If somebody else (some other process) changed the prefs            // file behind our back, we reload it.  This has been the            // historical (if undocumented) behavior.            sp.startReloadIfChangedUnexpectedly();        }        return sp;    }</code></pre><p>正在保存的文件获取是getSharedPrefsFile(name)，代码如下：</p><pre><code class="java">    @Override    public File getSharedPrefsFile(String name) { //文件以.xml结尾        return makeFilename(getPreferencesDir(), name + &quot;.xml&quot;);    }    private File makeFilename(File base, String name) {        if (name.indexOf(File.separatorChar) &lt; 0) { //name中不能存在文件路径分隔符            return new File(base, name);        }        throw new IllegalArgumentException(                &quot;File &quot; + name + &quot; contains a path separator&quot;);    }    private File getPreferencesDir() {//sharepreference文件的目录/data/data/{包名}/shared_prefs        synchronized (mSync) {            if (mPreferencesDir == null) {                mPreferencesDir = new File(getDataDirFile(), &quot;shared_prefs&quot;);            }            return mPreferencesDir;        }    }</code></pre><p>在ContextImpl中存在一个静态的sSharedPrefs，通过它来获取对应应用的prefs，在通过prefs找到对应名称的Sharepreference的引用。在系统中共用一个sSharedPrefs，每个应该在获取sp的时候都会将创建后sp加入到sSharedPrefs中以便后续进行访问。</p><h4 id="2-2-SharepreferenceImpl"><a href="#2-2-SharepreferenceImpl" class="headerlink" title="2.2 SharepreferenceImpl"></a>2.2 SharepreferenceImpl</h4><pre><code>从上面我们可以看到我们要获取的是Sharepreference，但是返回的是SharepreferenceImpl，这就赤裸裸的告诉我们SharepreferenceImpl是Sharepreference接口的实现类，具体代码如下：</code></pre><pre><code class="java">final class SharedPreferencesImpl implements SharedPreferences {    private static final String TAG = &quot;SharedPreferencesImpl&quot;;    private static final boolean DEBUG = false;    // Lock ordering rules:    //  - acquire SharedPreferencesImpl.this before EditorImpl.this    //  - acquire mWritingToDiskLock before EditorImpl.this    private final File mFile;    private final File mBackupFile;    private final int mMode;    private Map&lt;String, Object&gt; mMap;     // guarded by &#39;this&#39;    private int mDiskWritesInFlight = 0;  // guarded by &#39;this&#39;    private boolean mLoaded = false;      // guarded by &#39;this&#39;    private long mStatTimestamp;          // guarded by &#39;this&#39;    private long mStatSize;               // guarded by &#39;this&#39;    private final Object mWritingToDiskLock = new Object();    private static final Object mContent = new Object();    private final WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt; mListeners =            new WeakHashMap&lt;OnSharedPreferenceChangeListener, Object&gt;();    SharedPreferencesImpl(File file, int mode) {        mFile = file;        mBackupFile = makeBackupFile(file); //创建临时备份文件，这样写入失败的时候就用这个备份的还原        mMode = mode;        mLoaded = false;        mMap = null;        startLoadFromDisk();//异步加载文件内容到内存    }    private void startLoadFromDisk() {        synchronized (this) {            mLoaded = false;        }        new Thread(&quot;SharedPreferencesImpl-load&quot;) {            public void run() {                //由于是多线程加载的时候注意同步处理                synchronized (SharedPreferencesImpl.this) {                    loadFromDiskLocked();                }            }        }.start();    }...  private static File makeBackupFile(File prefsFile) {        return new File(prefsFile.getPath() + &quot;.bak&quot;);    }...}</code></pre><p>在获取sp的时候，如果通过sSharedPrefs获取为空就会先创建一个sp，在new SharepreferenceImpl的时候，在构造函数中最后就会异步加载文件到内存，异步开启一个线程后就调用loadFromDiskLocked()函数进行加载：<br>SharepreferenceImpl.java</p><pre><code class="java">    private void loadFromDiskLocked() {        if (mLoaded) {//加载过了就返回            return;        }        if (mBackupFile.exists()) {//如果存在备份就直接使用备份            mFile.delete();            mBackupFile.renameTo(mFile);        }        // Debugging        if (mFile.exists() &amp;&amp; !mFile.canRead()) {            Log.w(TAG, &quot;Attempt to read preferences file &quot; + mFile + &quot; without permission&quot;);        }        Map map = null;        StructStat stat = null;        try {            stat = Os.stat(mFile.getPath());            if (mFile.canRead()) {                BufferedInputStream str = null;                try {                    str = new BufferedInputStream(                            new FileInputStream(mFile), 16*1024);                    map = XmlUtils.readMapXml(str);//利用XmlUtils进行解析                } catch (XmlPullParserException e) {                    Log.w(TAG, &quot;getSharedPreferences&quot;, e);                } catch (FileNotFoundException e) {                    Log.w(TAG, &quot;getSharedPreferences&quot;, e);                } catch (IOException e) {                    Log.w(TAG, &quot;getSharedPreferences&quot;, e);                } finally {                    IoUtils.closeQuietly(str);                }            }        } catch (ErrnoException e) {        }        mLoaded = true;        if (map != null) {            mMap = map;            mStatTimestamp = stat.st_mtime;            mStatSize = stat.st_size;        } else {            mMap = new HashMap&lt;String, Object&gt;();        }        notifyAll();//没加载完前，所有操作（get等）都会等待加载完成，加载完成后通知其他操作可以进行操作了。    }</code></pre><p>一旦加载完成后，就会notifyAll()，我们先看下get的操作</p><pre><code class="java">    public Map&lt;String, ?&gt; getAll() {        synchronized (this) {            awaitLoadedLocked();            //noinspection unchecked            return new HashMap&lt;String, Object&gt;(mMap);        }    }    @Nullable    public String getString(String key, @Nullable String defValue) {        synchronized (this) {            awaitLoadedLocked();//没有加载就阻塞等待            String v = (String)mMap.get(key);//加载完成了就直接去内存中的值，记住是从内存中取。不会再次读取文件总内容。            return v != null ? v : defValue;        }    }...    private void awaitLoadedLocked() {//这里判断是否已经加载文件到内存了，没有加载就会阻塞等待        if (!mLoaded) {            // Raise an explicit StrictMode onReadFromDisk for this            // thread, since the real read will be in a different            // thread and otherwise ignored by StrictMode.            BlockGuard.getThreadPolicy().onReadFromDisk();        }        while (!mLoaded) {            try {                wait();            } catch (InterruptedException unused) {            }        }    }</code></pre><p>在get数据时，首先判断文件是否加载到内存，然后就直接读取内存中的值，这里可以看出一旦装载了，那么读取的速度就很快。</p><h4 id="2-3-EditorImpl"><a href="#2-3-EditorImpl" class="headerlink" title="2.3 EditorImpl"></a>2.3 EditorImpl</h4><p>上面SharepreferenceImpl是实现了get操作，真正的写入是Editor接口来完成的，而EditorImpl是具体的实现类。其代码如下：</p><pre><code class="java">    public final class EditorImpl implements Editor {        private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();        private boolean mClear = false;        //从这里可以看出每次存的时候都是先存入内存中的mModified变量中        public Editor putString(String key, @Nullable String value) {            synchronized (this) {                mModified.put(key, value);                return this;            }        }        public Editor putStringSet(String key, @Nullable Set&lt;String&gt; values) {            synchronized (this) {                mModified.put(key,                        (values == null) ? null : new HashSet&lt;String&gt;(values));                return this;            }        }        public Editor putInt(String key, int value) {            synchronized (this) {                mModified.put(key, value);                return this;            }        }...        public Editor remove(String key) {            synchronized (this) {                mModified.put(key, this);                return this;            }        }        public Editor clear() {            synchronized (this) {                mClear = true;                return this;            }        }        public void apply() {            final MemoryCommitResult mcr = commitToMemory();            final Runnable awaitCommit = new Runnable() {                    public void run() {                        try {                            mcr.writtenToDiskLatch.await();                        } catch (InterruptedException ignored) {                        }                    }                };            QueuedWork.add(awaitCommit);            Runnable postWriteRunnable = new Runnable() {                    public void run() {                        awaitCommit.run();                        QueuedWork.remove(awaitCommit);                    }                };            SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);            // Okay to notify the listeners before it&#39;s hit disk            // because the listeners should always get the same            // SharedPreferences instance back, which has the            // changes reflected in memory.            notifyListeners(mcr);        }    }</code></pre><p>首先查看下存入的代码：</p><pre><code>        //从这里可以看出每次存的时候都是先存入内存中的mModified变量中        public Editor putString(String key, @Nullable String value) {            synchronized (this) {                mModified.put(key, value);                return this;            }        }</code></pre><p>存入的时候首先获取同步锁，然后将存入的数据放入EditorImpl中的一个mModified变量中，也就是存入的时候并没有放入Sharepreference中，只有在使用了apply或者commit后才真正存入。<br>下面来看看commit操作：</p><pre><code class="java">        public boolean commit() {            MemoryCommitResult mcr = commitToMemory();//步骤1            SharedPreferencesImpl.this.enqueueDiskWrite(                mcr, null /* sync write on this thread okay */);//步骤2            try {                mcr.writtenToDiskLatch.await();//等待写入完成            } catch (InterruptedException e) {                return false;            }            notifyListeners(mcr);//步骤3            return mcr.writeToDiskResult;步骤4        }</code></pre><p>步骤1：</p><pre><code>        // Returns true if any changes were made 真正存入文件中        private MemoryCommitResult commitToMemory() {            MemoryCommitResult mcr = new MemoryCommitResult();            synchronized (SharedPreferencesImpl.this) {                // We optimistically don&#39;t make a deep copy until                // a memory commit comes in when we&#39;re already                // writing to disk.                if (mDiskWritesInFlight &gt; 0) {                    // We can&#39;t modify our mMap as a currently                    // in-flight write owns it.  Clone it before                    // modifying it.                    // noinspection unchecked                    mMap = new HashMap&lt;String, Object&gt;(mMap);                }                mcr.mapToWriteToDisk = mMap;                mDiskWritesInFlight++;                boolean hasListeners = mListeners.size() &gt; 0;                if (hasListeners) {                    mcr.keysModified = new ArrayList&lt;String&gt;();                    mcr.listeners =                            new HashSet&lt;OnSharedPreferenceChangeListener&gt;(mListeners.keySet());                }                synchronized (this) {                    if (mClear) {                        if (!mMap.isEmpty()) {                            mcr.changesMade = true;                            mMap.clear();                        }                        mClear = false;                    }                    for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) {                        String k = e.getKey();                        Object v = e.getValue();                        // &quot;this&quot; is the magic value for a removal mutation. In addition,                        // setting a value to &quot;null&quot; for a given key is specified to be                        // equivalent to calling remove on that key.                        //删除一些需要删除的数据                        if (v == this || v == null) {                            if (!mMap.containsKey(k)) {                                continue;                            }                            mMap.remove(k);                        } else {                            if (mMap.containsKey(k)) {                                Object existingValue = mMap.get(k);                                if (existingValue != null &amp;&amp; existingValue.equals(v)) {                                    continue;                                }                            }                            //将变化的数据放入SharepreferenceImpl的mMap中                            mMap.put(k, v);                        }                        mcr.changesMade = true;                        if (hasListeners) {                            mcr.keysModified.add(k);                        }                    }                    //变化的数据都加入了mMap后就可以清除mModified内容了。                    mModified.clear();                }            }            //返回封装mMap的MemoryCommitResult数据            return mcr;        }</code></pre><p>步骤2：</p><pre><code>private void enqueueDiskWrite(final MemoryCommitResult mcr,                                  final Runnable postWriteRunnable) {        final Runnable writeToDiskRunnable = new Runnable() {                public void run() {                    synchronized (mWritingToDiskLock) {                        writeToFile(mcr);                    }                    synchronized (SharedPreferencesImpl.this) {                        mDiskWritesInFlight--;                    }                    if (postWriteRunnable != null) {                        postWriteRunnable.run();                    }                }            };      final boolean isFromSyncCommit = (postWriteRunnable == null);//如果postWriteRunnable为null就是同步        // Typical #commit() path with fewer allocations, doing a write on        // the current thread.        if (isFromSyncCommit) {//同步就直接运行写入数据writeToDiskRunnable            boolean wasEmpty = false;            synchronized (SharedPreferencesImpl.this) {                wasEmpty = mDiskWritesInFlight == 1;            }            if (wasEmpty) {                writeToDiskRunnable.run();                return;            }        }        QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);    }// 写入数据    private void writeToFile(MemoryCommitResult mcr) {        // Rename the current file so it may be used as a backup during the next read        if (mFile.exists()) {            if (!mcr.changesMade) {                // If the file already exists, but no changes were                // made to the underlying map, it&#39;s wasteful to                // re-write the file.  Return as if we wrote it                // out.                mcr.setDiskWriteResult(true);                return;            }            if (!mBackupFile.exists()) {                if (!mFile.renameTo(mBackupFile)) {                    Log.e(TAG, &quot;Couldn&#39;t rename file &quot; + mFile                          + &quot; to backup file &quot; + mBackupFile);                    mcr.setDiskWriteResult(false);                    return;                }            } else {                mFile.delete();            }        }        // Attempt to write the file, delete the backup and return true as atomically as        // possible.  If any exception occurs, delete the new file; next time we will restore        // from the backup.        try {            FileOutputStream str = createFileOutputStream(mFile);            if (str == null) {                mcr.setDiskWriteResult(false);                return;            }            XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);            FileUtils.sync(str);            str.close();            ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);            try {                final StructStat stat = Os.stat(mFile.getPath());                synchronized (this) {                    mStatTimestamp = stat.st_mtime;                    mStatSize = stat.st_size;                }            } catch (ErrnoException e) {                // Do nothing            }            // Writing was successful, delete the backup file if there is one.            mBackupFile.delete();            mcr.setDiskWriteResult(true);            return;        } catch (XmlPullParserException e) {            Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);        } catch (IOException e) {            Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);        }        // Clean up an unsuccessfully written file        if (mFile.exists()) {            if (!mFile.delete()) {                Log.e(TAG, &quot;Couldn&#39;t clean up partially-written file &quot; + mFile);            }        }        mcr.setDiskWriteResult(false);    }</code></pre><p>步骤3通知写入数据发生变化</p><pre><code>        private void notifyListeners(final MemoryCommitResult mcr) {            if (mcr.listeners == null || mcr.keysModified == null ||                mcr.keysModified.size() == 0) {                return;            }            if (Looper.myLooper() == Looper.getMainLooper()) {                for (int i = mcr.keysModified.size() - 1; i &gt;= 0; i--) {                    final String key = mcr.keysModified.get(i);                    for (OnSharedPreferenceChangeListener listener : mcr.listeners) {                        if (listener != null) {                            listener.onSharedPreferenceChanged(SharedPreferencesImpl.this, key);                        }                    }                }            } else {                // Run this function on the main thread.                ActivityThread.sMainThreadHandler.post(new Runnable() {                        public void run() {                            notifyListeners(mcr);                        }                    });            }        }</code></pre><p>步骤4返回写入的结果。</p><h5 id="2-3-2-Editor-apply"><a href="#2-3-2-Editor-apply" class="headerlink" title="2.3.2 Editor.apply()"></a>2.3.2 Editor.apply()</h5><p>代码如下：</p><pre><code>public void apply() {    //写数据到内存，返回数据结构    final MemoryCommitResult mcr = commitToMemory();    final Runnable awaitCommit = new Runnable() {        public void run() {            try {                //等待写文件结束                mcr.writtenToDiskLatch.await();            } catch (InterruptedException ignored) {            }        }    };    QueuedWork.add(awaitCommit);    //一个收尾的Runnable    Runnable postWriteRunnable = new Runnable() {        public void run() {            awaitCommit.run();            QueuedWork.remove(awaitCommit);        }    };    //这里postWriteRunnable不为null，所以会在一个新的线程池调运postWriteRunnable的run方法    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);    // Okay to notify the listeners before it&#39;s hit disk    // because the listeners should always get the same    // SharedPreferences instance back, which has the    // changes reflected in memory.    //通知变化    notifyListeners(mcr);}</code></pre><p>apply会将写入放入到一个线程池中操作，这不会阻塞调用的线程。其他的都和commit类似。<br>QueuedWork.java</p><pre><code>public class QueuedWork {    private static final ConcurrentLinkedQueue&lt;Runnable&gt; sPendingWorkFinishers =       new ConcurrentLinkedQueue&lt;Runnable&gt;();    public static void add(Runnable finisher) {        sPendingWorkFinishers.add(finisher);    }    public static void remove(Runnable finisher) {        sPendingWorkFinishers.remove(finisher);    }    public static void waitToFinish() {        Runnable toFinish;        while ((toFinish = sPendingWorkFinishers.poll()) != null) {            toFinish.run();        }    }    public static boolean hasPendingWork() {        return !sPendingWorkFinishers.isEmpty();    }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>apply 与commit的对比</p><p>apply没有返回值, commit有返回值能知道修改是否提交成功<br>apply是将修改提交到内存，再异步提交到磁盘文件; commit是同步的提交到磁盘文件;<br>多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。<br>获取SP与Editor:</p><p>getSharedPreferences()是从ContextImpl.sSharedPrefsCache唯一的SPI对象;<br>edit()每次都是创建新的EditorImpl对象.<br>优化建议:</p><p>强烈建议不要在sp里面存储特别大的key/value, 有助于减少卡顿/anr<br>请不要高频地使用apply, 尽可能地批量提交;commit直接在主线程操作, 更要注意了<br>不要使用MODE_MULTI_PROCESS;<br>高频写操作的key与高频读操作的key可以适当地拆分文件, 由于减少同步锁竞争;<br>不要一上来就执行getSharedPreferences().edit(), 应该分成两大步骤来做, 中间可以执行其他代码.<br>不要连续多次edit(), 应该获取一次获取edit(),然后多次执行putxxx(), 减少内存波动; 经常看到大家喜欢封装方法, 结果就导致这种情况的出现.<br>每次commit时会把全部的数据更新的文件, 所以整个文件是不应该过大的, 影响整体性能;</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://gityuan.com/2017/06/18/SharedPreferences/" target="_blank" rel="noopener">Gityuan博客</a><br><a href="http://blog.csdn.net/yanbober/article/details/47866369" target="_blank" rel="noopener">工匠若水</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h3&gt;&lt;p&gt;写这篇博客目的在于巩固自己对SharedPreferences的理解。SharePreferences是Android系统提
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="SharedPreferences Editor" scheme="http://yoursite.com/tags/SharedPreferences-Editor/"/>
    
  </entry>
  
  <entry>
    <title>adb常用命令</title>
    <link href="http://yoursite.com/2018/01/17/adb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/01/17/adb常用命令/</id>
    <published>2018-01-17T02:15:31.000Z</published>
    <updated>2018-01-17T15:06:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="adb简介"><a href="#adb简介" class="headerlink" title="adb简介"></a>adb简介</h3><p>adb全称Android Debug Bridge，意为安卓调试桥接，即常用于Android手机调试的工具。adb提供了一系列命令可以操作手机，比如安装卸载软件，运行shell命令等等。adb工作方式是采用监听Socket TCP5554等端口的方式让IDE和Qemu通讯。</p><h3 id="常用的adb命令"><a href="#常用的adb命令" class="headerlink" title="常用的adb命令"></a>常用的adb命令</h3><ol><li>取得当前连接电脑的设备的状态<pre><code>adb devices</code></pre></li><li>安装卸载软件<pre><code>adb install  &lt;-r&gt; 文件.apk  //-r表示替换掉原来的apkadb uninstall &lt;-k&gt; {package} //packageName表示应用包名 -k表示保留配置和缓存</code></pre></li><li>获取设备的序列号<pre><code>adb get-serialno //获取设备序列号</code></pre></li><li>访问手机SQLit数据库（手机内部需有sqilte3命令支持）<pre><code>adb shellsqlite3 {数据库文件名}</code></pre></li><li>从电脑上发送文件到手机端<pre><code>adb push {文件路径} {手机端路径}  //文件表示要发送文件的全路径（当前路径下只需写上文件名 {手机端路径}表示拷贝到手机上的路径，/sdcard/表示sd卡根路径</code></pre></li><li>从手机端拉取文件到电脑端<pre><code>adb pull {手机端路径} {保存到电脑端路径}</code></pre></li><li>查看bug报告<pre><code>adb bugreport  //Android7.0及以后支持该功能</code></pre></li><li>获取手机中的第三方包名<pre><code>adb shell pm list packages -3</code></pre></li><li>查看当前正在交互的程序<pre><code>adb shell dumpsys activity | grep &quot;Running activities&quot; -A 7</code></pre></li><li>获取包名所在路径<pre><code>adb shell pm path {package}</code></pre></li><li>Monkey命令<br>全模块：<pre><code>adb shell &quot;monkey --ignore-crashes --ignore-timeouts --throttle 500 --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes 10000 &gt; sdcard/monkey.txt&quot;</code></pre>单模块<pre><code>adb shell monkey -p com.android.contacts --ignore-crashes --ignore-timeouts --ignore-security-exceptions --monitor-native-crashes --ignore-native-crashes --throttle 500 -v 10000 &gt; sdcard/monkey.txt&quot;</code></pre></li><li>强行停止monkey<pre><code>adb shellps | grep monkeykill monkey对应的pid</code></pre></li><li>列出所有可以dump的选项<pre><code>adb shell dumpsys -l</code></pre></li><li>查看内存信息<pre><code>adb shell dumpsys meminfo</code></pre></li><li>列出dumpsys能提供的所有服务列表<pre><code>adb shell dumpsys service list //得到该列表后，就可以在dumpsys后面加上service的名称来查看指定service的信息了</code></pre></li><li>查看ActvityManagerService 所有信息<pre><code>adb shell dumpsys activity</code></pre></li><li>查看Activity组件信息<pre><code>adb shell dumpsys activity activities</code></pre></li><li>查看Service组件信息<pre><code>adb shell dumpsys activity services</code></pre></li><li>产看ContentProvider组件信息<pre><code>adb shell dumpsys activity providers</code></pre></li><li>查看BraodcastReceiver信息<pre><code>adb shell dumpsys activity broadcasts</code></pre></li><li>查看Intent信息<pre><code>adb shell dumpsys activity intents</code></pre></li><li>查看进程信息<pre><code>adb shell dumpsys activity processes</code></pre></li><li>关闭或开启adb服务<pre><code>adb kill-serveradb start-server</code></pre></li><li>显示或导出log信息<pre><code>adb logcat &lt;-s&gt; //在命令行显示log信息 -s表示指定标签tagadb logcat &gt; log.txt //将log信息保存到当前目录的log.txt文件中</code></pre></li><li>启动Activities<pre><code>adb shell am start -n {包名}/{包名＋类名}（-n 类名,-a action,-d date,-m MIME-TYPE,-c category,-e 扩展数据,等）</code></pre></li><li>设置系统属性信息<pre><code>adb shell setprop {key} {value}</code></pre></li><li>常用的adb shell命令<pre><code>ps //列出所有进程ls //列出当前目录下文件df //检查文件系统的磁盘空间占用情况cat //查看某个文件kill {pid}//杀死某个进程cd //进入其他目录rm //删除rmdir //删除非空文件夹（有文件的文件夹可能不成功）</code></pre></li><li>显示WiFi信息<pre><code>adb shell dumpsys wifi</code></pre></li><li>模拟用户点击<pre><code>adb shell input tap {x} {x} //例子：adb shell input tap 50 250</code></pre></li><li>模拟用户滑动<pre><code>adb shell input swipe {start.x} {start.y} {end.x} {end.y} {time} //例子：adb shell input swipe 50 250 250 250 500 //划屏操作，前四个数为坐标点，后面是滑动的时间（单位毫秒）</code></pre></li><li>模拟输入字符串<pre><code>adb shell input text &#39;abc&#39;</code></pre></li><li>模拟点击手机自带的功能键：Home，Menu，Back<pre><code>adb shell input keyevent keyCodekeyCode对应表：KEYCODE_UNKNOWN=0;KEYCODE_SOFT_LEFT=1;   KEYCODE_SOFT_RIGHT=2;   KEYCODE_HOME=3;   KEYCODE_BACK=4;   KEYCODE_CALL=5;   KEYCODE_ENDCALL=6;   KEYCODE_0=7;   KEYCODE_1=8;   KEYCODE_2=9;   KEYCODE_4=11;   KEYCODE_5=12;   KEYCODE_6=13;   KEYCODE_7=14;   KEYCODE_8=15;   KEYCODE_9=16;   KEYCODE_STAR=17;   KEYCODE_POUND=18;   KEYCODE_DPAD_UP=19;   KEYCODE_DPAD_DOWN=20;   KEYCODE_DPAD_LEFT=21;   KEYCODE_DPAD_RIGHT=22;   KEYCODE_DPAD_CENTER=23;   KEYCODE_VOLUME_UP=24;   KEYCODE_VOLUME_DOWN=25;   KEYCODE_POWER=26;   KEYCODE_CAMERA=27;   KEYCODE_CLEAR=28;   KEYCODE_A=29;   KEYCODE_B=30;   KEYCODE_C=31;   KEYCODE_D=32;   KEYCODE_E=33;   KEYCODE_F=34;   KEYCODE_G=35;   KEYCODE_H=36;   KEYCODE_I=37;   KEYCODE_J=38;   KEYCODE_K=39;   KEYCODE_L=40;   KEYCODE_M=41;   KEYCODE_N=42;   KEYCODE_O=43;   KEYCODE_P=44;   KEYCODE_Q=45;   KEYCODE_R=46;   KEYCODE_S=47;   KEYCODE_T=48;   KEYCODE_U=49;   KEYCODE_V=50;   KEYCODE_W=51;   KEYCODE_X=52;   KEYCODE_Y=53;   KEYCODE_Z=54;   KEYCODE_COMMA=55;   KEYCODE_PERIOD=56;   KEYCODE_ALT_LEFT=57;   KEYCODE_ALT_RIGHT=58;   KEYCODE_SHIFT_LEFT=59;   KEYCODE_SHIFT_RIGHT=60;   KEYCODE_TAB=61;   KEYCODE_SPACE=62;   KEYCODE_SYM=63;   KEYCODE_EXPLORER=64;   KEYCODE_ENVELOPE=65;   KEYCODE_ENTER=66;   KEYCODE_DEL=67;   KEYCODE_GRAVE=68;   KEYCODE_MINUS=69;   KEYCODE_EQUALS=70;   KEYCODE_LEFT_BRACKET=71;   KEYCODE_RIGHT_BRACKET=72;   KEYCODE_BACKSLASH=73;   KEYCODE_SEMICOLON=74;   KEYCODE_APOSTROPHE=75;   KEYCODE_SLASH=76;   KEYCODE_AT=77;   KEYCODE_NUM=78;   KEYCODE_HEADSETHOOK=79;   KEYCODE_FOCUS=80;//*Camera*focus   KEYCODE_PLUS=81;   KEYCODE_MENU=82;   KEYCODE_NOTIFICATION=83;   KEYCODE_SEARCH=84;   KEYCODE_MEDIA_PLAY_PAUSE=85;   KEYCODE_MEDIA_STOP=86;   KEYCODE_MEDIA_NEXT=87;   KEYCODE_MEDIA_PREVIOUS=88;   KEYCODE_MEDIA_REWIND=89;   KEYCODE_MEDIA_FAST_FORWARD=90;   KEYCODE_MUTE=91;</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;adb简介&quot;&gt;&lt;a href=&quot;#adb简介&quot; class=&quot;headerlink&quot; title=&quot;adb简介&quot;&gt;&lt;/a&gt;adb简介&lt;/h3&gt;&lt;p&gt;adb全称Android Debug Bridge，意为安卓调试桥接，即常用于Android手机调试的工具。adb提
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="adb命令" scheme="http://yoursite.com/tags/adb%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>onAttachedToWindow和onDetachedFromWindow调用时机源码解析</title>
    <link href="http://yoursite.com/2018/01/09/onAttachedToWindow%E5%92%8ConDetachedFromWindow%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/09/onAttachedToWindow和onDetachedFromWindow调用时机源码解析/</id>
    <published>2018-01-09T14:56:44.000Z</published>
    <updated>2018-01-09T15:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-示例"><a href="#1-示例" class="headerlink" title="1.示例"></a>1.示例</h3><p>先上测试代码：<br>MyView.java</p><pre><code class="java">public class MyView extends TextView {      public MyView(Context context) {          super(context);      }      public MyView(Context context, AttributeSet attrs) {          super(context, attrs);          Log.e(&quot;test&quot;,&quot;view constructor&quot;);      }      @Override      protected void onAttachedToWindow() {          super.onAttachedToWindow();          Log.e(&quot;test&quot;, &quot;onAttachedToWindow&quot;);      }      @Override      protected void onDetachedFromWindow() {          super.onDetachedFromWindow();          Log.e(&quot;test&quot;, &quot;onDetachedFromWindow&quot;);      }  }</code></pre><p>MainActivity.java</p><pre><code class="java">public class MainActivity extends AppCompatActivity {      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          Log.e(&quot;test&quot;, &quot;before setContextView&quot;);          setContentView(R.layout.activity_main);          Log.e(&quot;test&quot;, &quot;after setContextView&quot;);      }      @Override      protected void onResume() {          super.onResume();          Log.e(&quot;test&quot;, &quot;onResume&quot;);      }      @Override      protected void onDestroy() {          super.onDestroy();          Log.e(&quot;test&quot;, &quot;onDestroy&quot;);      }  }</code></pre><p> 运行后输出的Log如下：<br> <img src="http://img.blog.csdn.net/20170801103513570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="运行后Log"><br>点击返回键退出后，输出的Log如下：<br><img src="http://img.blog.csdn.net/20170801103610947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="点击返回后Log"></p><p>根据Log的onAttachedToWindow和onDetachedFromWindow的输出情况一目了然。</p><h3 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h3><p>下面通过源码分析下，他两的调用时机到底在哪。</p><p>首先看下onAttachedToWindow的调用时机，在Android源码中onResume调用前会先调用了ActivityThread中的handleResumeActivity，下面是相应的代码：</p><p>ActivityThread.java</p><pre><code class="java">final void handleResumeActivity(IBinder token,              boolean clearHide, boolean isForward, boolean reallyResume) {          // If we are getting ready to gc after going to the background, well          // we are back active so skip it.          unscheduleGcIdler();          mSomeActivitiesChanged = true;          // TODO Push resumeArgs into the activity for consideration          ActivityClientRecord r = performResumeActivity(token, clearHide);          if (r != null) {              final Activity a = r.activity;              if (localLOGV) Slog.v(                  TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +                  a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow                  + &quot;, finished: &quot; + a.mFinished);              final int forwardBit = isForward ?                      WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;              // If the window hasn&#39;t yet been added to the window manager,              // and this guy didn&#39;t finish itself or start another activity,              // then go ahead and add the window.              boolean willBeVisible = !a.mStartedActivity;              if (!willBeVisible) {                  try {                      willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(                              a.getActivityToken());                  } catch (RemoteException e) {                  }              }              if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {                  r.window = r.activity.getWindow();                  View decor = r.window.getDecorView();                  decor.setVisibility(View.INVISIBLE);                  ViewManager wm = a.getWindowManager();                  WindowManager.LayoutParams l = r.window.getAttributes();                  a.mDecor = decor;                  l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;                  l.softInputMode |= forwardBit;                  if (a.mVisibleFromClient) {                      a.mWindowAdded = true;                      wm.addView(decor, l);//这里调用了ViewManager中的addView方法。                  }              // If the window has already been added, but during resume              // we started another activity, then don&#39;t yet make the              // window visible.              } else if (!willBeVisible) {                  if (localLOGV) Slog.v(                      TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;);                  r.hideForNow = true;              }              // Get rid of anything left hanging around.              cleanUpPendingRemoveWindows(r);              // The window is now visible if it has been added, we are not              // simply finishing, and we are not starting another activity.              if (!r.activity.mFinished &amp;&amp; willBeVisible                      &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) {                  if (r.newConfig != null) {                      r.tmpConfig.setTo(r.newConfig);                      if (r.overrideConfig != null) {                          r.tmpConfig.updateFrom(r.overrideConfig);                      }                      if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot;                              + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig);                      performConfigurationChanged(r.activity, r.tmpConfig);                      freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig));                      r.newConfig = null;                  }                  if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot;                          + isForward);                  WindowManager.LayoutParams l = r.window.getAttributes();                  if ((l.softInputMode                          &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)                          != forwardBit) {                      l.softInputMode = (l.softInputMode                              &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))                              | forwardBit;                      if (r.activity.mVisibleFromClient) {                          ViewManager wm = a.getWindowManager();                          View decor = r.window.getDecorView();                          wm.updateViewLayout(decor, l);                      }                  }                  r.activity.mVisibleFromServer = true;                  mNumVisibleActivities++;                  if (r.activity.mVisibleFromClient) {                      r.activity.makeVisible();                  }              }              ....      }</code></pre><p>看代码中的wm.addView(devor,l);通过该方法将View添加到Window当中（在当前Window也就是Activity，不过Window也可以是Dialog或Toast），而wm是ViewManager类型的，查看对应代码是：</p><pre><code class="java">/** Interface to let you add and remove child views to an Activity. To get an instance   * of this class, call {@link android.content.Context#getSystemService(java.lang.String) Context.getSystemService()}.   */  public interface ViewManager  {      /**      * Assign the passed LayoutParams to the passed View and add the view to the window.      * &lt;p&gt;Throws {@link android.view.WindowManager.BadTokenException} for certain programming      * errors, such as adding a second view to a window without removing the first view.      * &lt;p&gt;Throws {@link android.view.WindowManager.InvalidDisplayException} if the window is on a      * secondary {@link Display} and the specified display can&#39;t be found      * (see {@link android.app.Presentation}).      * @param view The view to be added to this window.      * @param params The LayoutParams to assign to view.      */      public void addView(View view, ViewGroup.LayoutParams params);      public void updateViewLayout(View view, ViewGroup.LayoutParams params);      public void removeView(View view);  }</code></pre><p> 该类是一个接口，在他下面还有一个WindowManager继承于ViewManager，而真正的实现代码在WindowManagerImpl类中，代码如下：<br>WindowManagerImpl.java</p><pre><code class="java">/* * @see WindowManager * @see WindowManagerGlobal * @hide */  ublic final class WindowManagerImpl implements WindowManager {     private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();     private final Display mDisplay;     private final Window mParentWindow;     private IBinder mDefaultToken;     public WindowManagerImpl(Display display) {         this(display, null);     }     private WindowManagerImpl(Display display, Window parentWindow) {         mDisplay = display;         mParentWindow = parentWindow;     }     public WindowManagerImpl createLocalWindowManager(Window parentWindow) {         return new WindowManagerImpl(mDisplay, parentWindow);     }     public WindowManagerImpl createPresentationWindowManager(Display display) {         return new WindowManagerImpl(display, mParentWindow);     }     /**     * Sets the window token to assign when none is specified by the client or     * available from the parent window.     *     * @param token The default token to assign.     */     public void setDefaultToken(IBinder token) {         mDefaultToken = token;     }     @Override     public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {         applyDefaultToken(params);         mGlobal.addView(view, params, mDisplay, mParentWindow);     }     @Override     public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {         applyDefaultToken(params);         mGlobal.updateViewLayout(view, params);     }     private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) {         // Only use the default token if we don&#39;t have a parent window.         if (mDefaultToken != null &amp;&amp; mParentWindow == null) {             if (!(params instanceof WindowManager.LayoutParams)) {                 throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);             }             // Only use the default token if we don&#39;t already have a token.             final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;             if (wparams.token == null) {                 wparams.token = mDefaultToken;             }         }     }     @Override     public void removeView(View view) {         mGlobal.removeView(view, false);     }     @Override     public void removeViewImmediate(View view) {         mGlobal.removeView(view, true);     }     @Override     public Display getDefaultDisplay() {         return mDisplay;     }</code></pre><p>从中可以看到addView又调用了 WindowManagerGlobal.java类中的addView，下面看看WindowManagerGlobal.java类的源码：<br>WindowManagerGlobal.java</p><pre><code class="java">public void addView(View view, ViewGroup.LayoutParams params,          Display display, Window parentWindow) {      if (view == null) {          throw new IllegalArgumentException(&quot;view must not be null&quot;);      }      if (display == null) {          throw new IllegalArgumentException(&quot;display must not be null&quot;);      }      if (!(params instanceof WindowManager.LayoutParams)) {          throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;);      }      final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;      if (parentWindow != null) {          parentWindow.adjustLayoutParamsForSubWindow(wparams);      } else {          // If there&#39;s no parent, then hardware acceleration for this view is          // set from the application&#39;s hardware acceleration setting.          final Context context = view.getContext();          if (context != null                  &amp;&amp; (context.getApplicationInfo().flags                          &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) {              wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;          }      }      ViewRootImpl root;      View panelParentView = null;      synchronized (mLock) {          // Start watching for system property changes.          if (mSystemPropertyUpdater == null) {              mSystemPropertyUpdater = new Runnable() {                  @Override public void run() {                      synchronized (mLock) {                          for (int i = mRoots.size() - 1; i &gt;= 0; --i) {                              mRoots.get(i).loadSystemProperties();                          }                      }                  }              };              SystemProperties.addChangeCallback(mSystemPropertyUpdater);          }          int index = findViewLocked(view, false);          if (index &gt;= 0) {              if (mDyingViews.contains(view)) {                  // Don&#39;t wait for MSG_DIE to make it&#39;s way through root&#39;s queue.                  mRoots.get(index).doDie();              } else {                  throw new IllegalStateException(&quot;View &quot; + view                          + &quot; has already been added to the window manager.&quot;);              }              // The previous removeView() had not completed executing. Now it has.          }          // If this is a panel window, then find the window it is being          // attached to for future reference.          if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;                  wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {              final int count = mViews.size();              for (int i = 0; i &lt; count; i++) {                  if (mRoots.get(i).mWindow.asBinder() == wparams.token) {                      panelParentView = mViews.get(i);                  }              }          }          root = new ViewRootImpl(view.getContext(), display);          view.setLayoutParams(wparams);          mViews.add(view);          mRoots.add(root);          mParams.add(wparams);      }      // do this last because it fires off messages to start doing things      try {          root.setView(view, wparams, panelParentView);//这里调用ViewRootImpl类中的setView方法，在该方法中触发了&lt;span style=&quot;color: rgb(101, 123, 131); font-family: Menlo, Monaco, Consolas, &#39;Courier New&#39;, monospace; line-height: 20.4px; white-space: pre-wrap; background-color: rgb(246, 246, 246);&quot;&gt;ViewRootImpl.performTraversals()&lt;/span&gt;      } catch (RuntimeException e) {          // BadTokenException or InvalidDisplayException, clean up.          synchronized (mLock) {              final int index = findViewLocked(view, false);              if (index &gt;= 0) {                  removeViewLocked(index, true);              }          }          throw e;      }  }</code></pre><p>在该方法中的root.setView(view,wparams,panelParentView)方法，调用的是ViewRootImpl类中的setView方法，正是该setView方法触发了ViewRootImpl.performTraversals()方法，也就是View绘制的起点，之后会进行measure,layout,draw三个步骤从而完成一个View的显示工作。</p><p>ViewRootImpl.java</p><pre><code class="java">/**  * We have one child  */  public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {      synchronized (this) {          if (mView == null) {              mView = view;              mAttachInfo.mDisplayState = mDisplay.getState();              mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);              ...              mSoftInputMode = attrs.softInputMode;              mWindowAttributesChanged = true;              mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;              mAttachInfo.mRootView = view;              mAttachInfo.mScalingRequired = mTranslator != null;              mAttachInfo.mApplicationScale =                      mTranslator == null ? 1.0f : mTranslator.applicationScale;              if (panelParentView != null) {                  mAttachInfo.mPanelParentWindowToken                          = panelParentView.getApplicationWindowToken();              }              mAdded = true;              int res; /* = WindowManagerImpl.ADD_OKAY; */              // Schedule the first layout -before- adding to the window              // manager, to make sure we do the relayout before receiving              // any other events from the system.              requestLayout();//这里开始请求view的绘制              if ((mWindowAttributes.inputFeatures                      &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {                  mInputChannel = new InputChannel();              }              try {                  mOrigWindowType = mWindowAttributes.type;                  mAttachInfo.mRecomputeGlobalAttributes = true;                  collectViewAttributes();                  res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,                          getHostVisibility(), mDisplay.getDisplayId(),                          mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,                          mAttachInfo.mOutsets, mInputChannel);              } catch (RemoteException e) {                  mAdded = false;                  mView = null;                  mAttachInfo.mRootView = null;                  mInputChannel = null;                  mFallbackEventHandler.setView(null);                  unscheduleTraversals();                  setAccessibilityFocus(null, null);                  throw new RuntimeException(&quot;Adding window failed&quot;, e);              } finally {                  if (restore) {                      attrs.restore();                  }              }              ....          }      }  }</code></pre><p>在setView的requestLayout方法中开始View的绘制。<br>ViewRootImpl.java</p><pre><code class="java">void scheduleTraversals() {      if (!mTraversalScheduled) {          mTraversalScheduled = true;          mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();          mChoreographer.postCallback(                  Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);          if (!mUnbufferedInputDispatch) {              scheduleConsumeBatchedInput();          }          notifyRendererOfFramePending();          pokeDrawLockIfNeeded();      }  }  void scheduleTraversals() {      if (!mTraversalScheduled) {          mTraversalScheduled = true;          mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();          mChoreographer.postCallback(                  Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);          if (!mUnbufferedInputDispatch) {              scheduleConsumeBatchedInput();          }          notifyRendererOfFramePending();          pokeDrawLockIfNeeded();      }  }  final class TraversalRunnable implements Runnable {      @Override      public void run() {          doTraversal();      }  }  final TraversalRunnable mTraversalRunnable = new TraversalRunnable();  void doTraversal() {      if (mTraversalScheduled) {          mTraversalScheduled = false;          mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);          if (mProfile) {              Debug.startMethodTracing(&quot;ViewAncestor&quot;);          }          performTraversals();          if (mProfile) {              Debug.stopMethodTracing();              mProfile = false;          }      }  }</code></pre><p> 在scheduleTraversals()方法中向mChoreographer中postCallback，而具体的Runable内容在TraversalRunnable类中，该类在run函数中直接执行doTraversal()方法，可以看到在该方法中最终调用了performTraversals()开启View的绘制工作。<br>查看ViewRootImpl.java中的performTraversals()的源码如下：</p><p>ViewRootImpl.java中的performTraversals()方法</p><pre><code class="java">private void performTraversals() {          // cache mView since it is used so much below...          final View host = mView;          ...          if (host == null || !mAdded)              return;          mIsInTraversal = true;          mWillDrawSoon = true;          boolean windowSizeMayChange = false;          boolean newSurface = false;          boolean surfaceChanged = false;          WindowManager.LayoutParams lp = mWindowAttributes;          int desiredWindowWidth;          int desiredWindowHeight;          final int viewVisibility = getHostVisibility();          boolean viewVisibilityChanged = mViewVisibility != viewVisibility                  || mNewSurfaceNeeded;          WindowManager.LayoutParams params = null;          if (mWindowAttributesChanged) {              mWindowAttributesChanged = false;              surfaceChanged = true;              params = lp;          }          CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();          if (compatibilityInfo.supportsScreen() == mLastInCompatMode) {              params = lp;              mFullRedrawNeeded = true;              mLayoutRequested = true;              if (mLastInCompatMode) {                  params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;                  mLastInCompatMode = false;              } else {                  params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;                  mLastInCompatMode = true;              }          }          mWindowAttributesChangesFlag = 0;          Rect frame = mWinFrame;          if (mFirst) {              mFullRedrawNeeded = true;              mLayoutRequested = true;              if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL                      || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {                  // NOTE -- system code, won&#39;t try to do compat mode.                  Point size = new Point();                  mDisplay.getRealSize(size);                  desiredWindowWidth = size.x;                  desiredWindowHeight = size.y;              } else {                  DisplayMetrics packageMetrics =                      mView.getContext().getResources().getDisplayMetrics();                  desiredWindowWidth = packageMetrics.widthPixels;                  desiredWindowHeight = packageMetrics.heightPixels;              }              // We used to use the following condition to choose 32 bits drawing caches:              // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888              // However, windows are now always 32 bits by default, so choose 32 bits              mAttachInfo.mUse32BitDrawingCache = true;              mAttachInfo.mHasWindowFocus = false;              mAttachInfo.mWindowVisibility = viewVisibility;              mAttachInfo.mRecomputeGlobalAttributes = false;              viewVisibilityChanged = false;              mLastConfiguration.setTo(host.getResources().getConfiguration());              mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;              // Set the layout direction if it has not been set before (inherit is the default)              if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) {                  host.setLayoutDirection(mLastConfiguration.getLayoutDirection());              }              host.dispatchAttachedToWindow(mAttachInfo, 0);//这里调用了View的dispatchAttachedToWindow，也就是这里回调了onAttachedToWindow方法。              mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);              dispatchApplyInsets(host);              //Log.i(TAG, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn);          } else {              desiredWindowWidth = frame.width();              desiredWindowHeight = frame.height();              if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {                  if (DEBUG_ORIENTATION) Log.v(TAG,                          &quot;View &quot; + host + &quot; resized to: &quot; + frame);                  mFullRedrawNeeded = true;                  mLayoutRequested = true;                  windowSizeMayChange = true;              }          }          ...      }</code></pre><p>在该方法中调用了host.dispatchAttachedToWindow(mAttachInfo, 0);方法。host是上面传下来的DecodView，该类继承与FrameLayout类，也就是ViewGroup的子类，所以先调用的是ViewGroup中的dispatchAttachedToWindow，其代码如下：</p><p>ViewGroup.java</p><pre><code class="java">@Override  void dispatchAttachedToWindow(AttachInfo info, int visibility) {      mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;      super.dispatchAttachedToWindow(info, visibility);//这里先调用父类，也就是View的dispathcAttachedToWindow。      mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;      final int count = mChildrenCount;      final View[] children = mChildren;      for (int i = 0; i &lt; count; i++) {          final View child = children[i];          child.dispatchAttachedToWindow(info,                  combineVisibility(visibility, child.getVisibility()));//这里调用子View的&lt;span style=&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;dispatchAttachedToWindow&lt;/span&gt;      }      final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size();      for (int i = 0; i &lt; transientCount; ++i) {          View view = mTransientViews.get(i);          view.dispatchAttachedToWindow(info,                  combineVisibility(visibility, view.getVisibility()));      }  }</code></pre><p>下面查看对应的View类中的dispatchAttacToWindow。代码如下：</p><p>View.java</p><pre><code class="java">void dispatchAttachedToWindow(AttachInfo info, int visibility) {          //System.out.println(&quot;Attached! &quot; + this);          mAttachInfo = info;          if (mOverlay != null) {              mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility);          }          mWindowAttachCount++;          // We will need to evaluate the drawable state at least once.          mPrivateFlags |= PFLAG_DRAWABLE_STATE_DIRTY;          if (mFloatingTreeObserver != null) {              info.mTreeObserver.merge(mFloatingTreeObserver);              mFloatingTreeObserver = null;          }          if ((mPrivateFlags&amp;PFLAG_SCROLL_CONTAINER) != 0) {              mAttachInfo.mScrollContainers.add(this);              mPrivateFlags |= PFLAG_SCROLL_CONTAINER_ADDED;          }          performCollectViewAttributes(mAttachInfo, visibility);          onAttachedToWindow();//快看，快看，在这里！终于找到这个方法调用的位置了          ListenerInfo li = mListenerInfo;          final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners =                  li != null ? li.mOnAttachStateChangeListeners : null;          if (listeners != null &amp;&amp; listeners.size() &gt; 0) {              // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to              // perform the dispatching. The iterator is a safe guard against listeners that              // could mutate the list by calling the various add/remove methods. This prevents              // the array from being modified while we iterate it.              for (OnAttachStateChangeListener listener : listeners) {                  listener.onViewAttachedToWindow(this);//              }          }          int vis = info.mWindowVisibility;          if (vis != GONE) {              onWindowVisibilityChanged(vis);          }          // Send onVisibilityChanged directly instead of dispatchVisibilityChanged.          // As all views in the subtree will already receive dispatchAttachedToWindow          // traversing the subtree again here is not desired.          onVisibilityChanged(this, visibility);          if ((mPrivateFlags&amp;PFLAG_DRAWABLE_STATE_DIRTY) != 0) {              // If nobody has evaluated the drawable state yet, then do it now.              refreshDrawableState();          }          needGlobalAttributesUpdate(false);      }</code></pre><p> 从上面代码可以看出一个布局的onAttachedToWindow会先调用自己的，然后再调用自己孩子的。而且从View.java的代码中也可以看出onAttachedToWindow和View自身的visibility无关，即使visibility==GONE，该方法也会调用。<br>好，下面来分析下onDetachedFromWindow方法的调用时机。在onDestory调用前会调用ActivityThread.java中的handleDestroyActivity方法，贴出代码：</p><p>ActivityThread.java</p><pre><code class="java">private void handleDestroyActivity(IBinder token, boolean finishing,          int configChanges, boolean getNonConfigInstance) {      ActivityClientRecord r = performDestroyActivity(token, finishing,              configChanges, getNonConfigInstance);      if (r != null) {          cleanUpPendingRemoveWindows(r);          WindowManager wm = r.activity.getWindowManager();          View v = r.activity.mDecor;          if (v != null) {              if (r.activity.mVisibleFromServer) {                  mNumVisibleActivities--;              }              IBinder wtoken = v.getWindowToken();              if (r.activity.mWindowAdded) {                  if (r.onlyLocalRequest) {                      // Hold off on removing this until the new activity&#39;s                      // window is being added.                      r.mPendingRemoveWindow = v;                      r.mPendingRemoveWindowManager = wm;                  } else {                      wm.removeViewImmediate(v);//看这里，看这里                  }              }              if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) {                  WindowManagerGlobal.getInstance().closeAll(wtoken,                          r.activity.getClass().getName(), &quot;Activity&quot;);              }              r.activity.mDecor = null;          }          if (r.mPendingRemoveWindow == null) {              // If we are delaying the removal of the activity window, then              // we can&#39;t clean up all windows here.  Note that we can&#39;t do              // so later either, which means any windows that aren&#39;t closed              // by the app will leak.  Well we try to warning them a lot              // about leaking windows, because that is a bug, so if they are              // using this recreate facility then they get to live with leaks.              WindowManagerGlobal.getInstance().closeAll(token,                      r.activity.getClass().getName(), &quot;Activity&quot;);          }          // Mocked out contexts won&#39;t be participating in the normal          // process lifecycle, but if we&#39;re running with a proper          // ApplicationContext we need to have it tear down things          // cleanly.          Context c = r.activity.getBaseContext();          if (c instanceof ContextImpl) {              ((ContextImpl) c).scheduleFinalCleanup(                      r.activity.getClass().getName(), &quot;Activity&quot;);          }      }      if (finishing) {          try {              ActivityManagerNative.getDefault().activityDestroyed(token);          } catch (RemoteException ex) {              // If the system process has died, it&#39;s game over for everyone.          }      }      mSomeActivitiesChanged = true;  }</code></pre><p> 看代码中的wm.removeViewImmediate方法，还是走到WindowManagerImpl类中的removeViewImmediate，代码如下：<br>WindowManagerImpl.java</p><pre><code class="java">@Override  public void removeViewImmediate(View view) {      mGlobal.removeView(view, true);  }</code></pre><p> 好熟悉啊，还是走到了WindowManagerGlobal类中的removeView，代码如下：<br>WindowManagerGlobal.java</p><pre><code class="java">public void removeView(View view, boolean immediate) {      if (view == null) {          throw new IllegalArgumentException(&quot;view must not be null&quot;);      }      synchronized (mLock) {          int index = findViewLocked(view, true);          View curView = mRoots.get(index).getView();          removeViewLocked(index, immediate);          if (curView == view) {              return;          }          throw new IllegalStateException(&quot;Calling with view &quot; + view                  + &quot; but the ViewAncestor is attached to &quot; + curView);      }  }  private void removeViewLocked(int index, boolean immediate) {      ViewRootImpl root = mRoots.get(index);      View view = root.getView();      if (view != null) {          InputMethodManager imm = InputMethodManager.getInstance();          if (imm != null) {              imm.windowDismissed(mViews.get(index).getWindowToken());          }      }      boolean deferred = root.die(immediate);      if (view != null) {          view.assignParent(null);          if (deferred) {              mDyingViews.add(view);          }      }  }</code></pre><p> 跟着代码继续走，到了ViewRootImpl类中的die，代码如下：<br>ViewRootImpl.java</p><pre><code class="java">/**      * @param immediate True, do now if not in traversal. False, put on queue and do later.      * @return True, request has been queued. False, request has been completed.      */      boolean die(boolean immediate) {          // Make sure we do execute immediately if we are in the middle of a traversal or the damage          // done by dispatchDetachedFromWindow will cause havoc on return.          if (immediate &amp;&amp; !mIsInTraversal) {              doDie();              return false;          }          if (!mIsDrawing) {              destroyHardwareRenderer();          } else {              Log.e(TAG, &quot;Attempting to destroy the window while drawing!\n&quot; +                      &quot;  window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle());          }          mHandler.sendEmptyMessage(MSG_DIE);          return true;      }      void doDie() {          checkThread();          if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface);          synchronized (this) {              if (mRemoved) {                  return;              }              mRemoved = true;              if (mAdded) {                  dispatchDetachedFromWindow();//看这里，看这里              }              if (mAdded &amp;&amp; !mFirst) {                  destroyHardwareRenderer();                  if (mView != null) {                      int viewVisibility = mView.getVisibility();                      boolean viewVisibilityChanged = mViewVisibility != viewVisibility;                      if (mWindowAttributesChanged || viewVisibilityChanged) {                          // If layout params have been changed, first give them                          // to the window manager to make sure it has the correct                          // animation info.                          try {                              if ((relayoutWindow(mWindowAttributes, viewVisibility, false)                                      &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {                                  mWindowSession.finishDrawing(mWindow);                              }                          } catch (RemoteException e) {                          }                      }                      mSurface.release();                  }              }              mAdded = false;          }          WindowManagerGlobal.getInstance().doRemoveView(this);      }</code></pre><p> 在doDie里面调用了dispatchDetachedFromWindow()方法，代码如下：<br>ViewRootImpl.java</p><pre><code class="java">void dispatchDetachedFromWindow() {          if (mView != null &amp;&amp; mView.mAttachInfo != null) {              mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false);              mView.dispatchDetachedFromWindow();//看这里，看这里          }          mAccessibilityInteractionConnectionManager.ensureNoConnection();          mAccessibilityManager.removeAccessibilityStateChangeListener(                  mAccessibilityInteractionConnectionManager);          mAccessibilityManager.removeHighTextContrastStateChangeListener(                  mHighContrastTextManager);          removeSendWindowContentChangedCallback();          destroyHardwareRenderer();          setAccessibilityFocus(null, null);          mView.assignParent(null);          mView = null;          mAttachInfo.mRootView = null;          mSurface.release();          if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) {              mInputQueueCallback.onInputQueueDestroyed(mInputQueue);              mInputQueue.dispose();              mInputQueueCallback = null;              mInputQueue = null;          }          if (mInputEventReceiver != null) {              mInputEventReceiver.dispose();              mInputEventReceiver = null;          }          try {              mWindowSession.remove(mWindow);          } catch (RemoteException e) {          }          // Dispose the input channel after removing the window so the Window Manager          // doesn&#39;t interpret the input channel being closed as an abnormal termination.          if (mInputChannel != null) {              mInputChannel.dispose();              mInputChannel = null;          }          mDisplayManager.unregisterDisplayListener(mDisplayListener);          unscheduleTraversals();      }</code></pre><p> 还记着在WindowManagerGlobal里面的root.setView(view, wparams, panelParentView);调用吧，这里的mView.dispatchDetachedFromWindow();这个mView也即是上面传过来的view。也就是先看DecorView即ViewGroup里面的dispatchDetachedFromWindow，代码如下：<br>ViewGroup.java</p><pre><code class="java">@Override  void dispatchDetachedFromWindow() {      // If we still have a touch target, we are still in the process of      // dispatching motion events to a child; we need to get rid of that      // child to avoid dispatching events to it after the window is torn      // down. To make sure we keep the child in a consistent state, we      // first send it an ACTION_CANCEL motion event.      cancelAndClearTouchTargets(null);      // Similarly, set ACTION_EXIT to all hover targets and clear them.      exitHoverTargets();      // In case view is detached while transition is running      mLayoutCalledWhileSuppressed = false;      // Tear down our drag tracking      mDragNotifiedChildren = null;      if (mCurrentDrag != null) {          mCurrentDrag.recycle();          mCurrentDrag = null;      }      final int count = mChildrenCount;      final View[] children = mChildren;      for (int i = 0; i &lt; count; i++) {          children[i].dispatchDetachedFromWindow();//这里会先调子类的dispatchDetachedFromWindow      }      clearDisappearingChildren();      final int transientCount = mTransientViews == null ? 0 : mTransientIndices.size();      for (int i = 0; i &lt; transientCount; ++i) {          View view = mTransientViews.get(i);          view.dispatchDetachedFromWindow();      }      super.dispatchDetachedFromWindow();//然后这里才调用自己的。  }</code></pre><p> 这之后又到View的dispatchDetachedFromWindow了，代码如下：<br>View.java</p><pre><code class="java">void dispatchDetachedFromWindow() {          AttachInfo info = mAttachInfo;          if (info != null) {              int vis = info.mWindowVisibility;              if (vis != GONE) {                  onWindowVisibilityChanged(GONE);              }          }          onDetachedFromWindow();//绕了一大圈，还是找到你了。快看快看，揪出来了。          onDetachedFromWindowInternal();          InputMethodManager imm = InputMethodManager.peekInstance();          if (imm != null) {              imm.onViewDetachedFromWindow(this);          }          ListenerInfo li = mListenerInfo;          final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners =                  li != null ? li.mOnAttachStateChangeListeners : null;          if (listeners != null &amp;&amp; listeners.size() &gt; 0) {              // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to              // perform the dispatching. The iterator is a safe guard against listeners that              // could mutate the list by calling the various add/remove methods. This prevents              // the array from being modified while we iterate it.              for (OnAttachStateChangeListener listener : listeners) {                  listener.onViewDetachedFromWindow(this);              }          }          if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) {              mAttachInfo.mScrollContainers.remove(this);              mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED;          }          mAttachInfo = null;          if (mOverlay != null) {              mOverlay.getOverlayView().dispatchDetachedFromWindow();          }      }</code></pre><p>看代码终于找到了onDetachedFromWindow的调用地方了。<br>这里总结下：</p><p>1.onAttachedToWindow调用顺序：ActivityThread.handleResumeActivity-&gt;WindowManagerImpl.addView-&gt;WindowManagerGlobal.addView-&gt;ViewRootImpl.performTraversals-&gt;ViewGroup.dispatchAttachedToWindow-&gt;View.dispatchAttachedToWindow-&gt;onAttachedToWindow</p><p>2.onDetachedFromWindow调用顺序：ActivityThread.handleDestroyActivity-&gt;WindowManagerImpl.removeViewImmediate-&gt;WindowManagerGlobal.removeView-&gt;ViewRootImpl.die-&gt;ViewRootImpl.doDie-&gt;ViewRootImpl.dispatchDetachedFromWindow-&gt;ViewGroup.dispatchDetachedFromWindow-&gt;View.dispatchDetachedFromWindow-&gt;onDetachedToWindow</p><p>3.onAttachedToWindow和onDetachedFromWindow的调用与visibility无关。</p><p>4.onAttachedToWindow是先调用自己，然后调用儿子View的。onDetachedFromWindow是先调用儿子View的，然后再调用自己的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-示例&quot;&gt;&lt;a href=&quot;#1-示例&quot; class=&quot;headerlink&quot; title=&quot;1.示例&quot;&gt;&lt;/a&gt;1.示例&lt;/h3&gt;&lt;p&gt;先上测试代码：&lt;br&gt;MyView.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public clas
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="onAttachedToWindow和onDetachedFromWindow,源码解析" scheme="http://yoursite.com/tags/onAttachedToWindow%E5%92%8ConDetachedFromWindow-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title> 在git命令行下查看git stash里面文件的内容</title>
    <link href="http://yoursite.com/2018/01/08/%E5%9C%A8git%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E6%9F%A5%E7%9C%8Bgit-stash%E9%87%8C%E9%9D%A2%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2018/01/08/在git命令行下查看git-stash里面文件的内容/</id>
    <published>2018-01-08T12:51:31.000Z</published>
    <updated>2018-01-09T14:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>在使用git的时候往往会保存一些东西，在保存的时候使用的就是git stash，强大的git使得保存修改和恢复修改变的很容易，但有时候时间久了不记得stash里面的内容是什么了。</p><h4 id="原英文地址"><a href="#原英文地址" class="headerlink" title="原英文地址"></a>原英文地址</h4><p>通过在stackflow里面查找，找到了一个好的方法。其网址是：<br><a href="http://stackoverflow.com/questions/10725729/git-see-whats-in-a-stash-without-applying-stash" target="_blank" rel="noopener">http://stackoverflow.com/questions/10725729/git-see-whats-in-a-stash-without-applying-stash</a> </p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>当利用git stash pop弹出来会有些耗费时间，这时可以使用git stash show来查看stash里面保存的内容。<br>在git bash上可以使用git –help stash来查看git stash命令的用法，当在stash后加show时，官方给出的介绍如下：</p><p>show stash</p><p>Show the changes recorded in the stash as a diff between the stashed state and its original parent. When no <stash> is given, shows the latest one. By default, the command shows the diffstat, but it will accept any format known to git diff(e.g., git stash show -p stash@{1} to view the second most recent stash in patch form). You can use stash.showStat and/or stash.showPatch config variables to change the default behavior.</stash></p><p>翻译如下：显示修改在stash状态与原版本之间的不同变化。当没有<stash>给定时，显示最新stash的变化。默认情况下，命令显示diffstat，它可以接受任何已知的git diff格式（例如，git stash show -p stash@{1}是查看第二最近stash的变化）。你可以使用stash.showstat和/或stash.showpatch配置变量来改变默认的行为。</stash></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>也就是使用git stash show -p stash@{1}来查看stash的内容变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;在使用git的时候往往会保存一些东西，在保存的时候使用的就是git stash，强大的git使得保存修改和恢复修改变的很容易，但有时候时间久
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="查看git bash内容" scheme="http://yoursite.com/tags/%E6%9F%A5%E7%9C%8Bgit-bash%E5%86%85%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>通过adb shell命令查看当前交互的Activity名称</title>
    <link href="http://yoursite.com/2018/01/08/%E9%80%9A%E8%BF%87adb-shell%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E4%BA%A4%E4%BA%92%E7%9A%84Activity%E5%90%8D%E7%A7%B0/"/>
    <id>http://yoursite.com/2018/01/08/通过adb-shell命令查看当前交互的Activity名称/</id>
    <published>2018-01-08T12:46:09.000Z</published>
    <updated>2018-01-09T14:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>在做android逆向的时候，有时候会需要知道当前的界面处于哪个Activity，这时候就可以使用adb shell命令来查看当前与用户交互的Activity名称。</p><h4 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h4><p>先给出原文地址：<br><a href="http://stackoverflow.com/questions/11549366/print-the-current-back-stack-in-the-log/26424943#26424943" target="_blank" rel="noopener">http://stackoverflow.com/questions/11549366/print-the-current-back-stack-in-the-log/26424943#26424943</a></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>有如下几种方法可以获取：</p><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><pre><code>adb shell dumpsys activity activities | sed -En -e &#39;/Running activities/,/Run #0/p&#39;</code></pre><p><img src="http://img.blog.csdn.net/20170110121929007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="方法一"><br>其中TaskRecord即为查询到的记录。其中com.sina.weibo为包名，.VisitorMainTabActivity为对应的Activity名称。</p><h5 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h5><pre><code>adb shell dumpsys activity | grep -i run</code></pre><p>查询结果为：<br><img src="http://img.blog.csdn.net/20170110122114759?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="方法二"></p><h5 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h5><pre><code>adb shell dumpsys activity | grep &quot;mFoc&quot;</code></pre><p>查询结果为：<br><img src="http://img.blog.csdn.net/20170110122247214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="方法三"><br>其中mFocusedActivity就是当前和用户交互的Activity。<br>如果在Windows下使用时，则先通过adb shell进入到adb shell里，然后把adb shell去了，再将余下的复制到$后面进行执行，例如：<br><img src="http://img.blog.csdn.net/20170110122816847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="在shell下执行grep语句"><br>这样就不会提示：“grep”不是内部或外部命令，也不是可运行查询了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h4&gt;&lt;p&gt;在做android逆向的时候，有时候会需要知道当前的界面处于哪个Activity，这时候就可以使用adb shell命令来查看当前与用户交互
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="adb查看交互Activity名称" scheme="http://yoursite.com/tags/adb%E6%9F%A5%E7%9C%8B%E4%BA%A4%E4%BA%92Activity%E5%90%8D%E7%A7%B0/"/>
    
  </entry>
  
  <entry>
    <title>自定义控件View之onMeasure调用时机源码分析</title>
    <link href="http://yoursite.com/2018/01/03/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6View%E4%B9%8BonMeasure%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2018/01/03/自定义控件View之onMeasure调用时机源码分析/</id>
    <published>2018-01-03T15:52:03.000Z</published>
    <updated>2018-01-03T15:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>先上测试代码：</p><p>MainActivity.java</p><pre><code class="java">import android.app.Activity;  import android.os.Bundle;  import android.util.Log;  public class MainActivity extends Activity {      @Override      protected void onCreate(Bundle savedInstanceState) {          super.onCreate(savedInstanceState);          Log.e(&quot;hty&quot;, &quot;before setContextView&quot;);          setContentView(R.layout.activity_main);          Log.e(&quot;hty&quot;, &quot;after setContextView&quot;);      }      @Override      protected void onResume() {          super.onResume();          Log.e(&quot;hty&quot;, &quot;onResume&quot;);      }      @Override      protected void onDestroy() {          super.onDestroy();          Log.e(&quot;hty&quot;, &quot;onDestroy&quot;);      }  }</code></pre><p>MyView.java</p><pre><code class="java">import android.content.Context;  import android.graphics.Canvas;  import android.graphics.Color;  import android.graphics.Paint;  import android.util.AttributeSet;  import android.util.Log;  import android.view.View;  public class MyView extends View {      Paint paint;      public MyView(Context context) {          this(context, null);      }      public MyView(Context context, AttributeSet attrs) {          super(context, attrs);          Log.e(&quot;hty&quot;,&quot;view constructor&quot;);          paint = new Paint();          paint.setColor(Color.RED);          paint.setTextSize(20);      }      @Override      protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {          super.onMeasure(widthMeasureSpec, heightMeasureSpec);          Log.e(&quot;hty&quot;,&quot;view onMeasure&quot;);      }      @Override      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {          super.onLayout(changed, left, top, right, bottom);          Log.e(&quot;hty&quot;,&quot;view onLayout&quot;);      }      String str = &quot;这里是测试&quot;;      @Override      protected void onDraw(Canvas canvas) {          super.onDraw(canvas);          Log.e(&quot;hty&quot;,&quot;view onDraw&quot;);          canvas.drawText(str, getWidth()/2-paint.measureText(str)/2,getHeight()/2, paint);      }  }</code></pre><p> activity_main.xml</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;      xmlns:tools=&quot;http://schemas.android.com/tools&quot;      android:id=&quot;@+id/activity_main&quot;      android:layout_width=&quot;match_parent&quot;      android:layout_height=&quot;match_parent&quot;      android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;      android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;      android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;      android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;      tools:context=&quot;com.zqc.mytest.MainActivity&quot;&gt;      &lt;com.zqc.mytest.MyView          android:layout_width=&quot;wrap_content&quot;          android:layout_height=&quot;wrap_content&quot;          android:text=&quot;Hello World!&quot; /&gt;  &lt;/RelativeLayout&gt;</code></pre><p> 正常运行后，查看对应的Log：<br><img src="http://img.blog.csdn.net/20170801161746746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"><br>从Log输出可以看出在一个View的绘制过程中，onMeasure是被多次调用了的。下面通过源码来一步步分析 onMeasure(int widthMeasureSpec, int heightMeasureSpec)函数，尤其是传过来的两个参数到底是从哪里来的。</p><p>首先看下MainActivity里面的setContentView，进入该函数后，其对应的代码如下：</p><p>Activity.java</p><pre><code class="java">public void setContentView(@LayoutRes int layoutResID) {      getWindow().setContentView(layoutResID);      initWindowDecorActionBar();  }</code></pre><p> 即调用了getWindow()的setContentView方法，查看getWindow方法，其返还的是类Window的一个实例mWindow，该类是一个抽象类，其具体实现类是PhoneWindow，即调用的是PhoneWindow的setContentView方法，查看相应的代码如下：<br>PhoneWindow.java</p><pre><code class="java">@Override  public void setContentView(int layoutResID) {      // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window      // decor, when theme attributes and the like are crystalized. Do not check the feature      // before this happens.      if (mContentParent == null) {          installDecor();      } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {          mContentParent.removeAllViews();      }      if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {          final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,                  getContext());          transitionTo(newScene);      } else {          mLayoutInflater.inflate(layoutResID, mContentParent);      }      mContentParent.requestApplyInsets();      final Callback cb = getCallback();      if (cb != null &amp;&amp; !isDestroyed()) {          cb.onContentChanged();      }  }</code></pre><p> 该方法首先判断mContentParent是否为空，不为空则调用installDecor()方法来初始化mContentParent，查看具体的代码：<br>PhoneWindow.java</p><pre><code class="java">private void installDecor() {      if (mDecor == null) {          mDecor = generateDecor();//这里生成了mDecor,它是所有应用窗口的根View 。          mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);          mDecor.setIsRootNamespace(true);          if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) {              mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);          }      }      if (mContentParent == null) {          mContentParent = generateLayout(mDecor);//这里就生成了mContentParent，这个generateLayout会根据设定的style来布局显示的界面          // Set up decor part of UI to ignore fitsSystemWindows if appropriate.          mDecor.makeOptionalFitsSystemWindows();          ....      }  }</code></pre><p>其中generateDecor方法就直接返回一个DecorView，代码如下：<br>PhoneWindow.java</p><pre><code class="java">protected DecorView generateDecor() {      return new DecorView(getContext(), -1);  }</code></pre><p> 而generateLayout(mDecor)方法会根据程序Activity设定的style来布局显示的界面，其代码如下：<br>PhoneWindow.java</p><pre><code class="java">protected ViewGroup generateLayout(DecorView decor) {      // Apply data from current theme.      TypedArray a = getWindowStyle();//获取窗口的style      。。。。      if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) {          requestFeature(FEATURE_NO_TITLE);//看到没，你在xml里面设置的FEATURE_NO_TITLE，在这里生效了      } else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) {          // Don&#39;t allow an action bar if there is no title.          requestFeature(FEATURE_ACTION_BAR);      }      。。。。      final Context context = getContext();      。。。。      WindowManager.LayoutParams params = getAttributes();      if (!hasSoftInputMode()) {          params.softInputMode = a.getInt(                  R.styleable.Window_windowSoftInputMode,                  params.softInputMode);      }      if (a.getBoolean(R.styleable.Window_backgroundDimEnabled,              mIsFloating)) {          /* All dialogs should have the window dimmed */          if ((getForcedWindowFlags()&amp;WindowManager.LayoutParams.FLAG_DIM_BEHIND) == 0) {              params.flags |= WindowManager.LayoutParams.FLAG_DIM_BEHIND;          }          if (!haveDimAmount()) {              params.dimAmount = a.getFloat(                      android.R.styleable.Window_backgroundDimAmount, 0.5f);          }      }      。。。。      int layoutResource;      int features = getLocalFeatures();      。。。。      View in = mLayoutInflater.inflate(layoutResource, null);//这里把给定的布局加载出来，然后加到decor中      decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));      mContentRoot = (ViewGroup) in;      ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);//看到没这个ID_ANDROID_CONTENT，也就是一个窗口的根布局      if (contentParent == null) {          throw new RuntimeException(&quot;Window couldn&#39;t find content container view&quot;);      }      。。。。      mDecor.finishChanging();      return contentParent;  }</code></pre><p> 通过一张图来分析下一个窗口的布局具体是怎样的。<br><img src="http://img.blog.csdn.net/20170801171514871?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHR5MTA1MzI0MDEyMw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="窗口布局"><br>图上标的很详细，在最外层是一个FramLayout，其实也就是DecorView，是所有窗口的根布局，在该根布局下有一个(0)LinearLayout和一个(1)View，这个(1)View就是状态栏，(0)LinearLayout里面有个FrameLayout，在里面的多个View有固定的id，在图中已经标明，所有在一个Activity通过findViewById获取的ID_ANDROID_CONTENT就是<br>(0)FrameLayout-&gt;(0)LinearLayout-&gt;(0)FrameLayout-&gt;(1)FrameLayout对应的View。<br>要知道onMeasure两个参数到底是从哪里来的，还得再找下View是如何绘制的，上一篇文章有分析。View的绘制从ViewRootImpl的performTraversals()函数开始，下面进入该方法中具体分析下。</p><p>ViewRootImpl.java</p><pre><code class="java">private void performTraversals() {      // cache mView since it is used so much below...      final View host = mView;      。。。。      mIsInTraversal = true;      mWillDrawSoon = true;      boolean windowSizeMayChange = false;      boolean newSurface = false;      boolean surfaceChanged = false;      WindowManager.LayoutParams lp = mWindowAttributes;      int desiredWindowWidth;      int desiredWindowHeight;      final int viewVisibility = getHostVisibility();      boolean viewVisibilityChanged = mViewVisibility != viewVisibility              || mNewSurfaceNeeded;      WindowManager.LayoutParams params = null;      if (mWindowAttributesChanged) {          mWindowAttributesChanged = false;          surfaceChanged = true;          params = lp;      }      。。。。      Rect frame = mWinFrame;      if (mFirst) {          mFullRedrawNeeded = true;          mLayoutRequested = true;          if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL                  || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {              // NOTE -- system code, won&#39;t try to do compat mode.              Point size = new Point();              mDisplay.getRealSize(size);              desiredWindowWidth = size.x;              desiredWindowHeight = size.y;          } else {              DisplayMetrics packageMetrics =                  mView.getContext().getResources().getDisplayMetrics();              desiredWindowWidth = packageMetrics.widthPixels;              desiredWindowHeight = packageMetrics.heightPixels;          }         。。。。      } else {          desiredWindowWidth = frame.width();          desiredWindowHeight = frame.height();          if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {              if (DEBUG_ORIENTATION) Log.v(TAG,                      &quot;View &quot; + host + &quot; resized to: &quot; + frame);              mFullRedrawNeeded = true;              mLayoutRequested = true;              windowSizeMayChange = true;          }      }      if (viewVisibilityChanged) {          mAttachInfo.mWindowVisibility = viewVisibility;          host.dispatchWindowVisibilityChanged(viewVisibility);          if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) {              destroyHardwareResources();          }          if (viewVisibility == View.GONE) {              // After making a window gone, we will count it as being              // shown for the first time the next time it gets focus.              mHasHadWindowFocus = false;          }      }      。。。。      boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);      if (layoutRequested) {          final Resources res = mView.getContext().getResources();          if (mFirst) {              // make sure touch mode code executes by setting cached value              // to opposite of the added touch mode.              mAttachInfo.mInTouchMode = !mAddedTouchMode;              ensureTouchModeLocally(mAddedTouchMode);          } else {              。。。。              if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT                      || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {                  windowSizeMayChange = true;                  if (lp.type == WindowManager.LayoutParams.TYPE_STATUS_BAR_PANEL                          || lp.type == WindowManager.LayoutParams.TYPE_INPUT_METHOD) {                      // NOTE -- system code, won&#39;t try to do compat mode.                      Point size = new Point();                      mDisplay.getRealSize(size);                      desiredWindowWidth = size.x;                      desiredWindowHeight = size.y;                  } else {                      DisplayMetrics packageMetrics = res.getDisplayMetrics();                      desiredWindowWidth = packageMetrics.widthPixels;                      desiredWindowHeight = packageMetrics.heightPixels;                  }              }          }          // Ask host how big it wants to be          windowSizeMayChange |= measureHierarchy(host, lp, res,                  desiredWindowWidth, desiredWindowHeight);      }      。。。。          if (!mStopped || mReportNextDraw) {              boolean focusChangedDueToTouchMode = ensureTouchModeLocally(                      (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);              if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()                      || mHeight != host.getMeasuredHeight() || contentInsetsChanged) {                  int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);//获取                  int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);                  if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed!  mWidth=&quot;                          + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()                          + &quot; mHeight=&quot; + mHeight                          + &quot; measuredHeight=&quot; + host.getMeasuredHeight()                          + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);                   // Ask host how big it wants to be                  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//看这里，看这里                  // Implementation of weights from WindowManager.LayoutParams                  // We just grow the dimensions as needed and re-measure if                  // needs be                  int width = host.getMeasuredWidth();                  int height = host.getMeasuredHeight();                  boolean measureAgain = false;                  if (lp.horizontalWeight &gt; 0.0f) {                      width += (int) ((mWidth - width) * lp.horizontalWeight);                      childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,                              MeasureSpec.EXACTLY);                      measureAgain = true;                  }                  if (lp.verticalWeight &gt; 0.0f) {                      height += (int) ((mHeight - height) * lp.verticalWeight);                      childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,                              MeasureSpec.EXACTLY);                      measureAgain = true;                  }                  if (measureAgain) {                      if (DEBUG_LAYOUT) Log.v(TAG,                              &quot;And hey let&#39;s measure once more: width=&quot; + width                              + &quot; height=&quot; + height);                      performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//看这里，看这里                  }                  layoutRequested = true;              }          }      }       。。。。      mIsInTraversal = false;  }   private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {      Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);      try {          mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);      } finally {          Trace.traceEnd(Trace.TRACE_TAG_VIEW);      }  }</code></pre><p> 看performTraversals方法中调用的performMeasure的地方，performMeasure即调用了View的measure方法，而measure方法会去调用onMeasure方法。<br>看下如下两行代码</p><pre><code class="java">int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);//获取  int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</code></pre><p> 在这两行代码中获取了child的宽高，使用的方法是getRootMeasureSpec，其中参数lp.width是传入的MATCH_PARENT或者WRAP_CONTENT，mWidth是窗口期望的大小，getRootMeasureSpec代码如下：<br>ViewRootImpl.java</p><pre><code class="java">private static int getRootMeasureSpec(int windowSize, int rootDimension) {      int measureSpec;      switch (rootDimension) {      case ViewGroup.LayoutParams.MATCH_PARENT:          // Window can&#39;t resize. Force root view to be windowSize.          measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);          break;      case ViewGroup.LayoutParams.WRAP_CONTENT:          // Window can resize. Set max size for root view.          measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);          break;      default:          // Window wants to be an exact size. Force root view to be that size.          measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);          break;      }      return measureSpec;  }</code></pre><p>这里应该很好理解了，其中调用了MeasureSpec类中的方法，关于MeasureSpec类网上资料很多，该类中用一个int值的两部分分别表示Mode和具体的尺寸。其中最高两位表示</p><p>Mode，而最低的30位表示具体的尺寸值，这里计算完之后就进入了View的measure函数中，代码如下：</p><p>View.java</p><pre><code class="java">public final void measure(int widthMeasureSpec, int heightMeasureSpec) {          boolean optical = isLayoutModeOptical(this);          if (optical != isLayoutModeOptical(mParent)) {              Insets insets = getOpticalInsets();              int oWidth  = insets.left + insets.right;              int oHeight = insets.top  + insets.bottom;              widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);              heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);          }          // Suppress sign extension for the low bytes          long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL;          if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2);          if ((mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ||                  widthMeasureSpec != mOldWidthMeasureSpec ||                  heightMeasureSpec != mOldHeightMeasureSpec) {              // first clears the measured dimension flag              mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;              resolveRtlPropertiesIfNeeded();              int cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -1 :                      mMeasureCache.indexOfKey(key);              if (cacheIndex &lt; 0 || sIgnoreMeasureCache) {                  // measure ourselves, this should set the measured dimension flag back                  onMeasure(widthMeasureSpec, heightMeasureSpec);                  mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;              } else {                  long value = mMeasureCache.valueAt(cacheIndex);                  // Casting a long to int drops the high 32 bits, no mask needed                  setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value);                  mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;              }              // flag not set, setMeasuredDimension() was not invoked, we raise              // an exception to warn the developer              if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) {                  throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot;                          + getClass().getName() + &quot;#onMeasure() did not set the&quot;                          + &quot; measured dimension by calling&quot;                          + &quot; setMeasuredDimension()&quot;);              }              mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;          }          mOldWidthMeasureSpec = widthMeasureSpec;          mOldHeightMeasureSpec = heightMeasureSpec;          mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 |                  (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension      }</code></pre><p>该方法是final的，因而不能被继承，但是里面提供了onMeasure回调，这样子类就可以直接继承onMeasure函数来实现相应的操作。这个View类型的，但是还有一种是ViewGroup类型，也就是容器类型的控件，在具体容器类型的控件里面可以通过重写onMeasure来实现，比如FrameLayout中的onMeasure函数如下：<br>FrameLayout.java</p><pre><code class="java">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {       int count = getChildCount();       final boolean measureMatchParentChildren =               MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||               MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;       mMatchParentChildren.clear();       int maxHeight = 0;       int maxWidth = 0;       int childState = 0;       for (int i = 0; i &lt; count; i++) {           final View child = getChildAt(i);           if (mMeasureAllChildren || child.getVisibility() != GONE) {               measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);               final LayoutParams lp = (LayoutParams) child.getLayoutParams();               maxWidth = Math.max(maxWidth,                       child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);               maxHeight = Math.max(maxHeight,                       child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);               childState = combineMeasuredStates(childState, child.getMeasuredState());               if (measureMatchParentChildren) {                   if (lp.width == LayoutParams.MATCH_PARENT ||                           lp.height == LayoutParams.MATCH_PARENT) {                       mMatchParentChildren.add(child);                   }               }           }       }       // Account for padding too       maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();       maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();       // Check against our minimum height and width       maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());       maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());       // Check against our foreground&#39;s minimum height and width       final Drawable drawable = getForeground();       if (drawable != null) {           maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());           maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());       }       setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),               resolveSizeAndState(maxHeight, heightMeasureSpec,                       childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));       count = mMatchParentChildren.size();       if (count &gt; 1) {           for (int i = 0; i &lt; count; i++) {               final View child = mMatchParentChildren.get(i);               final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();               final int childWidthMeasureSpec;               if (lp.width == LayoutParams.MATCH_PARENT) {                   final int width = Math.max(0, getMeasuredWidth()                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()                           - lp.leftMargin - lp.rightMargin);                   childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(                           width, MeasureSpec.EXACTLY);               } else {                   childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,                           getPaddingLeftWithForeground() + getPaddingRightWithForeground() +                           lp.leftMargin + lp.rightMargin,                           lp.width);               }               final int childHeightMeasureSpec;               if (lp.height == LayoutParams.MATCH_PARENT) {                   final int height = Math.max(0, getMeasuredHeight()                           - getPaddingTopWithForeground() - getPaddingBottomWithForeground()                           - lp.topMargin - lp.bottomMargin);                   childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(                           height, MeasureSpec.EXACTLY);               } else {                   childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,                           getPaddingTopWithForeground() + getPaddingBottomWithForeground() +                           lp.topMargin + lp.bottomMargin,                           lp.height);               }               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);           }       }   }</code></pre><p> 大概也就是回调本容器里面的子View的measure函数实现尺寸计算。这里通过方法ViewGroup类中的getChildMeasureSpec()来获取子类期望自己获取的宽高大小。其代码是<br>ViewGroup.java</p><pre><code class="java">public static int getChildMeasureSpec(int spec, int padding, int childDimension) {          int specMode = MeasureSpec.getMode(spec);          int specSize = MeasureSpec.getSize(spec);          int size = Math.max(0, specSize - padding);          int resultSize = 0;          int resultMode = 0;          switch (specMode) {          // Parent has imposed an exact size on us          case MeasureSpec.EXACTLY:              if (childDimension &gt;= 0) {                  resultSize = childDimension;                  resultMode = MeasureSpec.EXACTLY;              } else if (childDimension == LayoutParams.MATCH_PARENT) {                  // Child wants to be our size. So be it.                  resultSize = size;                  resultMode = MeasureSpec.EXACTLY;              } else if (childDimension == LayoutParams.WRAP_CONTENT) {                  // Child wants to determine its own size. It can&#39;t be                  // bigger than us.                  resultSize = size;                  resultMode = MeasureSpec.AT_MOST;              }              break;          // Parent has imposed a maximum size on us          case MeasureSpec.AT_MOST:              if (childDimension &gt;= 0) {                  // Child wants a specific size... so be it                  resultSize = childDimension;                  resultMode = MeasureSpec.EXACTLY;              } else if (childDimension == LayoutParams.MATCH_PARENT) {                  // Child wants to be our size, but our size is not fixed.                  // Constrain child to not be bigger than us.                  resultSize = size;                  resultMode = MeasureSpec.AT_MOST;              } else if (childDimension == LayoutParams.WRAP_CONTENT) {                  // Child wants to determine its own size. It can&#39;t be                  // bigger than us.                  resultSize = size;                  resultMode = MeasureSpec.AT_MOST;              }              break;          // Parent asked to see how big we want to be          case MeasureSpec.UNSPECIFIED:              if (childDimension &gt;= 0) {                  // Child wants a specific size... let him have it                  resultSize = childDimension;                  resultMode = MeasureSpec.EXACTLY;              } else if (childDimension == LayoutParams.MATCH_PARENT) {                  // Child wants to be our size... find out how big it should                  // be                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;                  resultMode = MeasureSpec.UNSPECIFIED;              } else if (childDimension == LayoutParams.WRAP_CONTENT) {                  // Child wants to determine its own size.... find out how                  // big it should be                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;                  resultMode = MeasureSpec.UNSPECIFIED;              }              break;          }          return MeasureSpec.makeMeasureSpec(resultSize, resultMode);      }</code></pre><p>  在重写onMeasure方法时一定要调用setMeasuredDimension，该方法会将mPrivateFlags经过或使得View知道已经经过了measure这个步骤了。代码如下：<br>View.java</p><pre><code class="java">protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {      boolean optical = isLayoutModeOptical(this);      if (optical != isLayoutModeOptical(mParent)) {          Insets insets = getOpticalInsets();          int opticalWidth  = insets.left + insets.right;          int opticalHeight = insets.top  + insets.bottom;          measuredWidth  += optical ? opticalWidth  : -opticalWidth;          measuredHeight += optical ? opticalHeight : -opticalHeight;      }      setMeasuredDimensionRaw(measuredWidth, measuredHeight);  }  private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) {      mMeasuredWidth = measuredWidth;      mMeasuredHeight = measuredHeight;      mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;  }</code></pre><p>至此分析结束，所以说一个View的大小是由自己和父类两者共同决定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先上测试代码：&lt;/p&gt;
&lt;p&gt;MainActivity.java&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;import android.app.Activity;  
import android.os.Bundle;  
import android.ut
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="View onMeasure" scheme="http://yoursite.com/tags/View-onMeasure/"/>
    
  </entry>
  
  <entry>
    <title>应用内存优化之OnLowMemory&amp;OnTrimMemory</title>
    <link href="http://yoursite.com/2018/01/03/%E5%BA%94%E7%94%A8%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E4%B9%8BOnLowMemory-OnTrimMemory/"/>
    <id>http://yoursite.com/2018/01/03/应用内存优化之OnLowMemory-OnTrimMemory/</id>
    <published>2018-01-03T15:39:09.000Z</published>
    <updated>2018-01-03T15:41:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-应用内存onLowMemory-amp-onTrimMemory优化"><a href="#1-应用内存onLowMemory-amp-onTrimMemory优化" class="headerlink" title="1.应用内存onLowMemory&amp; onTrimMemory优化"></a>1.应用内存onLowMemory&amp; onTrimMemory优化</h3><p>onLowMemory&amp; onTrimMemory简介：<br>OnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。<br>OnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。根据不同的内存状态，来响应不同的内存释放策略。</p><h4 id="1-1-onLowMemory-amp-onTrimMemory优化，需要释放什么资源？"><a href="#1-1-onLowMemory-amp-onTrimMemory优化，需要释放什么资源？" class="headerlink" title="1.1 onLowMemory&amp; onTrimMemory优化，需要释放什么资源？"></a>1.1 onLowMemory&amp; onTrimMemory优化，需要释放什么资源？</h4><p>在内存紧张的时候，会回调OnLowMemory/OnTrimMemory，需要在回调方法中编写释放资源的代码。<br>可以在资源紧张的时候，释放UI 使用的资源资：Bitmap、数组、控件资源。</p><h4 id="1-2-OnLowMemory"><a href="#1-2-OnLowMemory" class="headerlink" title="1.2 OnLowMemory"></a>1.2 OnLowMemory</h4><p>OnLowMemory是Android提供的API，在系统内存不足，所有后台程序（优先级为background的进程，不是指后台运行的进程）都被杀死时，系统会调用OnLowMemory。系统提供的回调有：<br>Application.onLowMemory()<br>Activity.OnLowMemory()<br>Fragement.OnLowMemory()<br>Service.OnLowMemory()<br>ContentProvider.OnLowMemory()</p><p>除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如：</p><pre><code class="java"> public static class MyCallback implements ComponentCallbacks {   @Override   public void onConfigurationChanged(Configuration arg) {   }   @Override   public void onLowMemory() {   //do release operation   }</code></pre><p>然后，通过Context.registerComponentCallbacks ()在合适的时候注册回调就可以了。通过这种自定义的方法，可以在很多地方注册回调，而不需要局限于系统提供的组件。<br>onLowMemory 当后台程序已经终止资源还匮乏时会调用这个方法。好的应用程序一般会在这个方法里面释放一些不必要的资源来应付当后台程序已经终止，前台应用程序内存还不够时的情况。</p><h4 id="1-3-OnTrimMemory"><a href="#1-3-OnTrimMemory" class="headerlink" title="1.3 OnTrimMemory"></a>1.3 OnTrimMemory</h4><p>OnTrimMemory是Android 4.0之后提供的API，系统会根据不同的内存状态来回调。系统提供的回调有：<br>Application.onTrimMemory()<br>Activity.onTrimMemory()<br>Fragement.OnTrimMemory()<br>Service.onTrimMemory()<br>ContentProvider.OnTrimMemory()<br>OnTrimMemory的参数是一个int数值，代表不同的内存状态：<br>TRIM_MEMORY_COMPLETE：内存不足，并且该进程在后台进程列表最后一个，马上就要被清理<br>TRIM_MEMORY_MODERATE：内存不足，并且该进程在后台进程列表的中部。<br>TRIM_MEMORY_BACKGROUND：内存不足，并且该进程是后台进程。<br>TRIM_MEMORY_UI_HIDDEN：内存不足，并且该进程的UI已经不可见了。<br>以上4个是4.0增加<br>TRIM_MEMORY_RUNNING_CRITICAL：内存不足(后台进程不足3个)，并且该进程优先级比较高，需要清理内存<br>TRIM_MEMORY_RUNNING_LOW：内存不足(后台进程不足5个)，并且该进程优先级比较高，需要清理内存<br>TRIM_MEMORY_RUNNING_MODERATE：内存不足(后台进程超过5个)，并且该进程优先级比较高，需要清理内存<br>以上3个是4.1增加<br>系统也提供了一个ComponentCallbacks2，通过Context.registerComponentCallbacks()注册后，就会被系统回调到。</p><h4 id="1-4-OnLowMemory和OnTrimMemory的比较"><a href="#1-4-OnLowMemory和OnTrimMemory的比较" class="headerlink" title="1.4 OnLowMemory和OnTrimMemory的比较"></a>1.4 OnLowMemory和OnTrimMemory的比较</h4><p>1，OnLowMemory被回调时，已经没有后台进程；而onTrimMemory被回调时，还有后台进程。<br>2，OnLowMemory是在最后一个后台进程被杀时调用，一般情况是low memory killer 杀进程后触发；而OnTrimMemory的触发更频繁，每次计算进程优先级时，只要满足条件，都会触发。<br>3，通过一键清理后，OnLowMemory不会被触发，而OnTrimMemory会被触发一次。</p><p>使用举例：</p><pre><code class="java"> @Override public void onTrimMemory(int level) { Log.e(TAG, &quot; onTrimMemory ... level:&quot; + level);  } @Override public void onLowMemory() {  Log.e(TAG, &quot; onLowMemory ... &quot;);  }</code></pre><h3 id="2-系统回调优化"><a href="#2-系统回调优化" class="headerlink" title="2.系统回调优化"></a>2.系统回调优化</h3><h4 id="2-1-回调原理："><a href="#2-1-回调原理：" class="headerlink" title="2.1 回调原理："></a>2.1 回调原理：</h4><p>在Application、 Activity、Fragement、Service、ContentProvider中都可以重写回调方法，对OnLowMemory/OnTrimMemory进行回调，在回调方法中实现资源释放的实现。<br>以Activity为例，在Activity源码中能够看到对于onTrimMemory的定义，因此在回调的时候重写方法即可。</p><pre><code class="java"> public void onTrimMemory(int level) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onTrimMemory &quot; + this + &quot;: &quot; + level); 　　mCalled = true; 　　mFragments.dispatchTrimMemory(level);}</code></pre><p>2.2 释放资源：<br>在onTrimMemory释放资源，释放图片、数组、缓存等资源。</p><pre><code class="java"> @Override public void onTrimMemory(int level) { // TODO Auto-generated method stub DLog.d(&quot; onTrimMemory ... level:&quot; + level); switch(level)  {  case TRIM_MEMORY_UI_HIDDEN:  //释放资源 /*编写释放资源代码*/ } break; } super.onTrimMemory(level); }</code></pre><p>下面是释放Bitmap的示例代码片段：</p><pre><code class="java">1 // 先判断是否已经回收2 if(bitmap != null &amp;&amp; !bitmap.isRecycled()){ 3 // 回收并且置为null4 bitmap.recycle(); 5 bitmap = null; 6 } 7 System.gc();复制代码list占用方法：list.clear();然后在置空。</code></pre><h3 id="3-实现ComponentCallbacks"><a href="#3-实现ComponentCallbacks" class="headerlink" title="3.实现ComponentCallbacks"></a>3.实现ComponentCallbacks</h3><p>OnLowMemory除了上述系统提供的API，还可以自己实现ComponentCallbacks，通过API注册，这样也能得到OnLowMemory回调。例如：</p><pre><code class="java"> public static class ViewComponentCallbacks implements ComponentCallbacks { @Override  public void onConfigurationChanged(Configuration arg) {  }  @Override  public void onLowMemory() {  //do release operation  } }</code></pre><p>注册自定义的回调类：</p><p> ViewComponentCallbacks callBacks =new ViewComponentCallbacks();<br> this.registerComponentCallbacks( callBacks );<br>回调之后，即可进行重写：</p><pre><code class="java"> @Override public void onLowMemory() { // TODO Auto-generated method stub //释放资源的方法 super.onLowMemory(); }</code></pre><p>Android onTrimMemory方法的一些疑惑？<br>当你的app进程正在被cached时，你可能会接受到从onTrimMemory()中返回的下面的值之一:</p><p>TRIM_MEMORY_BACKGROUND: 系统正运行于低内存状态并且你的进程正处于LRU缓存名单中最不容易杀掉的位置。尽管你的app进程并不是处于被杀掉的高危险状态，系统可能已经开始杀掉LRU缓存中的其他进程了。你应该释放那些容易恢复的资源，以便于你的进程可以保留下来，这样当用户回退到你的app的时候才能够迅速恢复。<br>TRIM_MEMORY_MODERATE: 系统正运行于低内存状态并且你的进程已经已经接近LRU名单的中部位置。如果系统开始变得更加内存紧张，你的进程是有可能被杀死的。<br>TRIM_MEMORY_COMPLETE: 系统正运行与低内存的状态并且你的进程正处于LRU名单中最容易被杀掉的位置。你应该释放任何不影响你的app恢复状态的资源。<br>这个地方讲的进程正在被cache 是什么意思呢？是指我的进程 还没有结束 正在内存中 但是因为没有执行任何操作 不占有cpu的意思吗？<br>此外当我们监听onTrimMemory回调方法的时候，假设我的缓存里最大的部分就是bitmap，请问就直接把bitmap从内存里抹去就可以了么？ 那如果这么做，在进程重新被加载到前台来的时候，我怎么迅速恢复这些bitmap资源？</p><h3 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h3><h4 id="答疑1："><a href="#答疑1：" class="headerlink" title="答疑1："></a>答疑1：</h4><p>android进程回收主要涉及两个组件：ActivityManagerService（Ams）和lowmemorykiller。当手机内存不足时，lowmemorykiller就要开始杀进程了。但是lowmemorykiller呢只知道进程占用的内存大小，不知道进程对用户的重要性。Ams则负责管理android四大组件，当然知道进程的重要性了，所以呢还需要与Ams充分交换意见。</p><p>当app状态发生改变时，比如退到后台时，ams会对app的进程计算出一个值，即Oomadj（ams#computeOomAdjLocked），然后把这个值传给linux内核，lowmemorykiller呢就可以拿到这个值了，lowmemorykiller则就有了所有app进程的Oomadj值，即进程对用户的重要程度。当手机内存不足时，lowmemorykiller就有了足够的信息决定干掉哪个进程了。那，lowmemorykiller决定干掉哪个进程呢？这个要根据手机还有多少空闲内存，比如还有16MB空闲内存，如下lowmemorykiller.c</p><pre><code class="java">static short lowmem_adj[6] = {0,1,6,12,};static int lowmem_adj_size = 4;static int lowmem_minfree[6] = {3 * 512,    /* 6MB */2 * 1024,    /* 8MB */4 * 1024,    /* 16MB */16 * 1024,    /* 64MB */};</code></pre><p>16MB在lowmem_minfree第三个位置，取lowmem_adj第三个位置即6，ok所有Oomadj大于6的进程就被选中了。而lowmemorykiller不是把这些选中的进程都干掉，而是先干掉oomAdj最大而且占用内存最大的进程。如下lowmemorykiller.c#lowmem_scan：</p><pre><code class="java">for_each_process(tsk) {  ...oom_score_adj = p-&gt;signal-&gt;oom_score_adj;if (oom_score_adj &lt; min_score_adj) {task_unlock(p);continue;}tasksize = get_mm_rss(p-&gt;mm);task_unlock(p);if (tasksize &lt;= 0)continue;if (selected) {if (oom_score_adj &lt; selected_oom_score_adj)continue;if (oom_score_adj == selected_oom_score_adj &amp;&amp;tasksize &lt;= selected_tasksize)continue;}selected = p;selected_tasksize = tasksize;selected_oom_score_adj = oom_score_adj;}</code></pre><p>总之一句话：进程对用户越不重要（Oomadj值就越大），占用内存越大，进程就越容易被干掉。</p><p>应对策略：</p><p>1 ams计算出一个危险的Oomadj值会调用onTrimMemory通知app，此时app应该把不重要的内存释放掉，只要比友商app占用的内存小被lowmemorykiller干掉的概率就小。</p><p>2 当然我们也可以先把忧伤的app干掉。。。帮用户释放内存（开玩笑啦）</p><p>3 如果我们的app能预置到手机中，并且manifest设置为persistence（Oomadj=0），或者coreserver则不必担心被lowmemorykiller干掉了。不过还有可能被linux层的oomkiller干掉的。当然这也是某些手机预置一堆app导致越用越慢的一个原因，所以我们尽量把这些预置app卸载掉。</p><h4 id="答疑2："><a href="#答疑2：" class="headerlink" title="答疑2："></a>答疑2：</h4><p>理解进程和组件之间的关系</p><p>一般来说，你的App在启动的时候，系统都会为你的APP创建一个进程。</p><p>比如我有一个App，其包名为com.performance.liferecord</p><p>当这个App启动的时候，我们可以通过ps命令来看其对应的进程 信息：</p><p>结果如下：</p><p>USER PID PPID VSIZE RSS WCHAN PC NAME</p><p>可以看到系统为这个进程分配的PD是32452，那么 PPID是什么呐？</p><p>使用PS命令来看：adb shell ps | grep 379</p><p>可以看到PPID的NAME是zygote64，也就是说32452这个进程是从Android的zygote64这个进程fork过来的。</p><p>那么 组件又是怎么回事呐？我们常说四大组件，Activity、Service、Broadcast、ContentProvider。这些个组件都是依附于一个进程来运行的，一个进程可以有多个Activity、Service等，也可以一个组件都没有。</p><p>Cache状态</p><p>当你的应用程序到了后台之后，会进入Cached状态，这时候进程还存在，但是组件是否存在就不一定了。</p><p>不过一般我们认为，当你按Back键回到桌面之后，如果Activity没有被释放，那么我们认为了内容泄漏，这个有兴趣可以自己看看。</p><p>以上面我提到的com.performance.liferecord这个应用为例子，当我启动这个应用之后，我们可以使用命令adb shell dumpsys meminfo来查看整个系统的状态，此时com.performance.liferecord这个进程状态为Foreground:</p><p>Foreground意味着此时你的进程处于前台进程，你的程序的界面可以被用户看到。此时我们使用adb shell dumpsys meminfo com.preformance.liferecord来看这个进程的状态：</p><p>可以看到Activity的数量为1（因为我只起了一个Activity）</p><p>当我们点击Back键的时候，我们可以使用命令adb shell dumpsys meminfo来查看 整个系统的状态，此时com.performance.liferecord这个进程状态为Cached:</p><p>Cached状态标识你的应用进程变成了后台进程，位于LRU list里面。</p><p>此时我们使用adb shell dumpsys meminfo com.performance.liferecord来看这个进程的状态：</p><p>Activity的数量妥妥变成0了，说明没有内存泄漏。此时你的进程里面，是没有任何组件的。当然也不占用cpu的资源，但是会点内存（例子中我们可以看到占用了20706kb）的内存。</p><p>将后台进程放到Cached列表里而不是直接杀掉，其好处就是下一次这个进程的某个组件（最常见的就是Activity）启动的时候，不需要再创建新的进程 ，速度杠杠的（比如就应用的热启动）。</p><p>onTrimMemory</p><p>此外当我们监听onTrimMemory回调方法的时候，假设我的缓存里最大的部分就是bitmap，请问就直接把bitmap从内存里抹去就可以了么？ 那如果这么做，在进程重新被加载到前台来的时候，我怎么迅速恢复这些bitmap资源？</p><p>如答疑1所述：</p><p>对于 图片，一般采用三层缓存机制，即内存、文件、网络、释放内存后从文件中读取就好</p><p>一般的图片加载库都会提供内存/文件的缓存，即使内存中的Bitmap清除掉了，下一次从文件中读取也会很快的。</p><p>至少onTrimMemory的优点，比如你的应用Cache了20MB的Bitmap没有清除，当手机内存不足的时候，如果你没有及时释放 这些内存，那么 很可能你的进程 就被系统给杀掉了，这会你的Bitmap当然也就没了。用户下次启动你的应用的时候，我曹这货又被杀了，这手机系统有毛病吧？</p><p>是吧。。。做系统的还得背这个锅！</p><p>关于onTrimMemory的使用，可以参考博客<a href="http://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory.html" target="_blank" rel="noopener">http://androidperformance.com/2015/07/20/Android-Performance-Memory-onTrimMemory.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-应用内存onLowMemory-amp-onTrimMemory优化&quot;&gt;&lt;a href=&quot;#1-应用内存onLowMemory-amp-onTrimMemory优化&quot; class=&quot;headerlink&quot; title=&quot;1.应用内存onLowMemory&amp;am
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="内存优化" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>RoboBinding(MVVM)架构介绍</title>
    <link href="http://yoursite.com/2018/01/03/RoboBinding-MVVM-%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/01/03/RoboBinding-MVVM-架构介绍/</id>
    <published>2018-01-03T15:08:14.000Z</published>
    <updated>2018-01-09T14:38:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-什么是RoboBinding"><a href="#1-什么是RoboBinding" class="headerlink" title="1. 什么是RoboBinding?"></a>1. 什么是RoboBinding?</h3><p><b>同步差异</b> - RoboBinding 是一个数据绑定器。<a href="http://martinfowler.com/eaaDev/PresentationModel.html" target="_blank" rel="noopener"> Presentation Model framework（著名的MVVM框架）</a>是安卓上的一个框架. RoboBinding帮助你在写UI代码时能方便的阅读、测试和维护。</p><h3 id="2-AndroidMVVM-Presentation-Model-框架"><a href="#2-AndroidMVVM-Presentation-Model-框架" class="headerlink" title="2.AndroidMVVM(Presentation Model)框架"></a>2.AndroidMVVM(Presentation Model)框架</h3><p>通过RoboBinding建立的一个activity由三个部分组成：layout布局，activity类，还有一个演示模型类。这里有个简单的事例<a href="https://github.com/RoboBinding/AndroidMVVM" target="_blank" rel="noopener">AndroidMVVM</a>。</p><h4 id="2-1-Layout布局"><a href="#2-1-Layout布局" class="headerlink" title="2.1. Layout布局"></a>2.1. Layout布局</h4><p>在布局文件总，我们声明一下RoboBinding的命名空间，属性和一些事件的attribute绑定。例如activity_main.xml</p><pre><code class="xml">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:tools=&quot;http://schemas.android.com/tools&quot;xmlns:bind=&quot;http://robobinding.org/android&quot;&gt;&lt;TextViewbind:text=&quot;{hello}&quot; /&gt;...&lt;Buttonandroid:text=&quot;Say Hello&quot;bind:onClick=&quot;sayHello&quot;/&gt;&lt;/LinearLayout&gt;</code></pre><h4 id="2-2-Presentation-Model-简单的Java对象"><a href="#2-2-Presentation-Model-简单的Java对象" class="headerlink" title="2.2. Presentation Model(简单的Java对象)"></a>2.2. Presentation Model(简单的Java对象)</h4><p>在演示层中，我们声明一个对应的属性和方法。代码如下org.robobinding.androidmvvm.PresentationModel.java</p><pre><code class="java">org.robobinding.annotation.PresentationModelpublic class PresentationModel implements HasPresentationModelChangeSupport {private String name;public String getHello() {return name + &quot;: hello Android MVVM(Presentation Model)!&quot;;}...public void sayHello() {firePropertyChange(&quot;hello&quot;);}}</code></pre><h4 id="2-3-Activity类"><a href="#2-3-Activity类" class="headerlink" title="2.3. Activity类"></a>2.3. Activity类</h4><p>通过RoboBinding框架将布局和演示层的model绑定在activity界面上。<br>org.robobinding.androidmvvm.MainActivity.java</p><pre><code class="java">public class MainActivity extends Activity {@Overrideprotected void onCreate(Bundle savedInstanceState) {...PresentationModel presentationModel = new PresentationModel();View rootView = Binders.inflateAndBindWithoutPreInitializingViews(this, R.layout.activity_main, presentationModel);setContentView(rootView);}}</code></pre><p>这样一个简单的AndroidMVVM事例就写完了。我们使用工具类Binders将UI空间和数据Model很简单的进行绑定。在真正使用时我们推荐使用<code>org.robobinding.binder.BinderFactoryBuilder</code>类。我们可以将BinderFactoryBuilder以单例模式保存在整个工程中，也可以使用第三方法库，例如 <a href="https://github.com/roboguice/roboguice" target="_blank" rel="noopener">RoboGuice</a> ，来帮忙管理BinderFactory对象实例，这样可以在全局共享和重复使用该实例。</p><h4 id="2-4-介绍视频"><a href="#2-4-介绍视频" class="headerlink" title="2.4. 介绍视频"></a>2.4. 介绍视频</h4><p><code>2012年2月</code> Robert Taylor 录了一个介绍RoboBinding的视频，<a href="http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding" target="_blank" rel="noopener">下载地址</a>.<br><code>2014年7月</code>Cheng Wei录了一个中文的介绍视频，<a href="https://www.youtube.com/watch?v=2sSBVaX77xA" target="_blank" rel="noopener">下载地址</a>.</p><h3 id="3-环境设置"><a href="#3-环境设置" class="headerlink" title="3. 环境设置"></a>3. 环境设置</h3><h4 id="3-1-Eclipse下安装使用"><a href="#3-1-Eclipse下安装使用" class="headerlink" title="3.1. Eclipse下安装使用"></a>3.1. Eclipse下安装使用</h4><p>安装Eclipse.</p><h5 id="3-1-1-没有AspectJ时"><a href="#3-1-1-没有AspectJ时" class="headerlink" title="3.1.1. 没有AspectJ时"></a>3.1.1. 没有AspectJ时</h5><p>将<em>robobinding-[version]-with-dependencies.jar</em> 或者<em>robobinding-[version].jar + [google guava]-[11.0.1+].jar</em> 放到工程的libs目录下，然后把他们添加到classpath上。点击顺序： <strong>project→Properties→Java Build Path→Libraries→Add JARs</strong>.在展开的列表上点击对应的jar包。<br><img src="http://robobinding.github.io/RoboBinding/images/eclipse_build_settings.png" alt="Alt text" title="Figure 1. Project build settings(An example using robobinding-[version]-with-dependencies.jar)"></p><h5 id="3-1-2-在有AspectJ时"><a href="#3-1-2-在有AspectJ时" class="headerlink" title="3.1.2. 在有AspectJ时"></a>3.1.2. 在有AspectJ时</h5><p>RoboBinding能帮我们减少一些自动绑定的代码。首先安装<a href="http://developer.android.com/tools/sdk/eclipse-adt.html" target="_blank" rel="noopener">Android Development Tools</a> 插件。然后右击项目→Configure→Convert to AspectJ Project. 这样就可以将AspectJ特性加入到项目当中。<br>按同样的方法将<code> robobinding-[version]-with-aop-and-dependencies.jar </code>或者<code> the robobinding-[version]-with-aop.jar + [google guava]-[11.0.1+].jar</code>加入的libs目录下，然后添加的项目的classpath中。<br>最后确保RoboBinding的jar是加入到Aspect路径中，具体方法如下：<br><img src="http://robobinding.github.io/RoboBinding/images/eclipse_aspectj_settings.png" alt="Figure 2. AspectJ settings(An example using robobinding-[version]-with-aop-and-dependencies.jar)" title="Figure 2. AspectJ settings(An example using robobinding-[version]-with-aop-and-dependencies.jar)"></p><h5 id="3-1-3-Annotaton-Processing-设置"><a href="#3-1-3-Annotaton-Processing-设置" class="headerlink" title="3.1.3. Annotaton Processing 设置"></a>3.1.3. Annotaton Processing 设置</h5><p>下载RoboBinding<code>codegen-[version]-with-dependencies.jar</code>的jar包。按如下方式添加到工程，注意项目不要依赖这个jar。<br><img src="http://robobinding.github.io/RoboBinding/images/eclipse_annotation_processing_settings.png" alt="Figure 3. Annotaton processing settings"></p><h4 id="3-2-Android-Studio安装方法"><a href="#3-2-Android-Studio安装方法" class="headerlink" title="3.2. Android Studio安装方法"></a>3.2. Android Studio安装方法</h4><h5 id="3-2-1-没有AspectJ时"><a href="#3-2-1-没有AspectJ时" class="headerlink" title="3.2.1. 没有AspectJ时"></a>3.2.1. 没有AspectJ时</h5><p>将robobinding依赖添加到gradle.build中。</p><pre><code class="xml">dependencies {...compile&quot;org.robobinding:robobinding:${robobindingVersion}&quot;//alternatively we can use with-dependencies jar(RoboBinding provide a minimal Proguarded with-dependencies jar.).compile(&quot;org.robobinding:robobinding:${robobindingVersion}:with-dependencies&quot;) {exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39;}}</code></pre><p><a href="https://github.com/RoboBinding" target="_blank" rel="noopener">RoboBinding</a>是完全免费的，可以随意引用,例如：AndroidMVVM, RoboBinding-album-sample 和 RoboBinding-gallery.</p><h5 id="3-2-2-有AspectJ时"><a href="#3-2-2-有AspectJ时" class="headerlink" title="3.2.2. 有AspectJ时"></a>3.2.2. 有AspectJ时</h5><p>在gradle.build中应用RoboBinding的Android aspcetj插件。</p><pre><code class="xml">buildscript {repositories {...maven() {name &#39;RoboBinding AspectJPlugin Maven Repository&#39;url &quot;https://github.com/RoboBinding/RoboBinding-aspectj-plugin/raw/master/mavenRepo&quot;}}dependencies {...classpath &#39;org.robobinding:aspectj-plugin:0.8.+&#39;}}...apply plugin: &#39;org.robobinding.android-aspectj&#39;</code></pre><p>添加RoboBinding 依赖到 gradle.build中</p><pre><code class="xml">dependencies {...compile &quot;org.robobinding:robobinding:$robobindingVersion&quot;aspectPath &quot;org.robobinding:robobinding:$robobindingVersion&quot;//alternatively we can use with-aop-and-dependencies jar(RoboBinding provides a minimal Proguarded with-aop-and-dependencies jar.).compile (&quot;org.robobinding:robobinding:$robobindingVersion:with-aop-and-dependencies&quot;) {exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39;}aspectPath (&quot;org.robobinding:robobinding:$robobindingVersion:with-aop-and-dependencies&quot;) {exclude group: &#39;com.google.guava&#39;, module: &#39;guava&#39;}}</code></pre><p><a href="https://github.com/RoboBinding" target="_blank" rel="noopener">RoboBinding</a>是完全免费的，可以随意引用,例如：AndroidMVVM, RoboBinding-album-sample 和 RoboBinding-gallery.</p><h5 id="3-2-3-Annotation-Processing-设置"><a href="#3-2-3-Annotation-Processing-设置" class="headerlink" title="3.2.3. Annotation Processing 设置"></a>3.2.3. Annotation Processing 设置</h5><p>在gradle.build中添加apt插件。</p><pre><code class="xml">buildscript {repositories {...}dependencies {...classpath &#39;com.neenbedankt.gradle.plugins:android-apt:1.+&#39;}}...apply plugin: &#39;com.neenbedankt.android-apt&#39;</code></pre><h4 id="3-3-ProGuard设置"><a href="#3-3-ProGuard设置" class="headerlink" title="3.3. ProGuard设置"></a>3.3. ProGuard设置</h4><p>在proguard中需要保存PresentationModel和生成的构造方法，我们也需要保存所以的注解。在proguard配置中进行如下设置：</p><pre><code class="xml">-keepattributes *Annotation*,Signature-keep,allowobfuscation @interface org.robobinding.annotation.PresentationModel-keep @org.robobinding.annotation.PresentationModel class * {public *** *(...);}-keep class * implements org.robobinding.itempresentationmodel.ItemPresentationModel{public *** *(...);}-keep class * extends org.robobinding.presentationmodel.AbstractPresentationModelObject{public &lt;init&gt;(...);}-keep class * extends org.robobinding.presentationmodel.AbstractItemPresentationModelObject{public &lt;init&gt;(...);}</code></pre><p>添加如下几行以便保持view监听的构造函数。</p><pre><code class="xml">-keepclassmembers class * implements org.robobinding.viewattribute.ViewListeners {public &lt;init&gt;(...);}</code></pre><p>添加如下几行来抑制Google的javax.annotation.XX 引用警告。</p><pre><code class="xml">-dontwarn javax.annotation.**</code></pre><p>在如下链接中有相关样例 <a href="https://github.com/RoboBinding/" target="_blank" rel="noopener">RoboBinding organization</a>.</p><h3 id="4-概念和特性"><a href="#4-概念和特性" class="headerlink" title="4. 概念和特性"></a>4. 概念和特性</h3><p><img src="http://robobinding.github.io/RoboBinding/images/robobinding_based_app.png" alt="Figure 4. A RoboBinding-based Android application" title="Figure 4. A RoboBinding-based Android application"><br>一个安卓应用中包含若干个activity界面和其他一些元素。在以RoboBinding架构编写的安卓应用中，一个activity包含一个activity类，一个layout布局和一个PresentationModel的普通类（而在普通安卓应用中，一个activity仅仅包含activity类和layout布局文件）。原先都在Activity类中编写展示逻辑的现在都提取到一个独立PresentationModel的简单类中。布局中视图控件的展示数据都绑定在PresentationModel的属性上，视图控件的各个事件都绑定在PresentationModel的方法上。RoboBinding可以帮助我们减少或者删除在Activity类中的UI相关代码，通过简单的在layout布局进行绑定。理想的PresentationModel仅仅包含UI展示逻辑，不包含UI代码或者UI连接代码，并且能够被单独的、简单的测试。<br>这部分样例代码可以通过如下链接查看<a href="https://github.com/RoboBinding/RoboBinding-gallery/" target="_blank" rel="noopener">Robobinding Gallery</a>.</p><h4 id="4-1-单向属性绑定"><a href="#4-1-单向属性绑定" class="headerlink" title="4.1. 单向属性绑定"></a>4.1. 单向属性绑定</h4><p>当我们将一根属性绑定到一个presentation模型时，任何对该属性的更改都会直接传给相应的View。<br>activity_view.xml</p><pre><code class="xml">&lt;TextViewbind:visibility=&quot;{integerVisibility}&quot;/&gt;</code></pre><p>ViewPresentationModel.java</p><pre><code class="java">public int getIntegerVisibility() {return integerVisibilityRotation.value();}</code></pre><p>robobinding遵循JavaBeans规范也提供getters和setters方法。在单方向绑定中，仅仅需要提供getters方法，即view的任何改变不需要更新给对应的presentation模型。更多关于属性绑定的内容可以参考<em><b>API和属性绑定文档</b></em></p><h4 id="4-2-双向属性绑定"><a href="#4-2-双向属性绑定" class="headerlink" title="4.2. 双向属性绑定"></a>4.2. 双向属性绑定</h4><p>双方向属性绑定顾名思义就是对presentation model的任何改变会反映到对应的view上，同时对view的任何改变也会更改对应的presentation Model。<br>EditText控件中的text属性是支持双向绑定的。考虑这种情况，无论何时用户更改了EditText的text内容，对应的presentation Model都会相应的进行更改。<br>双向属性绑定仅仅需要在大括号外加一个美元$符，例如：<br>activity_edittext.xml</p><pre><code class="xml">&lt;EditTextbind:text=&quot;${text}&quot;/&gt;</code></pre><p>为了支持双向绑定，需要在对应的presentation model中添加setter方法：<br>org.robobinding.gallery.presentationmodel.EditTextPresentationModel.java</p><pre><code class="java">PresentationModelpublic class EditTextPresentationModel {private String text;public String getText() {return text;}public void setText(String text) {this.text = text;}}</code></pre><h4 id="4-3-事件绑定"><a href="#4-3-事件绑定" class="headerlink" title="4.3. 事件绑定"></a>4.3. 事件绑定</h4><p>将view的事件绑定到presentation model的方法上，可以通过<code>bind:onClick=”showDemo”</code>来实现。<br>activity_gallery.xml</p><pre><code class="xml">&lt;Buttonbind:onClick=&quot;showDemo&quot;/&gt;</code></pre><p>org.robobinding.gallery.presentationmodel.GalleryPresentationModel.java</p><pre><code class="java">PresentationModelpublic class GalleryPresentationModel{...public void showDemo(){...}}</code></pre><p>当点击事件被触发时，presentation Model绑定的方法将被执行。我们能选择性的支持一个事件的参数，在上面例子中对应的参数是<code>org.robobinding.widget.view.ClickEvent</code><br>更多关于UI事件绑定可以参考<em><b>API和属性绑定文档</b></em></p><h4 id="4-4-AdapterViews的绑定"><a href="#4-4-AdapterViews的绑定" class="headerlink" title="4.4. AdapterViews的绑定"></a>4.4. AdapterViews的绑定</h4><p>当我们绑定一个AdapterViews时，RoboBinding首先要求我们指出对于presentation model基础的数据。可以是以下几个类型：an Array, List or org.robobinding.itempresentationmodel.TypedCursor.<br>在有基础数据后，RoboBinding需要知道presentation模型和子view对应的绑定关系。我们可以通过 @ItemPresentationModel注解实现。例如：<br>activity_adapter_view.xml</p><pre><code class="xml">&lt;ListViewbind:itemLayout=&quot;@android:layout/simple_list_item_1&quot;bind:itemMapping=&quot;[text1.text:{value}]&quot;bind:source=&quot;{dynamicStrings}&quot;/&gt;</code></pre><p>org.robobinding.gallery.presentationmodel.AdapterViewPresentationModel.java</p><pre><code class="java">PresentationModelpublic class AdapterViewPresentationModel{...@ItemPresentationModel(value=StringItemPresentationModel.class)public List&lt;String&gt; getDynamicStrings(){return getSelectedSource().getSample();}···</code></pre><p>提供的基础数据需要继承自ItemPresentationModel 接口。<br>org.robobinding.gallery.presentationmodel.StringItemPresentationModel.java</p><pre><code class="java">public class StringItemPresentationModel implements ItemPresentationModel&lt;String&gt;{private String value;@Overridepublic void updateData(int index, String bean){value = bean;}public String getValue(){return value;}}</code></pre><p>然后我们给每一个条目行定义一个布局。在该例中我们使用Android库给的simple_list_item_1.xml布局。通过<code>bind:itemMapping=”[text1.text:{value}]”</code>进行绑定我们将simple_list_item_1.xml中的text1.text绑定到StringItemPresentationModel.value中。<br>在@ItemPresentationModel中有一个工厂方法属性(<code>factoryMethod</code>)。当ItemPresentationModels有一些扩展的依赖时，我们能增加一个工厂方法(<code>factoryMethod</code>)到PresentationModel里面以便ItemPresentationModels能通过该方法进行创建。通过这种方式，我们能将任何依赖让到ItemPresentationModel中，通过完全自由的方式。下面是一个简单的例子。</p><pre><code class="java">@PresentationModelpublic class PresentationModelSample{...@ItemPresentationModel(value=ItemPresentationModelSample.class, factoryMethod=&quot;createItemPresentationModelSample&quot;)public List&lt;String&gt; getDynamicStrings(){return getSelectedSource().getSample();}public ItemPresentationModelSample createItemPresentationModelSample() {return ItemPresentationModelSample(dependency1, dependency2, ...);}</code></pre><h4 id="4-5-轻量级关系cursor游标映射对应的对象cursor游标"><a href="#4-5-轻量级关系cursor游标映射对应的对象cursor游标" class="headerlink" title="4.5. 轻量级关系cursor游标映射对应的对象cursor游标"></a>4.5. 轻量级关系cursor游标映射对应的对象cursor游标</h4><p>在AdapterViews绑定中提到数据类型<code>org.robobinding.itempresentationmod el.TypedCursor</code>。由于我们经常操作对象甚过操作对象数据，因而我们希望能将操作关系数据库的代码进行分离。RoboBinding增加了一个轻量级的对象cursor游标-<code>TypedCursor</code>。通过<code>org.robobinding.itempresentationmodel.RowMapper</code>类，我们能将一条数据转换为一个对象。示例如下：<br>org.robobinding.gallery.presentationmodel.TypedCursorPresentationModel.java</p><pre><code class="java">@PresentationModelpublic class TypedCursorPresentationModel {...@ItemPresentationModel(value=ProductItemPresentationModel.class)public TypedCursor&lt;Product&gt; getProducts() {return allProductsQuery.execute(db);}}</code></pre><p>org.robobinding.gallery.model.typedcursor.GetAllQuery.java</p><pre><code class="java">public class GetAllQuery&lt;T&gt;{private String tableName;private final RowMapper&lt;T&gt; rowMapper;public GetAllQuery(String tableName, RowMapper&lt;T&gt; rowMapper){...this.tableName = tableName;this.rowMapper = rowMapper;}public TypedCursor&lt;T&gt; execute(SQLiteDatabase db){Cursor cursor = db.query(tableName,null,null,null,null,null,BaseColumns._ID+&quot; ASC&quot;);return new TypedCursorAdapter&lt;T&gt;(cursor, rowMapper);}}</code></pre><p>org.robobinding.gallery.model.typedcursor.ProductRowMapper.java</p><pre><code class="java">public class ProductRowMapper implements RowMapper&lt;Product&gt; {@Overridepublic Product mapRow(Cursor cursor) {String name = cursor.getString(cursor.getColumnIndex(ProductTable.NAME));String description = cursor.getString(cursor.getColumnIndex(ProductTable.DESCRIPTION));return new Product(name, description);}}</code></pre><h4 id="4-6-菜单绑定"><a href="#4-6-菜单绑定" class="headerlink" title="4.6. 菜单绑定"></a>4.6. 菜单绑定</h4><p>将一个res/menu中的菜单资源绑定到一个Presentation Models中。看如下例子：<br>res/menu/context_menu.xml</p><pre><code class="xml">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:bind=&quot;http://robobinding.org/android&quot;xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;&lt;item android:title=&quot;Delete Product&quot;bind:onMenuItemClick=&quot;deleteProduct&quot;android:id=&quot;@+id/deleteProduct&quot;app:showAsAction=&quot;always&quot;/&gt;&lt;/menu&gt;</code></pre><p>org.robobinding.gallery.presentationmodel.ContextMenuPresentationModel.java</p><pre><code class="java">@PresentationModelpublic class ContextMenuPresentationModel {...public void deleteProduct(MenuItem menuItem) {...}}</code></pre><h4 id="4-7-Presentation-Models（演示models）"><a href="#4-7-Presentation-Models（演示models）" class="headerlink" title="4.7. Presentation Models（演示models）"></a>4.7. Presentation Models（演示models）</h4><p>我们将任何一个presentationModel添加<code>@org.robobinding.annotation.PresentationModel</code>注解。当一个presentationmodel需要<code>org.robobinding.presentationmodel.PresentationModelChangeSupport</code>支持时，presentationmodel必须继承自<code>org.robobinding.presentationmodel.HasPresentationModelChangeSupport </code>接口，以便于框架层能在内部使用<code>PresentationModelChangeSupport</code>对象。</p><p>有两种方式可以实现一个Presentationmodel，一个是有AspectJ时，一个是没有AspectJ时，</p><h5 id="4-7-1-没有-AspectJ"><a href="#4-7-1-没有-AspectJ" class="headerlink" title="4.7.1.没有 AspectJ"></a>4.7.1.没有 AspectJ</h5><ul><li>使用robobinding-[version].jar或者robobinding-[version]-with-dependencies.jar库</li><li>这种方式的好处是没有额外的依赖，可以使最终的apk尽可能的小</li><li>不好的地方在我们需要手动设置每一个firePropertyChange(“propertyName”).<br>以下有具体的样例<br><a href="https://github.com/RoboBinding/AndroidMVVM" target="_blank" rel="noopener">AndroidMVVM</a> 和 <a href="https://github.com/RoboBinding/Android-CleanArchitecture" target="_blank" rel="noopener">Android-CleanArchitecture</a> </li></ul><h5 id="4-7-2-有-AspectJ"><a href="#4-7-2-有-AspectJ" class="headerlink" title="4.7.2. 有 AspectJ"></a>4.7.2. 有 AspectJ</h5><ul><li><p>使用robobinding-[version]-with-aop.jar 或者robobinding-[version]-with-aop-and-dependencies.jar库</p></li><li><p>好处是许多firePropertyChange(“propertyName”) 可以自动生成</p></li><li><p>不好的地方是在AspectJ运行库里面包含依赖，这轻微的增加了最终apk的大小。<br>以下是具体样例<br><a href="https://github.com/RoboBinding/RoboBinding-album-sample" target="_blank" rel="noopener">Album Sample</a> 和 <a href="https://github.com/RoboBinding/RoboBinding-gallery" target="_blank" rel="noopener">Gallery</a></p></li></ul><h3 id="5-创造我们自己的view绑定"><a href="#5-创造我们自己的view绑定" class="headerlink" title="5. 创造我们自己的view绑定"></a>5. 创造我们自己的view绑定</h3><p>这一节的样例代码是： <a href="https://github.com/RoboBinding/RoboBinding-gallery/" target="_blank" rel="noopener">Robobinding Gallery</a>.</p><h4 id="5-1-单向绑定"><a href="#5-1-单向绑定" class="headerlink" title="5.1. 单向绑定"></a>5.1. 单向绑定</h4><p>在如下的例子中我们增加了View的enable属性绑定- <a href="https://github.com/RoboBinding/RoboBinding-gallery/blob/master/app/src/main/java/org/robobinding/gallery/activity/ViewBindingForView.java" target="_blank" rel="noopener">source code</a>.</p><pre><code class="java">@ViewBinding(simpleOneWayProperties = {&quot;enabled&quot;})public class ViewBindingForView extends CustomViewBinding&lt;View&gt; {}</code></pre><p>然后添加到<code> BinderFactoryBuilder</code> - <a href="https://github.com/RoboBinding/RoboBinding-gallery/blob/master/app/src/main/java/org/robobinding/gallery/activity/GalleryApp.java" target="_blank" rel="noopener">source code</a>.</p><pre><code class="java">new BinderFactoryBuilder().add(new ViewBindingForView().extend(View.class)).build();</code></pre><p>RoboBinding能够生成如下代码：</p><pre><code class="java">public class ViewBindingForView$$VB implements ViewBinding&lt;View&gt;{final ViewBindingForView customViewBinding;public ViewBindingForView$$VB(ViewBindingForView customViewBinding) {this.customViewBinding = customViewBinding;}@Overridepublic void mapBindingAttributes(BindingAttributeMappings&lt;View&gt; mappings) {mappings.mapOneWayProperty(ViewBindingForView$$VB.EnabledAttribute.class, &quot;enabled&quot;);customViewBinding.mapBindingAttributes(mappings);}public static class EnabledAttribute implements OneWayPropertyViewAttribute&lt;View, Boolean&gt;{@Overridepublic void updateView(View view, Boolean newValue) {view.setEnabled(newValue);}}}</code></pre><p>所以的绑定都是静态static的，这意味着每一性能的影响。</p><h4 id="5-2-其他类型的绑定"><a href="#5-2-其他类型的绑定" class="headerlink" title="5.2. 其他类型的绑定"></a>5.2. 其他类型的绑定</h4><p>除了单向属性绑定外，这里还有事件event绑定，多类型属性绑定和其他组属性类型的绑定。为了能实现这些绑定，我们需要扩展CustomViewBinding和手动实现对应的继承。具体例子如下：</p><pre><code class="java">@ViewBindingpublic class MyCustomViewBinding extends CustomViewBinding&lt;CustomView&gt; {@Overridepublic void mapBindingAttributes(BindingAttributeMappings&lt;CustomView&gt; mappings) {mappings.mapEvent(OnCustomEventAttribute.class, &quot;onCustomEvent&quot;);}public class OnCustomEventAttribute implements EventViewAttributeForView {...}}</code></pre><p>对于这些绑定，我们能在如下链接找到例子：- <a href="https://github.com/RoboBinding/RoboBinding/tree/develop/framework/src/main/java/org/robobinding/widget" target="_blank" rel="noopener">source code under widget package</a>.</p><h4 id="5-3-自定义控件或者第三方控件"><a href="#5-3-自定义控件或者第三方控件" class="headerlink" title="5.3. 自定义控件或者第三方控件"></a>5.3. 自定义控件或者第三方控件</h4><p>我们能对于任何自定义控件、第三方控件、Android widgets创建view绑定，以便更容易的使用它们。在RoboBinding中，这些绑定是一样的。<br><img src="http://robobinding.github.io/RoboBinding/images/custom_component.png" alt="Figure 5. custom Title Description Bar" title="Figure 5. custom Title Description Bar"></p><p>下面是一个简单的自定义控件的例子，该View有一个白色的边框。这个控件有一个标题和一个描述组成。当我们输入新的标题和描述后，然后点击应用（Apply），控件自己讲对于的更新。</p><p>这个需求可以用以下简单的代码实现：<br>activity_custom_component.xml</p><pre><code class="xml">&lt;org.robobinding.gallery.model.customcomponent.TitleDescriptionBarbind:title=&quot;{title}&quot;bind:description=&quot;{description}&quot;/&gt;</code></pre><p>这个TitleDescriptionBar控件的代码如下：(对于如何实现一个自定义控件，参考如下：<a href="http://developer.android.com/guide/topics/ui/custom-components.html" target="_blank" rel="noopener">Android Reference</a>):</p><pre><code class="java">public class TitleDescriptionBar extends LinearLayout {private TextView title;private TextView description;public TitleDescriptionBar(Context context, AttributeSet attrs) {this(context, attrs, R.layout.title_description_bar);}protected TitleDescriptionBar(Context context, AttributeSet attrs, int layoutId) {super(context, attrs);LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);inflater.inflate(layoutId, this);title = (TextView) findViewById(R.id.title);description = (TextView) findViewById(R.id.description);...}public void setTitle(CharSequence titleText) {title.setText(titleText);}public void setDescription(CharSequence descriptionText) {description.setText(descriptionText);}}</code></pre><p>对于的布局是： title_description_bar.xml:</p><pre><code class="xml">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;xmlns:bind=&quot;http://robobinding.org/android&quot;&gt;&lt;TextView android:id=&quot;@+id/title&quot;/&gt;&lt;TextView android:text=&quot;: &quot;/&gt;&lt;TextView android:id=&quot;@+id/description&quot;/&gt;</code></pre><h5 id="5-3-1-实现属性绑定"><a href="#5-3-1-实现属性绑定" class="headerlink" title="5.3.1. 实现属性绑定"></a>5.3.1. 实现属性绑定</h5><p>这个控件有两个简单的单向属性绑定- <a href="https://github.com/RoboBinding/RoboBinding-gallery/blob/master/app/src/main/java/org/robobinding/gallery/model/customcomponent/TitleDescriptionBarBinding.java" target="_blank" rel="noopener">source code</a>.</p><pre><code class="java">@ViewBinding(simpleOneWayProperties = {&quot;title&quot;, &quot;description&quot;})public class TitleDescriptionBarBinding extends CustomViewBinding&lt;TitleDescriptionBar&gt; {}</code></pre><h5 id="5-3-2-注册ViewBindings"><a href="#5-3-2-注册ViewBindings" class="headerlink" title="5.3.2. 注册ViewBindings"></a>5.3.2. 注册ViewBindings</h5><p>ViewBindings能够通过<code>org.robobinding.binder.BinderFactoryBuilder </code>进行绑定- <a href="https://github.com/RoboBinding/RoboBinding-gallery/blob/master/app/src/main/java/org/robobinding/gallery/activity/CustomComponentActivity.java" target="_blank" rel="noopener">source code</a>.</p><pre><code class="java">BinderFactory binderFactory = new BinderFactoryBuilder().add(new TitleDescriptionBarBinding().forView(TitleDescriptionBar.class)).build();</code></pre><p>这样就行了。我们能用同样的方法绑定第三方控件或者Android Widgets。</p><h4 id="5-4-替换已有的view绑定"><a href="#5-4-替换已有的view绑定" class="headerlink" title="5.4. 替换已有的view绑定"></a>5.4. 替换已有的view绑定</h4><p>当一个已经存在的view绑定不能满足我们需求时，我们通过注册去替代默认的继承implementations.</p><pre><code class="java">BinderFactory binderFactory = new BinderFactoryBuilder().add(new MyViewBindingForView().forView(View.class)).build();@ViewBindingstatic class MyViewBindingForView extends CustomViewBinding&lt;View&gt; {...}</code></pre><h5 id="5-4-1-扩展一个已经存在的view绑定"><a href="#5-4-1-扩展一个已经存在的view绑定" class="headerlink" title="5.4.1. 扩展一个已经存在的view绑定"></a>5.4.1. 扩展一个已经存在的view绑定</h5><p>扩展一个已经存在的TextViewBinding，并且增加一个属性绑定。</p><pre><code class="java">BinderFactory binderFactory = new BinderFactoryBuilder().add(new MyTextViewBinding().extend(TextView.class)).build();@ViewBinding(simpleOneWayProperties={&quot;typeface&quot;})static class MyTextViewBinding extends CustomViewBinding&lt;TextView&gt; {...}</code></pre><h3 id="6-Album例子的具体步骤"><a href="#6-Album例子的具体步骤" class="headerlink" title="6. Album例子的具体步骤"></a>6. Album例子的具体步骤</h3><p>Album工程是一个Martin Fowler的翻译版本<a href="http://martinfowler.com/eaaDev/PresentationModel.html" target="_blank" rel="noopener">original one</a>. 源代码如下： <a href="https://github.com/RoboBinding/RoboBinding-album-sample" target="_blank" rel="noopener">这里</a>.<br><img src="http://robobinding.github.io/RoboBinding/images/album_sample_prototype.png" alt="album_sample_prototype.png" title="Figure 6. Album Sample project prototype"><br>在接下来的几节，包名是已org.robobinding.albumsample开头的</p><p>上面是这个项目的原型。这个项目遵循RoboBinding工程的架构。一个Activity由一个Activity类，布局.xml和一个原型Model组成。在项目中你能看到如下几个包：org.robobinding.albumsample.activity,该包包含所有的Activity界面类；org.robobinding.albumsample.presentationmodel,该包包含所有的原型类；org.robobinding.albumsample.model,该包包含所有的Album实现类；org.robobinding.albumsample.store,该包包含所有的AlbumStore实现类。在原型中有5个表格，分别代表如下：<br>[Home Activity]表格由.activity.HomeActivity,home_activity.xml和.presentationmodel.HomePresentationModel组成。<br>[View Albums Activity]由.activity.ViewAlbumsActivity, view_albums_activity.xml和.presentationmodel.ViewAlbumsPresentationModel组成; 每一个album条目由.presentationmodel.AlbumItemPresentationModel 和album_row.xml来构成; 当album列表是空时，用albums_empty_view.xml布局来代替。<br>[Create Album Activity]和[Edit Album Activity]两者都使用.activity.CreateEditAlbumActivity, create_edit_album_activity.xml 和.presentationmodel.CreateEditAlbumPresentationModel来构成。<br>[View Album Activity].activity.ViewAlbumActivity, view_album_activity.xml 和.presentationmodel.ViewAlbumPresentationModel组成; 它的album 删除对话框.activity.DeleteAlbumDialog, delete_album_dialog.xml和 .presentationmodel.DeleteAlbumDialogPresentationModel构成。<br>把[View Albums Activity]作为一个简单的例子来阐述如何使用RoboBinding。ViewAlbumsActivity是关联到view_albums_activity.xml和ViewAlbumsPresentationModel上面的。view_albums_activity.xml包含3个子View，一个TextView，一个ListView和一个Button。这个TextView不包含任何绑定信息。在ListView中<code>bind:source=”{albums}”</code>绑定到 ViewAlbumsPresentationModel.albums dataset property. <code>bind:onItemClick=”viewAlbum”</code> 绑定到ViewAlbumsPresentationModel.viewAlbum(ItemClickEvent) 方法上. 当album的一个条目被点击时，这个方法将被调用。当数据为空时会使用albums_empte_view.xml布局<code>bind:emptyViewLayout=”@layout/albums_empty_view”</code> 。<code>bind:itemLayout=”@layout/album_row”</code>对应每一行布局，在该布局中有两个TextView，绑定信息如下：<code>bind:text=”{title}”</code> and <code>bind:text=”{artist}”</code> 绑定到AlbumItemPresentationModel.title/artist respectively.在view_albums_activity.xml布局中的子布局是一个 Button. 它的点击事件<code>bind:onClick=”createAlbum”</code> 绑定到ViewAlbumsPresentationModel.createAlbum()方法上。</p><h3 id="7-Gallery-Demos的组成"><a href="#7-Gallery-Demos的组成" class="headerlink" title="7. Gallery Demos的组成"></a>7. Gallery Demos的组成</h3><p>The entry classes mentioned below are from the package org.robobinding.gallery.activity of Robobinding Gallery project.</p><ul><li><p>Binding attributes demo for View. The entry class is ViewActivity.</p></li><li><p>Binding attributes demo for EditText. The entry class is EditTextActivity.</p></li><li><p>Binding attributes demo for AdapterView. The entry class is AdapterViewActivity.</p></li><li><p>Binding attributes demo for ListView. The entry class is ListViewActivity.</p></li><li><p>Binding attributes demo for RecyclerView. The entry class is RecyclerViewActivity.</p></li><li><p>Binding attributes demo for Custom Components. The entry class is CustomComponentActivity.</p></li><li><p>Demo for Object Cursor. The entry class is TypedCursorActivity.</p></li><li><p>Demo for Fragment &amp; ViewPager Binding. The entry class is ListFragmentDemoActivity.</p></li><li><p>Demo for Options Menu Binding. The entry class is OptionsMenuActivity.</p></li><li><p>Demo for Context Menu Binding. The entry class is ContextMenuDemoActivity.</p></li><li><p>Demo for Contextual Action Mode Binding. The entry class is ContextualActionModeActivity.</p></li></ul><h3 id="8-项目结构和项目实践"><a href="#8-项目结构和项目实践" class="headerlink" title="8. 项目结构和项目实践"></a>8. 项目结构和项目实践</h3><p>Involved from MVC pattern, the major motive of Presentation Model(MVVM) pattern is to further decouple UI state and logic into a pure POJO Presentation Model, which can be easily Unit tested. Meanwhile, the dependency of View→Presentation Model→Model becomes unidirectional. When applying the pattern, these are the basic rules we will follow. <a href="https://github.com/RoboBinding/RoboBinding" target="_blank" rel="noopener">Album Sample</a> is an example that follows the best practices. Recommend to read Martin Fowler’s original article on <a href="http://martinfowler.com/eaaDev/PresentationModel.html" target="_blank" rel="noopener">Presentation Model</a>.</p><h4 id="8-1-整个项目框架"><a href="#8-1-整个项目框架" class="headerlink" title="8.1. 整个项目框架"></a>8.1. 整个项目框架</h4><p><img src="http://robobinding.github.io/RoboBinding/images/project_structure.png" alt="project_structure.png" title="Figure 7. Project structure"><br>In Android app, the view layer consists of activities(fragments) and their layouts and the model layer(or business model layer) consists of various services, persistence layer, networking services, business services and so on. The diagram indicates the dependency between different layers. The view layer for example never directly accesses the business model.</p><h4 id="8-2-常见问题解决方案"><a href="#8-2-常见问题解决方案" class="headerlink" title="8.2. 常见问题解决方案"></a>8.2. 常见问题解决方案</h4><ul><li><p>When we are not using a third-party dependency injection lib, we may instantiate business model objects in Activities and then pass them into presentation models, but the view layer(or any activities) will not directly access any business model objects.</p></li><li><p>Sometimes presentation models may need to call some functionalities in the view layer. We can add view interfaces in between to decouple the relationship. Presentation models depends on view interfaces instead of the view layer, which keeps the testability of presentation models. If you prefer, you can shift these view interfaces into presentation model layer or presentation model package, so that the dependency remains unidirectional. Let us have a look a simple example below:<br>``` java<br>interface MainView {<br>void doSomeViewLogic();<br>}</p></li></ul><p>class MainActivity extends Activity implements MainView {<br>…<br>@Override<br>protected void onCreate(Bundle savedInstanceState) {<br>…<br>PresentationModel presentationModel = new PresentationModel(this);<br>…<br>}</p><p>public void doSomeViewLogic() {<br>…<br>}<br>}</p><p>class PresentationModel {<br>private MainView mainView;</p><p>public PresentationModel(MainView mainView) {<br>this.mainView = mainView;<br>}</p><p>public void someEvent() {<br>mainView.doSomeViewLogic();<br>}<br>}<br>```</p><h3 id="9-其他资源"><a href="#9-其他资源" class="headerlink" title="9. 其他资源"></a>9. 其他资源</h3><p><strong>Jan 2012</strong> Robert Taylor has written a couple of introductory articles <a href="http://roberttaylor426.blogspot.com/2011/11/hello-robobinding-part-1.html" target="_blank" rel="noopener">here</a> and <a href="http://roberttaylor426.blogspot.com/2012/01/hello-robobinding-part-2.html" target="_blank" rel="noopener">here</a>.</p><p><strong>Feb 2012</strong> A video of a talk on RoboBinding at SkillsMatter, London can be found<a href="http://skillsmatter.com/podcast/os-mobile-server/core-dev-talk-robobinding" target="_blank" rel="noopener"> here</a>.</p><p><strong>Jul 2014</strong> A video of a talk on RoboBinding in Chinese by Cheng Wei can be found <a href="https://www.youtube.com/watch?v=2sSBVaX77xA" target="_blank" rel="noopener">here</a>.</p><p>Sep 2014 A talk at <a href="http://adilmughal.github.io/YOW2014-Android-MVVM/" target="_blank" rel="noopener">YOW 2014 Android MVVM</a> by Adil Mughal on <em>Write cleaner, maintainable and testable code in Android using MVVM</em>.</p><p><a href="https://github.com/RoboBinding/AndroidMVVM" target="_blank" rel="noopener">AndroidMVVM</a> A minimal android app with MVVM.</p><p><a href="https://github.com/RoboBinding/RoboBinding-album-sample" target="_blank" rel="noopener">RoboBinding album sample</a> is an Android translation of Martin Fowler’s original sample code on <a href="http://martinfowler.com/eaaDev/PresentationModel.html" target="_blank" rel="noopener">Presentation Model</a> pattern.</p><p><a href="https://github.com/RoboBinding/RoboBinding-gallery" target="_blank" rel="noopener">RoboBinding Gallery</a> demonstrates RoboBinding features.</p><hr><p>Version 0.8.10<br>Last updated 2015-10-24 16:50:07</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-什么是RoboBinding&quot;&gt;&lt;a href=&quot;#1-什么是RoboBinding&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是RoboBinding?&quot;&gt;&lt;/a&gt;1. 什么是RoboBinding?&lt;/h3&gt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="RoboBinding,MVC,MVP" scheme="http://yoursite.com/tags/RoboBinding-MVC-MVP/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask研究</title>
    <link href="http://yoursite.com/2018/01/03/AsyncTask%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/01/03/AsyncTask研究/</id>
    <published>2018-01-03T14:32:22.000Z</published>
    <updated>2018-01-18T13:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-AsyncTask概述"><a href="#1-AsyncTask概述" class="headerlink" title="1. AsyncTask概述"></a>1. AsyncTask概述</h3><p>在Android平台上，要执行异步工作时，我们常常会用到AsyncTask。这个类可以算是历史悠久，早在Android 1.5版时，它就存在了。</p><p>AsyncTask的使用方法比较简单，无非是创建一个AsyncTask派生类对象，重写其doInBackground()函数，然后在合适世纪调用这个对象的execute()或executeOnExecutor()函数即可。</p><pre><code class="java">private static class MyTask extends AsyncTask&lt;Void, Void, Void&gt; ｛    // . . . . . .    @Override    public Void doInBackground(Void... param) {        //. . . . . .        return null;    }｝private class TestClickListener implements View.OnClickListener {    public void onClick(View v) {        switch (v.getId()) {        case R.id.scan_btn:            testTask();            break;        . . . . . .    }         private void testTask() {        for (int i = 0; i &lt; 5; i++) {            MyTask t = new MyTask(i+100);            t.execute();    // 调用execute()即可        }    }</code></pre><p>一般情况下，我们会像上面代码中这样调用AsyncTask的execute()函数，这样，投入执行的task会串行执行。不过，有时候我们也希望task们可以并行执行，此时只需把execute()换成executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR)即可。</p><h3 id="2-AsyncTask的内部机制"><a href="#2-AsyncTask的内部机制" class="headerlink" title="2. AsyncTask的内部机制"></a>2. AsyncTask的内部机制</h3><p>AsyncTask本身是个抽象的泛型基类，正如前面所说，在实际使用时，我们必须定义它的派生类，并在实现AsyncTask派生类时，重写其doInBackground()成员函数。</p><p>AysncTask的声明如下：<br>【frameworks/base/core/java/android/os/AsyncTask.java】</p><p>public abstract class AsyncTask<params, progress,="" result=""><br>作为一种异步执行的任务，AsyncTask是依靠内部的线程池来完成任务调度的。大体上说，AsyncTask内部搞了两个静态的执行器，分别表示成AsyncTask.THREAD_POOL_EXECUTOR 和 AsyncTask.SERIAL_EXECUTOR，前者是可并行执行的执行器（线程池），后者是串行执行的执行器（线程池）。</params,></p><p>AsyncTask的构造函数如下：</p><pre><code class="java">/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */public AsyncTask() {    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {        public Result call() throws Exception {            mTaskInvoked.set(true);            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);            //noinspection unchecked            Result result = doInBackground(mParams);            Binder.flushPendingCommands();            return postResult(result);        }    };    mFuture = new FutureTask&lt;Result&gt;(mWorker) {        @Override        protected void done() {            try {                postResultIfNotInvoked(get());            } catch (InterruptedException e) {                android.util.Log.w(LOG_TAG, e);            } catch (ExecutionException e) {                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause());            } catch (CancellationException e) {                postResultIfNotInvoked(null);            }        }    };}</code></pre><p>构造函数的注释中说的很明确，必须在UI线程里构造AsyncTask对象。而且构造函数里为两个重要的成员：mWorker和mFuture赋了值，这个我们后文再细说。</p><h4 id="2-1-AsyncTask的execute"><a href="#2-1-AsyncTask的execute" class="headerlink" title="2.1 AsyncTask的execute()"></a>2.1 AsyncTask的execute()</h4><p>我们先回过头看前文曾经提到的AsyncTask的execute()函数，其代码如下：<br>【frameworks/base/core/java/android/os/AsyncTask.java】</p><pre><code class="java">MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {    return executeOnExecutor(sDefaultExecutor, params);}</code></pre><p>因为params参数是可变长参数，所以execute()可以接受0到n个参数。注意，execute()和executeOnExecutor()都必须在UI线程里调用。</p><p>execute()只是简单地调用executeOnExecutor()而已，它传递的静态变量sDefaultExecutor引用的就是串行执行器AsyncTask.SERIAL_EXECUTOR：<br><code><br>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;<br></code><br>executeOnExecutor()的代码截选如下：</p><pre><code class="java">MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,        Params... params) {    . . . . . .    . . . . . .    mStatus = Status.RUNNING;    onPreExecute();    mWorker.mParams = params;    exec.execute(mFuture);  // 注意，mFuture本身实现了Runnable接口    return this;}</code></pre><p>也就是说，最终还是在调用执行器的execute()函数，只不过会把一个mFuture委托给执行器去回调。</p><p>默认情况下使用的串行执行器类是SerialExecutor，它的代码如下：</p><pre><code class="java">private static class SerialExecutor implements Executor {    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();    Runnable mActive;    public synchronized void execute(final Runnable r) { // 参数r一般就是mFuture引用的对象        mTasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (mActive == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((mActive = mTasks.poll()) != null) {            THREAD_POOL_EXECUTOR.execute(mActive);        }    }}</code></pre><p>从代码里可以看到，所谓的串行执行器内部，其实也是在复用THREAD_POOL_EXECUTOR，只不过利用对mActive的判断，把调用的流程改成串行的了。</p><p>SerialExecutor内部使用的是java.util.ArrayDeque队列，它的poll()函数可以检索并移除此队列的头部，如果返回null，则表示此队列已经取空了。每次摘取一个列头，并记录在mActive变量里，然后交给THREAD_POOL_EXECUTOR来处理。</p><p>ThreadPoolExecutor是java提供的线程池实现。总之，线程池会在后续的某个时刻，回调上面插入的Runnable对象的run()。在executeOnExecutor()函数里，我们已经看到向执行器添加了AsynctTask的mFuture成员，而mFuture本身实现了Runnable接口，以后回调就是回调mFuture的run()函数。</p><h4 id="2-2-AsyncTask和线程池的协作"><a href="#2-2-AsyncTask和线程池的协作" class="headerlink" title="2.2 AsyncTask和线程池的协作"></a>2.2 AsyncTask和线程池的协作</h4><h5 id="2-2-1-AsyncTask里的mFuture"><a href="#2-2-1-AsyncTask里的mFuture" class="headerlink" title="2.2.1 AsyncTask里的mFuture"></a>2.2.1 AsyncTask里的mFuture</h5><p>AsyncTask的mFuture非常重要，它的定义如下：</p><p>private final FutureTask<result> mFuture;<br>类型为FutureTask，其实现可以参考JDK里的代码：<br>【java/util/concurrent/FutureTask.java】<br><code><br>public class FutureTask<v> implements RunnableFuture<v><br></v></v></code><br>【java/util/concurrent/FunnableFuture.java】<br><code><br>public interface RunnableFuture<v> extends Runnable, Future<v><br></v></v></code><br>在前文列出AsyncTask构造函数时，我们已经看到mFuture的创建代码了，注意，在创建FutureTask对象时，传入了mWorker，它会被记入mFuture内部（如果分析JDK的代码，可以看到大体上就是记入mFuture.sync.callable了）。后续在被线程池执行时，这个mWorker才是最核心的对象。</result></p><p>欲了解详情，我们先得看看AsyncTask机制运用的线程池。在AsyncTask类里这样定义线程池成员的：</p><pre><code class="java">private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue =        new LinkedBlockingQueue&lt;Runnable&gt;(128);public static final Executor THREAD_POOL_EXECUTOR;static {    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,            sPoolWorkQueue, sThreadFactory);    threadPoolExecutor.allowCoreThreadTimeOut(true);    THREAD_POOL_EXECUTOR = threadPoolExecutor;}public static final Executor SERIAL_EXECUTOR = new SerialExecutor();</code></pre><p>注意，线程池都是记在静态变量里的，它的生命期和进程的生命期基本一致。</p><p>细心的同学还记得，前文在定义AsyncTask派生类时，我们写的是private static class，大家不要忘记加static，否则就是写了一个普通内嵌类，而普通内嵌类对象内部会隐式地引用其外部类，这样当我们的task对象记入线程池后，就有可能导致task的外部类（很有可能是个Activity或Service）对象在较长时间内都不能被垃圾回收机制回收，从而导致内存泄漏。</p><p>本文的重点并不想太深入线程池的内部机理，我们只做必要的探讨即可。我们大体上只需知道线程池里的线程会执行FutureTask的run()函数即可。而FutureTask的run()代码如下：<br>【java/util/concurrent/FutureTask.java】</p><pre><code class="java">public void run() {    sync.innerRun();}</code></pre><p>而FutureTask.Sync的innerRun()代码如下：</p><pre><code class="java">void innerRun() {    if (!compareAndSetState(READY, RUNNING))        return;    runner = Thread.currentThread();    if (getState() == RUNNING) { // recheck after setting thread        V result;        try {            result = callable.call();  // 这一步间接调用到AsyncTask的doInBackground()。        } catch (Throwable ex) {            setException(ex);            return;        }        set(result);  // 如果不出异常的话，会对call返回的结果执行set()操作。    } else {        releaseShared(0); // cancel    }}</code></pre><p>其中会调用callable.call()，这一步就会间接调用到AsyncTask的doInBackground()。再接下来，如果不出异常的话，会对call()返回的结果执行set()操作。大家还记得前文WorkerRunnable实现的call()函数吗？它最后返回语句为：return postResult(result);现在设置的就是这个postResult对象。</p><p>FutureTask的set()函数的代码如下：<br>【java/util/concurrent/FutureTask.java】</p><pre><code class="java">protected void set(V v) {    sync.innerSet(v);}    void innerSet(V v) {        for (;;) {            int s = getState();            if (s == RAN)                return;            if (s == CANCELLED) {                releaseShared(0);                return;            }            if (compareAndSetState(s, RAN)) {                result = v;                releaseShared(0);                done();                return;            }        }    }</code></pre><p>结果记录进Sync类的result成员，然后回调FutureTask的done()函数，这也就回调到前文我们看到的AysncTask的mFuture的done()函数了。我们再列一下mFuture的代码：<br>【frameworks/base/core/java/android/os/AsyncTask.java】</p><pre><code class="java">    mFuture = new FutureTask&lt;Result&gt;(mWorker) {        @Override        protected void done() {            try {                postResultIfNotInvoked(get());            } catch (InterruptedException e) {                android.util.Log.w(LOG_TAG, e);            } catch (ExecutionException e) {                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause());            } catch (CancellationException e) {                postResultIfNotInvoked(null);            }        }    };</code></pre><p>done()里面做的无法一些善后处理。</p><pre><code class="java">private void postResultIfNotInvoked(Result result) {    final boolean wasTaskInvoked = mTaskInvoked.get();    if (!wasTaskInvoked) {        postResult(result);    }}</code></pre><h5 id="2-2-2-AsyncTask里的mWorker"><a href="#2-2-2-AsyncTask里的mWorker" class="headerlink" title="2.2.2 AsyncTask里的mWorker"></a>2.2.2 AsyncTask里的mWorker</h5><p>AsyncTask的另一个重要成员是mWorker，</p><p>private final WorkerRunnable<params, result=""> mWorker;<br>除了在executeOnExecutor()里会为mWorker的mParams成员赋值外，AsyncTask一般不会直接操作mWorker。mWorker会间接记录进mFuture。当mFuture被回调时，系统会间接回调mWorker的call()成员函数，而这个call()函数是整个AsyncTask的核心行为。</params,></p><p>现在我们可以画一张AsyncTask的示意图：</p><p>其实，当一个AsyncTask被安插进线程池时，线程池主要关心的是其mFuture成员引用的FutureTask。所以我们可以画出如下示意图：</p><p>当回调发生时，最终间接执行到mWorker成员的call()函数，在介绍AsyncTask的构造函数时，我们已经见过该函数的代码，现在再列一遍：</p><pre><code class="java">    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {        public Result call() throws Exception {            mTaskInvoked.set(true);            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); // 设为后台线程            //noinspection unchecked            Result result = doInBackground(mParams);            Binder.flushPendingCommands();   // ???            return postResult(result);        }    };</code></pre><p>看到了吗，当线程池里的某个线程回调到上面的call()函数时，会先把线程优先级设置为“后台线程”，然后会调用doInBackground()函数。大家还记得吧，前文说过我们在实现一个AsyncTask派生类时，主要重写的就是这个doInBackground()函数，现在终于派上用场了。</p><p>上面代码中还调用了一个不常见的函数：Binder.flushPendingCommands()。这个函数对应的注释是这样说的：（本函数）会将所有在当前线程里挂起的“Binder命令”扔回内核驱动。一般可以在执行那些有可能阻塞较长时间的操作之前调用一下该函数，这样可以确保挂起的对象引用被及时释放，避免“持有执行对象的进程”占据比“实际需要持有的时间”更长的时间。所以，我判断此处的调用多少有点儿问题，也许更合理的调用地方是在doInBackground()一句之前。</p><h5 id="2-2-3-UI线程和AsyncTask工作线程之间的协作"><a href="#2-2-3-UI线程和AsyncTask工作线程之间的协作" class="headerlink" title="2.2.3 UI线程和AsyncTask工作线程之间的协作"></a>2.2.3 UI线程和AsyncTask工作线程之间的协作</h5><p>回调的call()函数最终还会通过postResult()，发回一条MESSAGE_POST_RESULT消息。postResult()的代码如下：</p><pre><code class="java">private Result postResult(Result result) {    @SuppressWarnings(&quot;unchecked&quot;)    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,            new AsyncTaskResult&lt;Result&gt;(this, result));    message.sendToTarget();    return result;}</code></pre><p>此处的getHandler()得到的实际是一个可向UI线程发送消息的handler（即AsyncTask的静态成员sHandler）。getHandler()的代码如下：</p><pre><code class="java">private static Handler getHandler() {    synchronized (AsyncTask.class) {        if (sHandler == null) {            sHandler = new InternalHandler();        }        return sHandler;    }}</code></pre><p>这里搞了个类似单例的sHandler，类型为InternalHandler：</p><pre><code class="java">private static class InternalHandler extends Handler {    public InternalHandler() {        super(Looper.getMainLooper());    // 用于向UI线程发送消息！    }    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})    @Override    public void handleMessage(Message msg) {        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;        switch (msg.what) {            case MESSAGE_POST_RESULT:                // There is only one result                result.mTask.finish(result.mData[0]);                break;            case MESSAGE_POST_PROGRESS:                result.mTask.onProgressUpdate(result.mData);                break;        }    }}</code></pre><p>从InternalHandler的构造函数可以看到，postResult()最终就是向UI线程发回MESSAGE_POST_RESULT消息的。</p><p>当UI线程最终处理MESSAGE_POST_RESUTL消息时，会调用AsyncTask的finish()。</p><pre><code class="java">private void finish(Result result) {    if (isCancelled()) {        onCancelled(result);    } else {        onPostExecute(result);    }    mStatus = Status.FINISHED;}</code></pre><p>另一方面，用户在编写doInBackground()时，还可以在合适时机调用publishProgress()，向UI线程发出MESSAGE_POST_PROGRESS消息。publishProgress()的代码如下：</p><pre><code class="java">@WorkerThreadprotected final void publishProgress(Progress... values) {    if (!isCancelled()) {        getHandler().obtainMessage(MESSAGE_POST_PROGRESS,                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();    }}</code></pre><p>这个消息同样被刚刚说到的InternalHandler处理，处理时会回调AsyncTask的onProgressUpdate()。</p><p>关于UI线程和执行AsyncTask的线程之间的交互，我们可以画一张示意图如下：</p><p>这张图反映了一个AsyncTask对象在运作时，大体上是如何被UI线程和工作线程调用执行的。</p><h5 id="2-2-4-AsyncTask的内部状态"><a href="#2-2-4-AsyncTask的内部状态" class="headerlink" title="2.2.4 AsyncTask的内部状态"></a>2.2.4 AsyncTask的内部状态</h5><p>细心的读者还会发现，AsyncTask在finish()时会把自己的状态置为Status.FINISHED。简单说来，AsyncTask可以处于3种状态，分别是PENDING、RUNNING、FINISHED。这3种状态的切换很简单，示意图如下：</p><h5 id="2-2-5-cancel动作"><a href="#2-2-5-cancel动作" class="headerlink" title="2.2.5 cancel动作"></a>2.2.5 cancel动作</h5><p>当然，用户还可以随时中途放弃执行当前任务。不管是在主线程处理MESSAGE_POST_PROGRESS时，还是在工作线程处理doInBackground()时，用户都可以调用cancel()函数。该函数的代码如下：<br>【frameworks/base/core/java/android/os/AsyncTask.java】</p><pre><code class="java">public final boolean cancel(boolean mayInterruptIfRunning) {    mCancelled.set(true);    return mFuture.cancel(mayInterruptIfRunning);}</code></pre><p>【java/util/concurrent/FutureTask.java】</p><pre><code class="java">public boolean cancel(boolean mayInterruptIfRunning) {    return sync.innerCancel(mayInterruptIfRunning);}</code></pre><p>【java/util/concurrent/FutureTask.java】</p><pre><code class="java">boolean innerCancel(boolean mayInterruptIfRunning) {    for (;;) {        int s = getState();        if (ranOrCancelled(s))            return false;        if (compareAndSetState(s, CANCELLED))            break;    }    if (mayInterruptIfRunning) {        Thread r = runner;        if (r != null)            r.interrupt();    }    releaseShared(0);    done();    return true;}</code></pre><p>简单地说，cancel()动作会将mCancelled设为true，这样以后再调用isCancelled()时，就会返回true。前文我们已经看过AsyncTask的finish()的代码，现在再列一下：</p><pre><code class="java">private void finish(Result result) {    if (isCancelled()) {        onCancelled(result);    } else {        onPostExecute(result);    }    mStatus = Status.FINISHED;}</code></pre><p>可以看到，如果该任务是被用户cancel的，那么finish时执行的会是onCancelled()，而不是onPostExecute()。另外，为了确保在用户cancel任务之后，该任务能真的快速退出，我们应该在doInBackground()里周期性地检查一下isCancelled()的返回值，一旦发现，就立即退出。</p><h4 id="2-3-线程退出"><a href="#2-3-线程退出" class="headerlink" title="2.3 线程退出"></a>2.3 线程退出</h4><p>在将当前任务加入到AsyncTask执行时，如果想取消可以直接调用cancel，进行取消。cancel会把没有具体进入线程中的这个任务给取消了，但如果当前任务已经在线程中执行，那么可以在当前任务中不断判断是否cancel了，如果cancel了就return，这样达到线程退出的目的。具体代码如下：</p><pre><code class="java">@Overrideprotected Void doInBackground(Void... voids) {  if (isCancelled()) {    return null;  }  // 耗时任务中依然要判断是否cancel了，  for(int i = 0; i &lt; n; i++) {      if (isCancelled()) {        return null;    }    //TODO 原有循环内逻辑。  }  return null;}</code></pre><p>通过上面两个isCanceled进行判断，当当前任务cancel了，就能快速退出当前任务，避免不必要的消耗。</p><h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h3><p>关于AsyncTask的知识，我们就先说这么多。现在大体总结一下：<br>1）使用AsyncTask时，主要是重写其派生类的doInBackground()，而且该函数会在线程池的某个工作线程里被回调的；<br>2）必须在UI线程调用AsyncTask的execute()或executeOnExecutor()；<br>3）可以在doInBackground()里的合适时机调用publishProgress()，向UI线程通知工作进展；<br>4）可以随时调用cancel()，放弃执行任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-AsyncTask概述&quot;&gt;&lt;a href=&quot;#1-AsyncTask概述&quot; class=&quot;headerlink&quot; title=&quot;1. AsyncTask概述&quot;&gt;&lt;/a&gt;1. AsyncTask概述&lt;/h3&gt;&lt;p&gt;在Android平台上，要执行异步工作时，我们常
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android学习" scheme="http://yoursite.com/tags/Android%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>DexClassLoader加载过程分析</title>
    <link href="http://yoursite.com/2017/12/27/DexClassLoader%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/12/27/DexClassLoader加载过程分析/</id>
    <published>2017-12-27T10:02:07.000Z</published>
    <updated>2018-01-03T13:20:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在动态加载dex时，均采用的是DexClassLoader类进行加载，网上也有很多对如何加载进行分析的，现结合Android5.1源码进行分析。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>先来看一个实例，实例完成动态加载SD卡上的一个jar包，在jar包中Toast一段话。</p><pre><code class="java">public class ToastTest {    private Context context;    public ToastTest(Context context){        this.context = context;    }    public void call() {        Toast.makeText(context, &quot;call method&quot;, 0).show();    }    public String getData() {        return &quot;ToastTest&quot;;    }}</code></pre><p>将这个Java类打包生成test.jar包，然后放到SD目录下，然后利用DexClassLoader动态加载该jar包。</p><pre><code class="java">public class MainActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        File file = new File(Environment.getExternalStorageDirectory()                .toString() + File.separator + &quot;test.jar&quot;);        final File optimizedDexOutputPath = getDir(&quot;temp&quot;, Context.MODE_PRIVATE);        /*         * Parameters         * dexPath    需要装载的APK或者Jar文件的路径。包含多个路径用File.pathSeparator间隔开,在Android上默认是 &quot;:&quot;          * optimizedDirectory    优化后的dex文件存放目录，不能为null         * libraryPath    目标类中使用的C/C++库的列表,每个目录用File.pathSeparator间隔开; 可以为 null         * parent    该类装载器的父装载器，一般用当前执行类的装载器         */        new DexClassLoader(file.getAbsolutePath(),                optimizedDexOutputPath.getAbsolutePath(), null,                getClassLoader());          //利用反射原理去调用      try {            Class&lt;?&gt; testClass = classLoader.loadClass(&quot;com.demo.ToastTest&quot;);            Constructor&lt;?&gt; istructor = testClass.getConstructor(Context.class);            Method method = iclass.getMethod(&quot;call&quot;, null);            String data = (String) method.invoke(istructor.newInstance(this), null);            //System.out.println(data);            Log.d(&quot;ToastTest&quot;,data);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>上面代码<code>new DexClassLoader(file.getAbsolutePath(),optimizedDexOutputPath.getAbsolutePath(), null, getClassLoader());</code>完成了jar包的加载，下面从该步骤开始分析DexClassLoader是如何加载一个jar包或者dex的。</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><p>DexClassLoader类文件在\libcore\dalvik\src\main\java\dalvik\system\ DexClassLoader.java文件下</p><pre><code class="java">public class DexClassLoader extends BaseDexClassLoader {    /**     * Creates a {@code DexClassLoader} that finds interpreted and native     * code.  Interpreted classes are found in a set of DEX files contained     * in Jar or APK files.     *     * &lt;p&gt;The path lists are separated using the character specified by the     * {@code path.separator} system property, which defaults to {@code :}.     *     * @param dexPath the list of jar/apk files containing classes and     *     resources, delimited by {@code File.pathSeparator}, which     *     defaults to {@code &quot;:&quot;} on Android     * @param optimizedDirectory directory where optimized dex files     *     should be written; must not be {@code null}     * @param libraryPath the list of directories containing native     *     libraries, delimited by {@code File.pathSeparator}; may be     *     {@code null}     * @param parent the parent class loader     */    public DexClassLoader(String dexPath, String optimizedDirectory,            String libraryPath, ClassLoader parent) {        super(dexPath, new File(optimizedDirectory), libraryPath, parent);    }}</code></pre><p>代码很简单，直接调用了父类的构造方法。</p><pre><code class="java">public class BaseDexClassLoader extends ClassLoader {    private final DexPathList pathList;    /**     * Constructs an instance.     *     * @param dexPath the list of jar/apk files containing classes and     * resources, delimited by {@code File.pathSeparator}, which     * defaults to {@code &quot;:&quot;} on Android     * @param optimizedDirectory directory where optimized dex files     * should be written; may be {@code null}     * @param libraryPath the list of directories containing native     * libraries, delimited by {@code File.pathSeparator}; may be     * {@code null}     * @param parent the parent class loader     */    public BaseDexClassLoader(String dexPath, File optimizedDirectory,            String libraryPath, ClassLoader parent) {        super(parent);        this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);    }    ...}</code></pre><p>父类构造函数也很简单，首先调用了它自己的父类构造函数，然后new DaxPathList。下面先分析下DexPathList的构造函数。</p><pre><code class="java">    /**     * Constructs an instance.     *     * @param definingContext the context in which any as-yet unresolved     * classes should be defined     * @param dexPath list of dex/resource path elements, separated by     * {@code File.pathSeparator}     * @param libraryPath list of native library directory path elements,     * separated by {@code File.pathSeparator}     * @param optimizedDirectory directory where optimized {@code .dex} files     * should be found and written to, or {@code null} to use the default     * system directory for same     */    public DexPathList(ClassLoader definingContext, String dexPath,            String libraryPath, File optimizedDirectory) {        if (definingContext == null) {            throw new NullPointerException(&quot;definingContext == null&quot;);        }        if (dexPath == null) {            throw new NullPointerException(&quot;dexPath == null&quot;);        }        if (optimizedDirectory != null) {            if (!optimizedDirectory.exists())  {                throw new IllegalArgumentException(                        &quot;optimizedDirectory doesn&#39;t exist: &quot;                        + optimizedDirectory);            }            if (!(optimizedDirectory.canRead()                            &amp;&amp; optimizedDirectory.canWrite())) {                throw new IllegalArgumentException(                        &quot;optimizedDirectory not readable/writable: &quot;                        + optimizedDirectory);            }        }        //前面做了一些检查和异常处理        this.definingContext = definingContext;        ArrayList&lt;IOException&gt; suppressedExceptions = new ArrayList&lt;IOException&gt;();        this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory,                                           suppressedExceptions);        if (suppressedExceptions.size() &gt; 0) {            this.dexElementsSuppressedExceptions =                suppressedExceptions.toArray(new IOException[suppressedExceptions.size()]);        } else {            dexElementsSuppressedExceptions = null;        }        this.nativeLibraryDirectories = splitLibraryPath(libraryPath);    }</code></pre><p>其中关键代码是makeDexElements</p><pre><code class="java">    /**     * Makes an array of dex/resource path elements, one per element of     * the given array.     */    private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory,                                             ArrayList&lt;IOException&gt; suppressedExceptions) {        ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;();        /*         * Open all files and load the (direct or contained) dex files         * up front.         */        for (File file : files) {            File zip = null;            DexFile dex = null;            String name = file.getName();            //对每个文件进行处理            if (file.isDirectory()) {            //如果是文件直接加入到elements中                // We support directories for looking up resources.                // This is only useful for running libcore tests.                elements.add(new Element(file, true, null, null));            } else if (file.isFile()){                if (name.endsWith(DEX_SUFFIX)) {//是dex                    // Raw dex file (not inside a zip/jar).                    try {                        dex = loadDexFile(file, optimizedDirectory);                    } catch (IOException ex) {                        System.logE(&quot;Unable to load dex file: &quot; + file, ex);                    }                } else {//不是dex。即是压缩文件：jar zip apk                    zip = file;                    try {                        dex = loadDexFile(file, optimizedDirectory);                    } catch (IOException suppressed) {                        /*                         * IOException might get thrown &quot;legitimately&quot; by the DexFile constructor if                         * the zip file turns out to be resource-only (that is, no classes.dex file                         * in it).                         * Let dex == null and hang on to the exception to add to the tea-leaves for                         * when findClass returns null.                         */                        suppressedExceptions.add(suppressed);                    }                }            } else {                System.logW(&quot;ClassLoader referenced unknown path: &quot; + file);            }            if ((zip != null) || (dex != null)) {                elements.add(new Element(file, false, zip, dex));            }        }        return elements.toArray(new Element[elements.size()]);    }</code></pre><p>先看DexPathList内部是如何解析dex文件的，即分析loadDexFile代码</p><pre><code class="java">    /**     * Constructs a {@code DexFile} instance, as appropriate depending     * on whether {@code optimizedDirectory} is {@code null}.     */    private static DexFile loadDexFile(File file, File optimizedDirectory)            throws IOException {        if (optimizedDirectory == null) {            return new DexFile(file);        } else {            String optimizedPath = optimizedPathFor(file, optimizedDirectory);            return DexFile.loadDex(file.getPath(), optimizedPath, 0);        }    }</code></pre><p>如果被优化后的路径是空，那么直接返回new DexFile(file)。optimizedPathFor是判断优化路径，代码如下：</p><pre><code class="java">    /**     * Converts a dex/jar file path and an output directory to an     * output file path for an associated optimized dex file.     */    private static String optimizedPathFor(File path,            File optimizedDirectory) {        /*         * Get the filename component of the path, and replace the         * suffix with &quot;.dex&quot; if that&#39;s not already the suffix.         *         * We don&#39;t want to use &quot;.odex&quot;, because the build system uses         * that for files that are paired with resource-only jar         * files. If the VM can assume that there&#39;s no classes.dex in         * the matching jar, it doesn&#39;t need to open the jar to check         * for updated dependencies, providing a slight performance         * boost at startup. The use of &quot;.dex&quot; here matches the use on         * files in /data/dalvik-cache.         */        String fileName = path.getName();        if (!fileName.endsWith(DEX_SUFFIX)) {            int lastDot = fileName.lastIndexOf(&quot;.&quot;);            if (lastDot &lt; 0) {                fileName += DEX_SUFFIX;            } else {                StringBuilder sb = new StringBuilder(lastDot + 4);                sb.append(fileName, 0, lastDot);                sb.append(DEX_SUFFIX);                fileName = sb.toString();            }        }        File result = new File(optimizedDirectory, fileName);        return result.getPath();    }</code></pre><p>真正执行代码优化的是DexFile.loadDex，代码如下：</p><pre><code class="java">    /**     * Open a DEX file, specifying the file in which the optimized DEX     * data should be written.  If the optimized form exists and appears     * to be current, it will be used; if not, the VM will attempt to     * regenerate it.     *     * This is intended for use by applications that wish to download     * and execute DEX files outside the usual application installation     * mechanism.  This function should not be called directly by an     * application; instead, use a class loader such as     * dalvik.system.DexClassLoader.     *     * @param sourcePathName     *  Jar or APK file with &quot;classes.dex&quot;.  (May expand this to include     *  &quot;raw DEX&quot; in the future.)     * @param outputPathName     *  File that will hold the optimized form of the DEX data.     * @param flags     *  Enable optional features.  (Currently none defined.)     * @return     *  A new or previously-opened DexFile.     * @throws IOException     *  If unable to open the source or output file.     */    static public DexFile loadDex(String sourcePathName, String outputPathName,        int flags) throws IOException {        /*         * TODO: we may want to cache previously-opened DexFile objects.         * The cache would be synchronized with close().  This would help         * us avoid mapping the same DEX more than once when an app         * decided to open it multiple times.  In practice this may not         * be a real issue.         */        return new DexFile(sourcePathName, outputPathName, flags);    }</code></pre><p>也就是直接返回了DexFile，下面看看DexFile构造函数做了哪些事情：</p><pre><code class="java">    /**     * Opens a DEX file from a given filename, using a specified file     * to hold the optimized data.     *     * @param sourceName     *  Jar or APK file with &quot;classes.dex&quot;.     * @param outputName     *  File that will hold the optimized form of the DEX data.     * @param flags     *  Enable optional features.     */    private DexFile(String sourceName, String outputName, int flags) throws IOException {        if (outputName != null) {            try {                String parent = new File(outputName).getParent();                if (Libcore.os.getuid() != Libcore.os.stat(parent).st_uid) {                    throw new IllegalArgumentException(&quot;Optimized data directory &quot; + parent                            + &quot; is not owned by the current user. Shared storage cannot protect&quot;                            + &quot; your application from code injection attacks.&quot;);                }            } catch (ErrnoException ignored) {                // assume we&#39;ll fail with a more contextual error later            }        }        //前面是异常判断        mCookie = openDexFile(sourceName, outputName, flags);        mFileName = sourceName;        guard.open(&quot;close&quot;);        //System.out.println(&quot;DEX FILE cookie is &quot; + mCookie + &quot; sourceName=&quot; + sourceName + &quot; outputName=&quot; + outputName);    }</code></pre><p>关键代码:openDexFile</p><pre><code class="java">    /*     * Open a DEX file.  The value returned is a magic VM cookie.  On     * failure, an IOException is thrown.     */    private static long openDexFile(String sourceName, String outputName, int flags) throws IOException {        // Use absolute paths to enable the use of relative paths when testing on host.        return openDexFileNative(new File(sourceName).getAbsolutePath(),                                 (outputName == null) ? null : new File(outputName).getAbsolutePath(),                                 flags);    }    /*     * Open a DEX file.  The value returned is a magic VM cookie.  On     * failure, an IOException is thrown.     */    private static native long openDexFileNative(String sourceName, String outputName, int flags);</code></pre><p>这里也就直接调用了native方法进行优化。继续跟进代码在\dalvik\vm\native\dalvik_system_DexFile.cpp文件中的openDexFileNative() 函数，接下重点就在这个函数：</p><pre><code class="cpp">static void Dalvik_dalvik_system_DexFile_openDexFileNative(const u4* args,    JValue* pResult){//args[0]: sourceName java层传入的//args[1]: outputName        StringObject* sourceNameObj = (StringObject*) args[0];    StringObject* outputNameObj = (StringObject*) args[1];    DexOrJar* pDexOrJar = NULL;    JarFile* pJarFile;RawDexFile* pRawDexFile;//DexOrJar*  JarFile*   RawDexFile* 目录    char* sourceName;    char* outputName;    //……    sourceName = dvmCreateCstrFromString(sourceNameObj);    if (outputNameObj != NULL)        outputName = dvmCreateCstrFromString(outputNameObj);    else        outputName = NULL;/*判断要加载的dex是否为系统中的dex文件* gDvm ？？？*/    if (dvmClassPathContains(gDvm.bootClassPath, sourceName)) {        ALOGW(&quot;Refusing to reopen boot DEX &#39;%s&#39;&quot;, sourceName);        dvmThrowIOException(            &quot;Re-opening BOOTCLASSPATH DEX files is not allowed&quot;);        free(sourceName);        free(outputName);        RETURN_VOID();    }    /*     * Try to open it directly as a DEX if the name ends with &quot;.dex&quot;.     * If that fails (or isn&#39;t tried in the first place), try it as a     * Zip with a &quot;classes.dex&quot; inside.     */    //判断sourcename扩展名是否是.dex    if (hasDexExtension(sourceName)            &amp;&amp; dvmRawDexFileOpen(sourceName, outputName, &amp;pRawDexFile, false) == 0) {        ALOGV(&quot;Opening DEX file &#39;%s&#39; (DEX)&quot;, sourceName);        pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar));        pDexOrJar-&gt;isDex = true;        pDexOrJar-&gt;pRawDexFile = pRawDexFile;        pDexOrJar-&gt;pDexMemory = NULL;    //.jar文件    } else if (dvmJarFileOpen(sourceName, outputName, &amp;pJarFile, false) == 0) {        ALOGV(&quot;Opening DEX file &#39;%s&#39; (Jar)&quot;, sourceName);        pDexOrJar = (DexOrJar*) malloc(sizeof(DexOrJar));        pDexOrJar-&gt;isDex = false;        pDexOrJar-&gt;pJarFile = pJarFile;        pDexOrJar-&gt;pDexMemory = NULL;} else {//都不满足，抛出异常        ALOGV(&quot;Unable to open DEX file &#39;%s&#39;&quot;, sourceName);        dvmThrowIOException(&quot;unable to open DEX file&quot;);    }if (pDexOrJar != NULL) {        pDexOrJar-&gt;fileName = sourceName;    //把pDexOr这个结构体中的内容加到gDvm中的userDexFile结构的hash表中，便于Dalvik以后的查找        addToDexFileTable(pDexOrJar);    } else {        free(sourceName);    }    free(outputName);    RETURN_PTR(pDexOrJar);}</code></pre><p>再看对.dex文件的处理函数dvmRawDexFileOpen（\dalvik\vm\RawDexFile.cpp）的处理</p><pre><code class="cpp">/* See documentation comment in header. */int dvmRawDexFileOpen(const char* fileName, const char* odexOutputName,    RawDexFile** ppRawDexFile, bool isBootstrap){    DvmDex* pDvmDex = NULL;    char* cachedName = NULL;    int result = -1;    int dexFd = -1;    int optFd = -1;    u4 modTime = 0;    u4 adler32 = 0;    size_t fileSize = 0;    bool newFile = false;    bool locked = false;    dexFd = open(fileName, O_RDONLY);  //打开dex文件    if (dexFd &lt; 0) goto bail;    /* If we fork/exec into dexopt, don&#39;t let it inherit the open fd. */dvmSetCloseOnExec(dexFd);//dexfd不继承//校验dex文件的标志，将第8字节开始的4个字节赋值给adler32。    if (verifyMagicAndGetAdler32(dexFd, &amp;adler32) &lt; 0) {        ALOGE(&quot;Error with header for %s&quot;, fileName);        goto bail;    }    //得到dex文件的大小和修改时间，保存在modTime和filesize中    if (getModTimeAndSize(dexFd, &amp;modTime, &amp;fileSize) &lt; 0) {        ALOGE(&quot;Error with stat for %s&quot;, fileName);        goto bail;    }    //odexOutputName就是odex文件名，如果odexOutputName为空，则自动生成一个。    if (odexOutputName == NULL) {        cachedName = dexOptGenerateCacheFileName(fileName, NULL);        if (cachedName == NULL)            goto bail;    } else {        cachedName = strdup(odexOutputName);       }    //主要是验证缓存文件名的正确性，之后将dexOptHeader结构写入fd中    optFd = dvmOpenCachedDexFile(fileName, cachedName, modTime,        adler32, isBootstrap, &amp;newFile, /*createIfMissing=*/true);    locked = true;    if (newFile) {        u8 startWhen, copyWhen, endWhen;        bool result;        off_t dexOffset;        dexOffset = lseek(optFd, 0, SEEK_CUR);  //文件指针的位置        result = (dexOffset &gt; 0);        if (result) {            startWhen = dvmGetRelativeTimeUsec();    //将dex文件中的内容拷贝到当前odex文件，也就是dexOffset开始            result = copyFileToFile(optFd, dexFd, fileSize) == 0;            copyWhen = dvmGetRelativeTimeUsec();        }        if (result) {    //优化odex文件            result = dvmOptimizeDexFile(optFd, dexOffset, fileSize,                fileName, modTime, adler32, isBootstrap);        }    }    /*     * Map the cached version.  This immediately rewinds the fd, so it     * doesn&#39;t have to be seeked anywhere in particular.     *///将odex文件映射到内存空间(mmap)，并用mprotect将属性置为只读属性，并将映射的dex结构放在pDvmDex数据结构中，具体代码在下面。    if (dvmDexFileOpenFromFd(optFd, &amp;pDvmDex) != 0) {        ALOGI(&quot;Unable to map cached %s&quot;, fileName);        goto bail;    }……}</code></pre><pre><code class="cpp">//Dalvik/vm/RewDexFile.cppstatic int verifyMagicAndGetAdler32(int fd, u4 *adler32){    u1 headerStart[12];    ssize_t amt = read(fd, headerStart, sizeof(headerStart));    if (amt &lt; 0) {        ALOGE(&quot;Unable to read header: %s&quot;, strerror(errno));        return -1;    }    if (amt != sizeof(headerStart)) {        ALOGE(&quot;Unable to read full header (only got %d bytes)&quot;, (int) amt);        return -1;    }    if (!dexHasValidMagic((DexHeader*) (void*) headerStart)) {        return -1;    }    *adler32 = (u4) headerStart[8]        | (((u4) headerStart[9]) &lt;&lt; 8)        | (((u4) headerStart[10]) &lt;&lt; 16)        | (((u4) headerStart[11]) &lt;&lt; 24);    return 0;}</code></pre><pre><code class="cpp">//dalvik\vm\DvmDex.cpp/* * Given an open optimized DEX file, map it into read-only shared memory and * parse the contents. * * Returns nonzero on error. */int dvmDexFileOpenFromFd(int fd, DvmDex** ppDvmDex){    DvmDex* pDvmDex;    DexFile* pDexFile;    MemMapping memMap;    int parseFlags = kDexParseDefault;    int result = -1;    if (gDvm.verifyDexChecksum)        parseFlags |= kDexParseVerifyChecksum;    if (lseek(fd, 0, SEEK_SET) &lt; 0) {        ALOGE(&quot;lseek rewind failed&quot;);        goto bail;    }    //mmap映射fd文件,就是我们之前的odex文件   if (sysMapFileInShmemWritableReadOnly(fd, &amp;memMap) != 0) {        ALOGE(&quot;Unable to map file&quot;);        goto bail;    }    pDexFile = dexFileParse((u1*)memMap.addr, memMap.length, parseFlags);    if (pDexFile == NULL) {        ALOGE(&quot;DEX parse failed&quot;);        sysReleaseShmem(&amp;memMap);        goto bail;    }    pDvmDex = allocateAuxStructures(pDexFile);    if (pDvmDex == NULL) {        dexFileFree(pDexFile);        sysReleaseShmem(&amp;memMap);        goto bail;    }/* tuck this into the DexFile so it gets released later *///将映射odex文件的内存拷贝到DvmDex的结构中    sysCopyMap(&amp;pDvmDex-&gt;memMap, &amp;memMap);    pDvmDex-&gt;isMappedReadOnly = true;    *ppDvmDex = pDvmDex;    result = 0;bail:    return result;}</code></pre><pre><code class="cpp">/*dalvik\libdex\SysUtil.cpp*/int sysMapFileInShmemWritableReadOnly(int fd, MemMapping* pMap){    off_t start;    size_t length;    void* memPtr;assert(pMap != NULL);//获得文件长度和文件开始地址    if (getFileStartAndLength(fd, &amp;start, &amp;length) &lt; 0)        return -1;//映射文件    memPtr = mmap(NULL, length, PROT_READ | PROT_WRITE, MAP_FILE | MAP_PRIVATE,            fd, start);    //……//将保护属性置为只读属性    if (mprotect(memPtr, length, PROT_READ) &lt; 0) {      //…….    }    pMap-&gt;baseAddr = pMap-&gt;addr = memPtr;    pMap-&gt;baseLength = pMap-&gt;length = length;return 0;//……}</code></pre><p>这些就是对dex的文件处理，对压缩包zip,jar,apk的有兴趣的可以直接分析下源码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>首先是对文件名的修正，后缀名置为”.dex”作为输出文件，然后生个一个DexPathList对象函数直接返回一个DexPathList对象，</p><p>在DexPathList的构造函数中调用makeDexElements()函数，在makeDexElement()函数中调用loadDexFile()开始对.dex或者是.jar .zip .apk文件进行处理，</p><p>跟入loadDexFile()函数中，会发现里面做的工作很简单，调用optimizedPathFor()函数对optimizedDiretcory路径进行修正。</p><p>之后才真正通过DexFile.loadDex()开始加载文件中的数据，其中的加载也只是返回一个DexFile对象。</p><p>在DexFile类的构造函数中，重点便放在了其调用的openDexFile()函数，在openDexFile()中调用了openDexFileNative()真正进入native层，</p><p>在openDexFileNative()的真正实现中，对于后缀名为.dex的文件或者其他文件(.jar .apk .zip)分开进行处理：</p><p>.dex文件调用dvmRawDexFileOpen()；<br>其他文件调用dvmJarFileOpen()。</p><p>在dvmRawDexFileOpen()函数中，检验dex文件的标志，检验odex文件的缓存名称，之后将dex文件拷贝到odex文件中，并对odex进行优化</p><p>调用dvmDexFileOpenFromFd()对优化后的odex文件进行映射，通过mprotect置为”只读”属性并将映射的内存结构保存在DvmDex*结构中。</p><p>dvmJarFileOpen()先对文件进行映射，结构保存在ZipArchive中，然后再尝试以文件名作为dex文件名来“打开”文件，<br>如果失败，则调用dexZipFindEntry在ZipArchive的名称hash表中找名为”class.dex”的文件,然后创建odex文件，下面就和<br>dvmRawDexFileOpen()一样了，就是对dex文件进行优化和映射。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在动态加载dex时，均采用的是DexClassLoader类进行加载，网上也有很多对如何加载进行分析的，现结合Android5.1源码进行分析。&lt;/p&gt;
&lt;h4 id=&quot;实例&quot;&gt;&lt;a href=&quot;#实例&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Dex类加载" scheme="http://yoursite.com/tags/Dex%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
</feed>
